// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-vscext.ts via github.com/metaleap/vscode-appz/src/gen/main.ts

import * as vscode from 'vscode'
import * as ppio from './procspipeio'
const noOp = (_:any) => {}

export function handle(msg: ppio.IpcMsg, prog: ppio.Prog, remoteCancellationTokens: string[]): Thenable<any> | vscode.Disposable {
	const idxdot = msg.qName.lastIndexOf('.')
	const [apiname, methodname] = (idxdot > 0) ? [msg.qName.slice(0, idxdot), msg.qName.slice(idxdot + 1)] : ['', msg.qName]
	switch (apiname) {
		case "window":
			switch (methodname) {
				case "showInformationMessage1": {
					const arg_message = (msg.data['message']) as string
					const arg_items = (msg.data['items'] || []) as string[]
					const ret = vscode.window.showInformationMessage(arg_message, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showInformationMessage2": {
					const arg_message = (msg.data['message']) as string
					const arg_options = (msg.data['options']) as MessageOptions
					const arg_items = (msg.data['items'] || []) as string[]
					const ret = vscode.window.showInformationMessage(arg_message, arg_options, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showInformationMessage3": {
					const arg_message = (msg.data['message']) as string
					const arg_items = (msg.data['items'] || []) as MessageItem[]
					const ret = vscode.window.showInformationMessage(arg_message, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showInformationMessage4": {
					const arg_message = (msg.data['message']) as string
					const arg_options = (msg.data['options']) as MessageOptions
					const arg_items = (msg.data['items'] || []) as MessageItem[]
					const ret = vscode.window.showInformationMessage(arg_message, arg_options, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showWarningMessage1": {
					const arg_message = (msg.data['message']) as string
					const arg_items = (msg.data['items'] || []) as string[]
					const ret = vscode.window.showWarningMessage(arg_message, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showWarningMessage2": {
					const arg_message = (msg.data['message']) as string
					const arg_options = (msg.data['options']) as MessageOptions
					const arg_items = (msg.data['items'] || []) as string[]
					const ret = vscode.window.showWarningMessage(arg_message, arg_options, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showWarningMessage3": {
					const arg_message = (msg.data['message']) as string
					const arg_items = (msg.data['items'] || []) as MessageItem[]
					const ret = vscode.window.showWarningMessage(arg_message, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showWarningMessage4": {
					const arg_message = (msg.data['message']) as string
					const arg_options = (msg.data['options']) as MessageOptions
					const arg_items = (msg.data['items'] || []) as MessageItem[]
					const ret = vscode.window.showWarningMessage(arg_message, arg_options, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showErrorMessage1": {
					const arg_message = (msg.data['message']) as string
					const arg_items = (msg.data['items'] || []) as string[]
					const ret = vscode.window.showErrorMessage(arg_message, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showErrorMessage2": {
					const arg_message = (msg.data['message']) as string
					const arg_options = (msg.data['options']) as MessageOptions
					const arg_items = (msg.data['items'] || []) as string[]
					const ret = vscode.window.showErrorMessage(arg_message, arg_options, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showErrorMessage3": {
					const arg_message = (msg.data['message']) as string
					const arg_items = (msg.data['items'] || []) as MessageItem[]
					const ret = vscode.window.showErrorMessage(arg_message, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showErrorMessage4": {
					const arg_message = (msg.data['message']) as string
					const arg_options = (msg.data['options']) as MessageOptions
					const arg_items = (msg.data['items'] || []) as MessageItem[]
					const ret = vscode.window.showErrorMessage(arg_message, arg_options, ...arg_items, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showInputBox": {
					const arg_options = (msg.data['options']) as InputBoxOptions
					if (arg_options && arg_options.validateInput_AppzFuncId && arg_options.validateInput_AppzFuncId.length)
						arg_options.validateInput = (a0) => prog.callBack("window.showInputBox", true, arg_options.validateInput_AppzFuncId, a0)
					let ctid = msg.data['token'] as string, arg_token = prog.cancellerToken(ctid)
					if (!arg_token)
						arg_token = prog.cancellers[''].token
					else
						remoteCancellationTokens.push(ctid)
					const ret = vscode.window.showInputBox(arg_options, arg_token, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showQuickPick1": {
					const arg_items = (msg.data['items']) as string[]
					const arg_options = (msg.data['options']) as QuickPickOptions
					if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
						arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick1", true, arg_options.onDidSelectItem_AppzFuncId, a0)
					let ctid = msg.data['token'] as string, arg_token = prog.cancellerToken(ctid)
					if (!arg_token)
						arg_token = prog.cancellers[''].token
					else
						remoteCancellationTokens.push(ctid)
					const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showQuickPick2": {
					const arg_items = (msg.data['items']) as string[]
					const arg_options = (msg.data['options']) as QuickPickOptions
					if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
						arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick2", true, arg_options.onDidSelectItem_AppzFuncId, a0)
					let ctid = msg.data['token'] as string, arg_token = prog.cancellerToken(ctid)
					if (!arg_token)
						arg_token = prog.cancellers[''].token
					else
						remoteCancellationTokens.push(ctid)
					const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showQuickPick3": {
					const arg_items = (msg.data['items']) as QuickPickItem[]
					const arg_options = (msg.data['options']) as QuickPickOptions
					if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
						arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick3", true, arg_options.onDidSelectItem_AppzFuncId, a0)
					let ctid = msg.data['token'] as string, arg_token = prog.cancellerToken(ctid)
					if (!arg_token)
						arg_token = prog.cancellers[''].token
					else
						remoteCancellationTokens.push(ctid)
					const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showQuickPick4": {
					const arg_items = (msg.data['items']) as QuickPickItem[]
					const arg_options = (msg.data['options']) as QuickPickOptions
					if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
						arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick4", true, arg_options.onDidSelectItem_AppzFuncId, a0)
					let ctid = msg.data['token'] as string, arg_token = prog.cancellerToken(ctid)
					if (!arg_token)
						arg_token = prog.cancellers[''].token
					else
						remoteCancellationTokens.push(ctid)
					const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "setStatusBarMessage1": {
					const arg_text = (msg.data['text']) as string
					const arg_hideAfterTimeout = (msg.data['hideAfterTimeout']) as number
					const ret = vscode.window.setStatusBarMessage(arg_text, arg_hideAfterTimeout, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "setStatusBarMessage2": {
					const arg_text = (msg.data['text']) as string
					const ret = vscode.window.setStatusBarMessage(arg_text, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showSaveDialog": {
					const arg_options = (msg.data['options']) as SaveDialogOptions
					const ret = vscode.window.showSaveDialog(arg_options, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showOpenDialog": {
					const arg_options = (msg.data['options']) as OpenDialogOptions
					const ret = vscode.window.showOpenDialog(arg_options, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "showWorkspaceFolderPick": {
					const arg_options = (msg.data['options']) as WorkspaceFolderPickOptions
					const ret = vscode.window.showWorkspaceFolderPick(arg_options, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "state": {
					return Promise.resolve(vscode.window.state)
				}
				case "onDidChangeWindowState": {
					const _fnid_listener = msg.data['listener'] as string
					return (!(_fnid_listener && _fnid_listener.length))
						? ppio.promRej("window.onDidChangeWindowState.listener", msg.data)
						: vscode.window.onDidChangeWindowState((a0) => {
							if (prog && prog.proc)
								prog.callBack("window.onDidChangeWindowState", false, _fnid_listener, a0).then(noOp, noOp)
						})
				}
				case "createStatusBarItem": {
					const arg_alignment = (msg.data['alignment']) as StatusBarAlignment
					const arg_priority = (msg.data['priority']) as number
					const ret = vscode.window.createStatusBarItem(arg_alignment, arg_priority, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "createOutputChannel": {
					const arg_name = (msg.data['name']) as string
					const ret = vscode.window.createOutputChannel(arg_name, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "createTextEditorDecorationType": {
					const arg_options = (msg.data['options']) as DecorationRenderOptions
					const ret = vscode.window.createTextEditorDecorationType(arg_options, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "createInputBox": {
					const ret = vscode.window.createInputBox()
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "createQuickPick": {
					const ret = vscode.window.createQuickPick()
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				default:
					throw (methodname)
			}
		case "env":
			switch (methodname) {
				case "openExternal": {
					const arg_target = ppio.tryUnmarshalUri(msg.data['target'])
					if (!arg_target)
						return ppio.promRej("env.openExternal", msg.data['target'])
					const ret = vscode.env.openExternal(arg_target, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "appName": {
					return Promise.resolve(vscode.env.appName)
				}
				case "appRoot": {
					return Promise.resolve(vscode.env.appRoot)
				}
				case "language": {
					return Promise.resolve(vscode.env.language)
				}
				case "machineId": {
					return Promise.resolve(vscode.env.machineId)
				}
				case "remoteName": {
					return Promise.resolve(vscode.env.remoteName)
				}
				case "sessionId": {
					return Promise.resolve(vscode.env.sessionId)
				}
				case "shell": {
					return Promise.resolve(vscode.env.shell)
				}
				case "uriScheme": {
					return Promise.resolve(vscode.env.uriScheme)
				}
				case "AllProperties": {
					return Promise.resolve({
						appName: vscode.env.appName,
						appRoot: vscode.env.appRoot,
						language: vscode.env.language,
						machineId: vscode.env.machineId,
						remoteName: vscode.env.remoteName,
						sessionId: vscode.env.sessionId,
						shell: vscode.env.shell,
						uriScheme: vscode.env.uriScheme,
					})
				}
				default:
					throw (methodname)
			}
		case "clipboard":
			switch (methodname) {
				case "readText": {
					const ret = vscode.env.clipboard.readText()
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "writeText": {
					const arg_value = (msg.data['value']) as string
					const ret = vscode.env.clipboard.writeText(arg_value, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				default:
					throw (methodname)
			}
		case "workspace":
			switch (methodname) {
				case "name": {
					return Promise.resolve(vscode.workspace.name)
				}
				case "workspaceFile": {
					return Promise.resolve(vscode.workspace.workspaceFile)
				}
				case "saveAll": {
					const arg_includeUntitled = (msg.data['includeUntitled']) as boolean
					const ret = vscode.workspace.saveAll(arg_includeUntitled, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "onDidChangeWorkspaceFolders": {
					const _fnid_listener = msg.data['listener'] as string
					return (!(_fnid_listener && _fnid_listener.length))
						? ppio.promRej("workspace.onDidChangeWorkspaceFolders.listener", msg.data)
						: vscode.workspace.onDidChangeWorkspaceFolders((a0) => {
							if (prog && prog.proc)
								prog.callBack("workspace.onDidChangeWorkspaceFolders", false, _fnid_listener, a0).then(noOp, noOp)
						})
				}
				case "getWorkspaceFolder": {
					const arg_uri = ppio.tryUnmarshalUri(msg.data['uri'])
					if (!arg_uri)
						return ppio.promRej("workspace.getWorkspaceFolder", msg.data['uri'])
					const ret = vscode.workspace.getWorkspaceFolder(arg_uri, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "workspaceFolders": {
					return Promise.resolve(vscode.workspace.workspaceFolders)
				}
				case "findFiles": {
					const arg_include = (msg.data['include']) as string
					const arg_exclude = (msg.data['exclude']) as string
					const arg_maxResults = (msg.data['maxResults']) as number
					let ctid = msg.data['token'] as string, arg_token = prog.cancellerToken(ctid)
					if (!arg_token)
						arg_token = prog.cancellers[''].token
					else
						remoteCancellationTokens.push(ctid)
					const ret = vscode.workspace.findFiles(arg_include, arg_exclude, arg_maxResults, arg_token, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "asRelativePath": {
					const arg_pathOrUri = (msg.data['pathOrUri']) as string
					const arg_includeWorkspaceFolder = (msg.data['includeWorkspaceFolder']) as boolean
					const ret = vscode.workspace.asRelativePath(arg_pathOrUri, arg_includeWorkspaceFolder, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "AllProperties": {
					return Promise.resolve({
						name: vscode.workspace.name,
						workspaceFile: vscode.workspace.workspaceFile,
						workspaceFolders: vscode.workspace.workspaceFolders,
					})
				}
				default:
					throw (methodname)
			}
		case "languages":
			switch (methodname) {
				case "getLanguages": {
					const ret = vscode.languages.getLanguages()
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "onDidChangeDiagnostics": {
					const _fnid_listener = msg.data['listener'] as string
					return (!(_fnid_listener && _fnid_listener.length))
						? ppio.promRej("languages.onDidChangeDiagnostics.listener", msg.data)
						: vscode.languages.onDidChangeDiagnostics((a0) => {
							if (prog && prog.proc)
								prog.callBack("languages.onDidChangeDiagnostics", false, _fnid_listener, a0).then(noOp, noOp)
						})
				}
				default:
					throw (methodname)
			}
		case "extensions":
			switch (methodname) {
				case "onDidChange": {
					const _fnid_listener = msg.data['listener'] as string
					return (!(_fnid_listener && _fnid_listener.length))
						? ppio.promRej("extensions.onDidChange.listener", msg.data)
						: vscode.extensions.onDidChange(() => {
							if (prog && prog.proc)
								prog.callBack("extensions.onDidChange", false, _fnid_listener, ).then(noOp, noOp)
						})
				}
				default:
					throw (methodname)
			}
		case "commands":
			switch (methodname) {
				case "registerCommand": {
					const arg_command = (msg.data['command']) as string
					const _fnid_callback = msg.data['callback'] as string
					if (!(_fnid_callback && _fnid_callback.length))
						return ppio.promRej("commands.registerCommand", msg.data)
					const arg_callback = (..._0: any[]): any => {
						if (prog && prog.proc)
							return prog.callBack("commands.registerCommand", true, _fnid_callback, _0)
						return undefined
					}
					const ret = vscode.commands.registerCommand(arg_command, arg_callback, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "executeCommand": {
					const arg_command = (msg.data['command']) as string
					const arg_rest = (msg.data['rest'] || []) as any[]
					const ret = vscode.commands.executeCommand(arg_command, ...arg_rest, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "getCommands": {
					const arg_filterInternal = (msg.data['filterInternal']) as boolean
					const ret = vscode.commands.getCommands(arg_filterInternal, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				default:
					throw (methodname)
			}
		case "StatusBarItem":
			const thisStatusBarItem = prog.objects[msg.data[""]] as StatusBarItem
			if (!thisStatusBarItem)
				throw "Called vscode.StatusBarItem." + methodname + " for an already disposed-and-forgotten instance"
			switch (methodname) {
				case "show": {
					thisStatusBarItem.show()
					return Promise.resolve({ alignment: thisStatusBarItem.alignment, priority: thisStatusBarItem.priority, text: thisStatusBarItem.text, tooltip: thisStatusBarItem.tooltip, color: (thisStatusBarItem.color && ((thisStatusBarItem.color as any)["id"])) ? ((thisStatusBarItem.color as any)["id"]) : thisStatusBarItem.color, command: thisStatusBarItem.command })
				}
				case "hide": {
					thisStatusBarItem.hide()
					return Promise.resolve({ alignment: thisStatusBarItem.alignment, priority: thisStatusBarItem.priority, text: thisStatusBarItem.text, tooltip: thisStatusBarItem.tooltip, color: (thisStatusBarItem.color && ((thisStatusBarItem.color as any)["id"])) ? ((thisStatusBarItem.color as any)["id"]) : thisStatusBarItem.color, command: thisStatusBarItem.command })
				}
				case "appzObjPropsGet": {
					return Promise.resolve({ alignment: thisStatusBarItem.alignment, priority: thisStatusBarItem.priority, text: thisStatusBarItem.text, tooltip: thisStatusBarItem.tooltip, color: (thisStatusBarItem.color && ((thisStatusBarItem.color as any)["id"])) ? ((thisStatusBarItem.color as any)["id"]) : thisStatusBarItem.color, command: thisStatusBarItem.command })
				}
				case "appzObjPropsSet": {
					const allUpdates = msg.data['allUpdates'] as { [_:string]: any }
					if (!allUpdates)
						return ppio.promRej("StatusBarItem.set#allUpdates", msg.data)
					const prop_text = allUpdates["text"] as string
					if (prop_text !== undefined) {
						let val = prop_text
						if (val !== thisStatusBarItem.text)
							thisStatusBarItem.text = val
					}
					const prop_tooltip = allUpdates["tooltip"] as string
					if (prop_tooltip !== undefined) {
						let val = prop_tooltip
						if (val !== thisStatusBarItem.tooltip)
							thisStatusBarItem.tooltip = val
					}
					const prop_color = allUpdates["color"] as string
					if (prop_color !== undefined) {
						let val = (!((typeof prop_color === "string") && prop_color && prop_color.length)) ? undefined : prop_color.startsWith("#") ? prop_color : new vscode.ThemeColor(prop_color)
						if (val !== thisStatusBarItem.color)
							thisStatusBarItem.color = val
					}
					const prop_command = allUpdates["command"] as string
					if (prop_command !== undefined) {
						let val = prop_command
						if (val !== thisStatusBarItem.command)
							thisStatusBarItem.command = val
					}
					return Promise.resolve()
				}
				default:
					throw methodname
			}
		case "OutputChannel":
			const thisOutputChannel = prog.objects[msg.data[""]] as OutputChannel
			if (!thisOutputChannel)
				throw "Called vscode.OutputChannel." + methodname + " for an already disposed-and-forgotten instance"
			switch (methodname) {
				case "append": {
					const arg_value = (msg.data['value']) as string
					thisOutputChannel.append(arg_value, )
					return Promise.resolve({ name: thisOutputChannel.name })
				}
				case "appendLine": {
					const arg_value = (msg.data['value']) as string
					thisOutputChannel.appendLine(arg_value, )
					return Promise.resolve({ name: thisOutputChannel.name })
				}
				case "clear": {
					thisOutputChannel.clear()
					return Promise.resolve({ name: thisOutputChannel.name })
				}
				case "show": {
					const arg_preserveFocus = (msg.data['preserveFocus']) as boolean
					thisOutputChannel.show(arg_preserveFocus, )
					return Promise.resolve({ name: thisOutputChannel.name })
				}
				case "hide": {
					thisOutputChannel.hide()
					return Promise.resolve({ name: thisOutputChannel.name })
				}
				case "appzObjPropsGet": {
					return Promise.resolve({ name: thisOutputChannel.name })
				}
				default:
					throw methodname
			}
		case "TextEditorDecorationType":
			const thisTextEditorDecorationType = prog.objects[msg.data[""]] as TextEditorDecorationType
			if (!thisTextEditorDecorationType)
				throw "Called vscode.TextEditorDecorationType." + methodname + " for an already disposed-and-forgotten instance"
			switch (methodname) {
				case "appzObjPropsGet": {
					return Promise.resolve({ key: thisTextEditorDecorationType.key })
				}
				default:
					throw methodname
			}
		case "InputBox":
			const thisInputBox = prog.objects[msg.data[""]] as InputBox
			if (!thisInputBox)
				throw "Called vscode.InputBox." + methodname + " for an already disposed-and-forgotten instance"
			switch (methodname) {
				case "onDidChangeValue": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("InputBox.onDidChangeValue.handler", msg.data)
					const arg_handler = (_0: string): unknown => {
						if (prog && prog.proc)
							return prog.callBack("InputBox.onDidChangeValue.handler", false, _fnid_handler, _0, ({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }))
						return undefined
					}
					const ret = thisInputBox.onDidChangeValue(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "onDidAccept": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("InputBox.onDidAccept.handler", msg.data)
					const arg_handler = (): unknown => {
						if (prog && prog.proc)
							return prog.callBack("InputBox.onDidAccept.handler", false, _fnid_handler, ({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }))
						return undefined
					}
					const ret = thisInputBox.onDidAccept(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "show": {
					thisInputBox.show()
					return Promise.resolve({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut })
				}
				case "hide": {
					thisInputBox.hide()
					return Promise.resolve({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut })
				}
				case "onDidHide": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("InputBox.onDidHide.handler", msg.data)
					const arg_handler = (): unknown => {
						if (prog && prog.proc)
							return prog.callBack("InputBox.onDidHide.handler", false, _fnid_handler, ({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }))
						return undefined
					}
					const ret = thisInputBox.onDidHide(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "appzObjPropsGet": {
					return Promise.resolve({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut })
				}
				case "appzObjPropsSet": {
					const allUpdates = msg.data['allUpdates'] as { [_:string]: any }
					if (!allUpdates)
						return ppio.promRej("InputBox.set#allUpdates", msg.data)
					const prop_value = allUpdates["value"] as string
					if (prop_value !== undefined) {
						let val = prop_value
						if (val !== thisInputBox.value)
							thisInputBox.value = val
					}
					const prop_placeholder = allUpdates["placeholder"] as string
					if (prop_placeholder !== undefined) {
						let val = prop_placeholder
						if (val !== thisInputBox.placeholder)
							thisInputBox.placeholder = val
					}
					const prop_password = allUpdates["password"] as boolean
					if (prop_password !== undefined) {
						let val = prop_password
						if (val !== thisInputBox.password)
							thisInputBox.password = val
					}
					const prop_prompt = allUpdates["prompt"] as string
					if (prop_prompt !== undefined) {
						let val = prop_prompt
						if (val !== thisInputBox.prompt)
							thisInputBox.prompt = val
					}
					const prop_validationMessage = allUpdates["validationMessage"] as string
					if (prop_validationMessage !== undefined) {
						let val = prop_validationMessage
						if (val !== thisInputBox.validationMessage)
							thisInputBox.validationMessage = val
					}
					const prop_title = allUpdates["title"] as string
					if (prop_title !== undefined) {
						let val = prop_title
						if (val !== thisInputBox.title)
							thisInputBox.title = val
					}
					const prop_step = allUpdates["step"] as number
					if (prop_step !== undefined) {
						let val = prop_step
						if (val !== thisInputBox.step)
							thisInputBox.step = val
					}
					const prop_totalSteps = allUpdates["totalSteps"] as number
					if (prop_totalSteps !== undefined) {
						let val = prop_totalSteps
						if (val !== thisInputBox.totalSteps)
							thisInputBox.totalSteps = val
					}
					const prop_enabled = allUpdates["enabled"] as boolean
					if (prop_enabled !== undefined) {
						let val = prop_enabled
						if (val !== thisInputBox.enabled)
							thisInputBox.enabled = val
					}
					const prop_busy = allUpdates["busy"] as boolean
					if (prop_busy !== undefined) {
						let val = prop_busy
						if (val !== thisInputBox.busy)
							thisInputBox.busy = val
					}
					const prop_ignoreFocusOut = allUpdates["ignoreFocusOut"] as boolean
					if (prop_ignoreFocusOut !== undefined) {
						let val = prop_ignoreFocusOut
						if (val !== thisInputBox.ignoreFocusOut)
							thisInputBox.ignoreFocusOut = val
					}
					return Promise.resolve()
				}
				default:
					throw methodname
			}
		case "QuickPick":
			const thisQuickPick = prog.objects[msg.data[""]] as QuickPick
			if (!thisQuickPick)
				throw "Called vscode.QuickPick." + methodname + " for an already disposed-and-forgotten instance"
			switch (methodname) {
				case "onDidChangeValue": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("QuickPick.onDidChangeValue.handler", msg.data)
					const arg_handler = (_0: string): unknown => {
						if (prog && prog.proc)
							return prog.callBack("QuickPick.onDidChangeValue.handler", false, _fnid_handler, _0, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }))
						return undefined
					}
					const ret = thisQuickPick.onDidChangeValue(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "onDidAccept": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("QuickPick.onDidAccept.handler", msg.data)
					const arg_handler = (): unknown => {
						if (prog && prog.proc)
							return prog.callBack("QuickPick.onDidAccept.handler", false, _fnid_handler, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }))
						return undefined
					}
					const ret = thisQuickPick.onDidAccept(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "onDidChangeActive": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("QuickPick.onDidChangeActive.handler", msg.data)
					const arg_handler = (_0: QuickPickItem[]): unknown => {
						if (prog && prog.proc)
							return prog.callBack("QuickPick.onDidChangeActive.handler", false, _fnid_handler, _0, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }))
						return undefined
					}
					const ret = thisQuickPick.onDidChangeActive(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "onDidChangeSelection": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("QuickPick.onDidChangeSelection.handler", msg.data)
					const arg_handler = (_0: QuickPickItem[]): unknown => {
						if (prog && prog.proc)
							return prog.callBack("QuickPick.onDidChangeSelection.handler", false, _fnid_handler, _0, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }))
						return undefined
					}
					const ret = thisQuickPick.onDidChangeSelection(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "show": {
					thisQuickPick.show()
					return Promise.resolve({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut })
				}
				case "hide": {
					thisQuickPick.hide()
					return Promise.resolve({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut })
				}
				case "onDidHide": {
					const _fnid_handler = msg.data['handler'] as string
					if (!(_fnid_handler && _fnid_handler.length))
						return ppio.promRej("QuickPick.onDidHide.handler", msg.data)
					const arg_handler = (): unknown => {
						if (prog && prog.proc)
							return prog.callBack("QuickPick.onDidHide.handler", false, _fnid_handler, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }))
						return undefined
					}
					const ret = thisQuickPick.onDidHide(arg_handler, )
					const retdisp = ret as any as vscode.Disposable
					const retprom = ret as any as Thenable<any>
					return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret))
				}
				case "appzObjPropsGet": {
					return Promise.resolve({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut })
				}
				case "appzObjPropsSet": {
					const allUpdates = msg.data['allUpdates'] as { [_:string]: any }
					if (!allUpdates)
						return ppio.promRej("QuickPick.set#allUpdates", msg.data)
					const prop_value = allUpdates["value"] as string
					if (prop_value !== undefined) {
						let val = prop_value
						if (val !== thisQuickPick.value)
							thisQuickPick.value = val
					}
					const prop_placeholder = allUpdates["placeholder"] as string
					if (prop_placeholder !== undefined) {
						let val = prop_placeholder
						if (val !== thisQuickPick.placeholder)
							thisQuickPick.placeholder = val
					}
					const prop_items = allUpdates["items"] as QuickPickItem[]
					if (prop_items !== undefined) {
						let val = prop_items
						if (val !== thisQuickPick.items)
							thisQuickPick.items = val
					}
					const prop_canSelectMany = allUpdates["canSelectMany"] as boolean
					if (prop_canSelectMany !== undefined) {
						let val = prop_canSelectMany
						if (val !== thisQuickPick.canSelectMany)
							thisQuickPick.canSelectMany = val
					}
					const prop_matchOnDescription = allUpdates["matchOnDescription"] as boolean
					if (prop_matchOnDescription !== undefined) {
						let val = prop_matchOnDescription
						if (val !== thisQuickPick.matchOnDescription)
							thisQuickPick.matchOnDescription = val
					}
					const prop_matchOnDetail = allUpdates["matchOnDetail"] as boolean
					if (prop_matchOnDetail !== undefined) {
						let val = prop_matchOnDetail
						if (val !== thisQuickPick.matchOnDetail)
							thisQuickPick.matchOnDetail = val
					}
					const prop_activeItems = allUpdates["activeItems"] as QuickPickItem[]
					if (prop_activeItems !== undefined) {
						let val = prop_activeItems
						if (val !== thisQuickPick.activeItems)
							thisQuickPick.activeItems = val
					}
					const prop_selectedItems = allUpdates["selectedItems"] as QuickPickItem[]
					if (prop_selectedItems !== undefined) {
						let val = prop_selectedItems
						if (val !== thisQuickPick.selectedItems)
							thisQuickPick.selectedItems = val
					}
					const prop_title = allUpdates["title"] as string
					if (prop_title !== undefined) {
						let val = prop_title
						if (val !== thisQuickPick.title)
							thisQuickPick.title = val
					}
					const prop_step = allUpdates["step"] as number
					if (prop_step !== undefined) {
						let val = prop_step
						if (val !== thisQuickPick.step)
							thisQuickPick.step = val
					}
					const prop_totalSteps = allUpdates["totalSteps"] as number
					if (prop_totalSteps !== undefined) {
						let val = prop_totalSteps
						if (val !== thisQuickPick.totalSteps)
							thisQuickPick.totalSteps = val
					}
					const prop_enabled = allUpdates["enabled"] as boolean
					if (prop_enabled !== undefined) {
						let val = prop_enabled
						if (val !== thisQuickPick.enabled)
							thisQuickPick.enabled = val
					}
					const prop_busy = allUpdates["busy"] as boolean
					if (prop_busy !== undefined) {
						let val = prop_busy
						if (val !== thisQuickPick.busy)
							thisQuickPick.busy = val
					}
					const prop_ignoreFocusOut = allUpdates["ignoreFocusOut"] as boolean
					if (prop_ignoreFocusOut !== undefined) {
						let val = prop_ignoreFocusOut
						if (val !== thisQuickPick.ignoreFocusOut)
							thisQuickPick.ignoreFocusOut = val
					}
					return Promise.resolve()
				}
				default:
					throw methodname
			}
		default:
			throw (apiname)
	}
}

type StatusBarAlignment = vscode.StatusBarAlignment
type MessageOptions = vscode.MessageOptions
interface MessageItem extends vscode.MessageItem {
	my?: { [_: string]: any }
}
interface InputBoxOptions extends vscode.InputBoxOptions {
	validateInput_AppzFuncId: string
}
interface QuickPickOptions extends vscode.QuickPickOptions {
	onDidSelectItem_AppzFuncId: string
}
interface QuickPickItem extends vscode.QuickPickItem {
	my?: { [_: string]: any }
}
type SaveDialogOptions = vscode.SaveDialogOptions
type OpenDialogOptions = vscode.OpenDialogOptions
type WorkspaceFolderPickOptions = vscode.WorkspaceFolderPickOptions
type StatusBarItem = vscode.StatusBarItem
type OutputChannel = vscode.OutputChannel
type DecorationRenderOptions = vscode.DecorationRenderOptions
type TextEditorDecorationType = vscode.TextEditorDecorationType
type InputBox = vscode.InputBox
type QuickPick = vscode.QuickPick<QuickPickItem>
