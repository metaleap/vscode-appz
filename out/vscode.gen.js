"use strict";
// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-vscext.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
Object.defineProperty(exports, "__esModule", { value: true });
const vscode = require("vscode");
const ppio = require("./procspipeio");
const noOp = (_) => { };
function handle(msg, prog, remoteCancellationTokens) {
    const idxdot = msg.qName.lastIndexOf('.');
    const [apiname, methodname] = (idxdot > 0) ? [msg.qName.slice(0, idxdot), msg.qName.slice(idxdot + 1)] : ['', msg.qName];
    switch (apiname) {
        case "window":
            switch (methodname) {
                case "showInformationMessage1": {
                    const arg_message = (msg.data['message']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showInformationMessage(arg_message, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showInformationMessage2": {
                    const arg_message = (msg.data['message']);
                    const arg_options = (msg.data['options']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showInformationMessage(arg_message, arg_options, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showInformationMessage3": {
                    const arg_message = (msg.data['message']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showInformationMessage(arg_message, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showInformationMessage4": {
                    const arg_message = (msg.data['message']);
                    const arg_options = (msg.data['options']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showInformationMessage(arg_message, arg_options, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showWarningMessage1": {
                    const arg_message = (msg.data['message']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showWarningMessage(arg_message, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showWarningMessage2": {
                    const arg_message = (msg.data['message']);
                    const arg_options = (msg.data['options']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showWarningMessage(arg_message, arg_options, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showWarningMessage3": {
                    const arg_message = (msg.data['message']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showWarningMessage(arg_message, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showWarningMessage4": {
                    const arg_message = (msg.data['message']);
                    const arg_options = (msg.data['options']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showWarningMessage(arg_message, arg_options, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showErrorMessage1": {
                    const arg_message = (msg.data['message']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showErrorMessage(arg_message, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showErrorMessage2": {
                    const arg_message = (msg.data['message']);
                    const arg_options = (msg.data['options']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showErrorMessage(arg_message, arg_options, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showErrorMessage3": {
                    const arg_message = (msg.data['message']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showErrorMessage(arg_message, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showErrorMessage4": {
                    const arg_message = (msg.data['message']);
                    const arg_options = (msg.data['options']);
                    const arg_items = (msg.data['items'] || []);
                    const ret = vscode.window.showErrorMessage(arg_message, arg_options, ...arg_items);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showInputBox": {
                    const arg_options = (msg.data['options']);
                    if (arg_options && arg_options.validateInput_AppzFuncId && arg_options.validateInput_AppzFuncId.length)
                        arg_options.validateInput = (a0) => prog.callBack("window.showInputBox", true, arg_options.validateInput_AppzFuncId, a0);
                    let ctid = msg.data['token'], arg_token = prog.cancellerToken(ctid);
                    if (!arg_token)
                        arg_token = prog.cancellers[''].token;
                    else
                        remoteCancellationTokens.push(ctid);
                    const ret = vscode.window.showInputBox(arg_options, arg_token);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showQuickPick1": {
                    const arg_items = (msg.data['items']);
                    const arg_options = (msg.data['options']);
                    if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
                        arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick1", true, arg_options.onDidSelectItem_AppzFuncId, a0);
                    let ctid = msg.data['token'], arg_token = prog.cancellerToken(ctid);
                    if (!arg_token)
                        arg_token = prog.cancellers[''].token;
                    else
                        remoteCancellationTokens.push(ctid);
                    const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showQuickPick2": {
                    const arg_items = (msg.data['items']);
                    const arg_options = (msg.data['options']);
                    if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
                        arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick2", true, arg_options.onDidSelectItem_AppzFuncId, a0);
                    let ctid = msg.data['token'], arg_token = prog.cancellerToken(ctid);
                    if (!arg_token)
                        arg_token = prog.cancellers[''].token;
                    else
                        remoteCancellationTokens.push(ctid);
                    const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showQuickPick3": {
                    const arg_items = (msg.data['items']);
                    const arg_options = (msg.data['options']);
                    if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
                        arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick3", true, arg_options.onDidSelectItem_AppzFuncId, a0);
                    let ctid = msg.data['token'], arg_token = prog.cancellerToken(ctid);
                    if (!arg_token)
                        arg_token = prog.cancellers[''].token;
                    else
                        remoteCancellationTokens.push(ctid);
                    const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showQuickPick4": {
                    const arg_items = (msg.data['items']);
                    const arg_options = (msg.data['options']);
                    if (arg_options && arg_options.onDidSelectItem_AppzFuncId && arg_options.onDidSelectItem_AppzFuncId.length)
                        arg_options.onDidSelectItem = (a0) => prog.callBack("window.showQuickPick4", true, arg_options.onDidSelectItem_AppzFuncId, a0);
                    let ctid = msg.data['token'], arg_token = prog.cancellerToken(ctid);
                    if (!arg_token)
                        arg_token = prog.cancellers[''].token;
                    else
                        remoteCancellationTokens.push(ctid);
                    const ret = vscode.window.showQuickPick(arg_items, arg_options, arg_token);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "setStatusBarMessage1": {
                    const arg_text = (msg.data['text']);
                    const arg_hideAfterTimeout = (msg.data['hideAfterTimeout']);
                    const ret = vscode.window.setStatusBarMessage(arg_text, arg_hideAfterTimeout);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "setStatusBarMessage2": {
                    const arg_text = (msg.data['text']);
                    const ret = vscode.window.setStatusBarMessage(arg_text);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showSaveDialog": {
                    const arg_options = (msg.data['options']);
                    const ret = vscode.window.showSaveDialog(arg_options);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showOpenDialog": {
                    const arg_options = (msg.data['options']);
                    const ret = vscode.window.showOpenDialog(arg_options);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "showWorkspaceFolderPick": {
                    const arg_options = (msg.data['options']);
                    const ret = vscode.window.showWorkspaceFolderPick(arg_options);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "state": {
                    return Promise.resolve(vscode.window.state);
                }
                case "onDidChangeWindowState": {
                    const _fnid_listener = msg.data['listener'];
                    return (!(_fnid_listener && _fnid_listener.length))
                        ? ppio.promRej("window.onDidChangeWindowState.listener", msg.data)
                        : vscode.window.onDidChangeWindowState((a0) => {
                            if (prog && prog.proc)
                                prog.callBack("window.onDidChangeWindowState", false, _fnid_listener, a0).then(noOp, noOp);
                        });
                }
                case "createStatusBarItem": {
                    const arg_alignment = (msg.data['alignment']);
                    const arg_priority = (msg.data['priority']);
                    const ret = vscode.window.createStatusBarItem(arg_alignment, arg_priority);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "createOutputChannel": {
                    const arg_name = (msg.data['name']);
                    const ret = vscode.window.createOutputChannel(arg_name);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "createTextEditorDecorationType": {
                    const arg_options = (msg.data['options']);
                    const ret = vscode.window.createTextEditorDecorationType(arg_options);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "createInputBox": {
                    const ret = vscode.window.createInputBox();
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "createQuickPick": {
                    const ret = vscode.window.createQuickPick();
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                default:
                    throw (methodname);
            }
        case "env":
            switch (methodname) {
                case "openExternal": {
                    const arg_target = ppio.tryUnmarshalUri(msg.data['target']);
                    if (!arg_target)
                        return ppio.promRej("env.openExternal", msg.data['target']);
                    const ret = vscode.env.openExternal(arg_target);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "appName": {
                    return Promise.resolve(vscode.env.appName);
                }
                case "appRoot": {
                    return Promise.resolve(vscode.env.appRoot);
                }
                case "language": {
                    return Promise.resolve(vscode.env.language);
                }
                case "machineId": {
                    return Promise.resolve(vscode.env.machineId);
                }
                case "remoteName": {
                    return Promise.resolve(vscode.env.remoteName);
                }
                case "sessionId": {
                    return Promise.resolve(vscode.env.sessionId);
                }
                case "shell": {
                    return Promise.resolve(vscode.env.shell);
                }
                case "uriScheme": {
                    return Promise.resolve(vscode.env.uriScheme);
                }
                case "AllProperties": {
                    return Promise.resolve({
                        appName: vscode.env.appName,
                        appRoot: vscode.env.appRoot,
                        language: vscode.env.language,
                        machineId: vscode.env.machineId,
                        remoteName: vscode.env.remoteName,
                        sessionId: vscode.env.sessionId,
                        shell: vscode.env.shell,
                        uriScheme: vscode.env.uriScheme,
                    });
                }
                default:
                    throw (methodname);
            }
        case "clipboard":
            switch (methodname) {
                case "readText": {
                    const ret = vscode.env.clipboard.readText();
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "writeText": {
                    const arg_value = (msg.data['value']);
                    const ret = vscode.env.clipboard.writeText(arg_value);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                default:
                    throw (methodname);
            }
        case "workspace":
            switch (methodname) {
                case "name": {
                    return Promise.resolve(vscode.workspace.name);
                }
                case "workspaceFile": {
                    return Promise.resolve(vscode.workspace.workspaceFile);
                }
                case "saveAll": {
                    const arg_includeUntitled = (msg.data['includeUntitled']);
                    const ret = vscode.workspace.saveAll(arg_includeUntitled);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "onDidChangeWorkspaceFolders": {
                    const _fnid_listener = msg.data['listener'];
                    return (!(_fnid_listener && _fnid_listener.length))
                        ? ppio.promRej("workspace.onDidChangeWorkspaceFolders.listener", msg.data)
                        : vscode.workspace.onDidChangeWorkspaceFolders((a0) => {
                            if (prog && prog.proc)
                                prog.callBack("workspace.onDidChangeWorkspaceFolders", false, _fnid_listener, a0).then(noOp, noOp);
                        });
                }
                case "getWorkspaceFolder": {
                    const arg_uri = ppio.tryUnmarshalUri(msg.data['uri']);
                    if (!arg_uri)
                        return ppio.promRej("workspace.getWorkspaceFolder", msg.data['uri']);
                    const ret = vscode.workspace.getWorkspaceFolder(arg_uri);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "workspaceFolders": {
                    return Promise.resolve(vscode.workspace.workspaceFolders);
                }
                case "findFiles": {
                    const arg_include = (msg.data['include']);
                    const arg_exclude = (msg.data['exclude']);
                    const arg_maxResults = (msg.data['maxResults']);
                    let ctid = msg.data['token'], arg_token = prog.cancellerToken(ctid);
                    if (!arg_token)
                        arg_token = prog.cancellers[''].token;
                    else
                        remoteCancellationTokens.push(ctid);
                    const ret = vscode.workspace.findFiles(arg_include, arg_exclude, arg_maxResults, arg_token);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "asRelativePath": {
                    const arg_pathOrUri = (msg.data['pathOrUri']);
                    const arg_includeWorkspaceFolder = (msg.data['includeWorkspaceFolder']);
                    const ret = vscode.workspace.asRelativePath(arg_pathOrUri, arg_includeWorkspaceFolder);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "AllProperties": {
                    return Promise.resolve({
                        name: vscode.workspace.name,
                        workspaceFile: vscode.workspace.workspaceFile,
                        workspaceFolders: vscode.workspace.workspaceFolders,
                    });
                }
                default:
                    throw (methodname);
            }
        case "languages":
            switch (methodname) {
                case "getLanguages": {
                    const ret = vscode.languages.getLanguages();
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "onDidChangeDiagnostics": {
                    const _fnid_listener = msg.data['listener'];
                    return (!(_fnid_listener && _fnid_listener.length))
                        ? ppio.promRej("languages.onDidChangeDiagnostics.listener", msg.data)
                        : vscode.languages.onDidChangeDiagnostics((a0) => {
                            if (prog && prog.proc)
                                prog.callBack("languages.onDidChangeDiagnostics", false, _fnid_listener, a0).then(noOp, noOp);
                        });
                }
                default:
                    throw (methodname);
            }
        case "extensions":
            switch (methodname) {
                case "onDidChange": {
                    const _fnid_listener = msg.data['listener'];
                    return (!(_fnid_listener && _fnid_listener.length))
                        ? ppio.promRej("extensions.onDidChange.listener", msg.data)
                        : vscode.extensions.onDidChange(() => {
                            if (prog && prog.proc)
                                prog.callBack("extensions.onDidChange", false, _fnid_listener).then(noOp, noOp);
                        });
                }
                default:
                    throw (methodname);
            }
        case "commands":
            switch (methodname) {
                case "registerCommand": {
                    const arg_command = (msg.data['command']);
                    const callbackFnId = msg.data['callback'];
                    if (!(callbackFnId && callbackFnId.length))
                        return ppio.promRej("commands.registerCommand", msg.data);
                    const arg_callback = (..._0) => {
                        if (prog && prog.proc)
                            return prog.callBack("commands.registerCommand", true, callbackFnId, _0);
                        return undefined;
                    };
                    const ret = vscode.commands.registerCommand(arg_command, arg_callback);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "executeCommand": {
                    const arg_command = (msg.data['command']);
                    const arg_rest = (msg.data['rest'] || []);
                    const ret = vscode.commands.executeCommand(arg_command, ...arg_rest);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "getCommands": {
                    const arg_filterInternal = (msg.data['filterInternal']);
                    const ret = vscode.commands.getCommands(arg_filterInternal);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                default:
                    throw (methodname);
            }
        case "StatusBarItem":
            const thisStatusBarItem = prog.objects[msg.data[""]];
            if (!thisStatusBarItem)
                throw "Called vscode.StatusBarItem." + methodname + " for an already disposed-and-forgotten instance";
            switch (methodname) {
                case "show": {
                    const ret = thisStatusBarItem.show();
                    return Promise.resolve([ret, { alignment: thisStatusBarItem.alignment, priority: thisStatusBarItem.priority, text: thisStatusBarItem.text, tooltip: thisStatusBarItem.tooltip, color: (thisStatusBarItem.color && (thisStatusBarItem.color["id"])) ? (thisStatusBarItem.color["id"]) : thisStatusBarItem.color, command: thisStatusBarItem.command }]);
                }
                case "hide": {
                    const ret = thisStatusBarItem.hide();
                    return Promise.resolve([ret, { alignment: thisStatusBarItem.alignment, priority: thisStatusBarItem.priority, text: thisStatusBarItem.text, tooltip: thisStatusBarItem.tooltip, color: (thisStatusBarItem.color && (thisStatusBarItem.color["id"])) ? (thisStatusBarItem.color["id"]) : thisStatusBarItem.color, command: thisStatusBarItem.command }]);
                }
                case "__appzObjBagPullFromPeer__": {
                    return Promise.resolve({ alignment: thisStatusBarItem.alignment, priority: thisStatusBarItem.priority, text: thisStatusBarItem.text, tooltip: thisStatusBarItem.tooltip, color: (thisStatusBarItem.color && (thisStatusBarItem.color["id"])) ? (thisStatusBarItem.color["id"]) : thisStatusBarItem.color, command: thisStatusBarItem.command });
                }
                case "__appzObjBagPushToPeer__": {
                    const upd = msg.data["allUpdates"];
                    if (!upd)
                        return ppio.promRej("StatusBarItem.set#allUpdates", msg.data);
                    const prop_text = upd["text"];
                    if (prop_text !== undefined) {
                        let val = prop_text;
                        if (val !== thisStatusBarItem.text)
                            thisStatusBarItem.text = val;
                    }
                    const prop_tooltip = upd["tooltip"];
                    if (prop_tooltip !== undefined) {
                        let val = prop_tooltip;
                        if (val !== thisStatusBarItem.tooltip)
                            thisStatusBarItem.tooltip = val;
                    }
                    const prop_color = upd["color"];
                    if (prop_color !== undefined) {
                        let val = (!((typeof prop_color === "string") && prop_color && prop_color.length)) ? undefined : prop_color.startsWith("#") ? prop_color : new vscode.ThemeColor(prop_color);
                        if (val !== thisStatusBarItem.color)
                            thisStatusBarItem.color = val;
                    }
                    const prop_command = upd["command"];
                    if (prop_command !== undefined) {
                        let val = prop_command;
                        if (val !== thisStatusBarItem.command)
                            thisStatusBarItem.command = val;
                    }
                    return Promise.resolve({ alignment: thisStatusBarItem.alignment, priority: thisStatusBarItem.priority, text: thisStatusBarItem.text, tooltip: thisStatusBarItem.tooltip, color: (thisStatusBarItem.color && (thisStatusBarItem.color["id"])) ? (thisStatusBarItem.color["id"]) : thisStatusBarItem.color, command: thisStatusBarItem.command });
                }
                default:
                    throw methodname;
            }
        case "OutputChannel":
            const thisOutputChannel = prog.objects[msg.data[""]];
            if (!thisOutputChannel)
                throw "Called vscode.OutputChannel." + methodname + " for an already disposed-and-forgotten instance";
            switch (methodname) {
                case "append": {
                    const arg_value = (msg.data['value']);
                    const ret = thisOutputChannel.append(arg_value);
                    return Promise.resolve([ret, { name: thisOutputChannel.name }]);
                }
                case "appendLine": {
                    const arg_value = (msg.data['value']);
                    const ret = thisOutputChannel.appendLine(arg_value);
                    return Promise.resolve([ret, { name: thisOutputChannel.name }]);
                }
                case "clear": {
                    const ret = thisOutputChannel.clear();
                    return Promise.resolve([ret, { name: thisOutputChannel.name }]);
                }
                case "show": {
                    const arg_preserveFocus = (msg.data['preserveFocus']);
                    const ret = thisOutputChannel.show(arg_preserveFocus);
                    return Promise.resolve([ret, { name: thisOutputChannel.name }]);
                }
                case "hide": {
                    const ret = thisOutputChannel.hide();
                    return Promise.resolve([ret, { name: thisOutputChannel.name }]);
                }
                case "__appzObjBagPullFromPeer__": {
                    return Promise.resolve({ name: thisOutputChannel.name });
                }
                default:
                    throw methodname;
            }
        case "TextEditorDecorationType":
            const thisTextEditorDecorationType = prog.objects[msg.data[""]];
            if (!thisTextEditorDecorationType)
                throw "Called vscode.TextEditorDecorationType." + methodname + " for an already disposed-and-forgotten instance";
            switch (methodname) {
                case "__appzObjBagPullFromPeer__": {
                    return Promise.resolve({ key: thisTextEditorDecorationType.key });
                }
                default:
                    throw methodname;
            }
        case "InputBox":
            const thisInputBox = prog.objects[msg.data[""]];
            if (!thisInputBox)
                throw "Called vscode.InputBox." + methodname + " for an already disposed-and-forgotten instance";
            switch (methodname) {
                case "onDidChangeValue": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("InputBox.onDidChangeValue.handler", msg.data);
                    const arg_handler = (_0) => {
                        if (prog && prog.proc)
                            return prog.callBack("InputBox.onDidChangeValue.handler", false, handlerFnId, _0, ({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisInputBox.onDidChangeValue(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "onDidAccept": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("InputBox.onDidAccept.handler", msg.data);
                    const arg_handler = () => {
                        if (prog && prog.proc)
                            return prog.callBack("InputBox.onDidAccept.handler", false, handlerFnId, ({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisInputBox.onDidAccept(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "show": {
                    const ret = thisInputBox.show();
                    return Promise.resolve([ret, { value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }]);
                }
                case "hide": {
                    const ret = thisInputBox.hide();
                    return Promise.resolve([ret, { value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }]);
                }
                case "onDidHide": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("InputBox.onDidHide.handler", msg.data);
                    const arg_handler = () => {
                        if (prog && prog.proc)
                            return prog.callBack("InputBox.onDidHide.handler", false, handlerFnId, ({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisInputBox.onDidHide(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "__appzObjBagPullFromPeer__": {
                    return Promise.resolve({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut });
                }
                case "__appzObjBagPushToPeer__": {
                    const upd = msg.data["allUpdates"];
                    if (!upd)
                        return ppio.promRej("InputBox.set#allUpdates", msg.data);
                    const prop_value = upd["value"];
                    if (prop_value !== undefined) {
                        let val = prop_value;
                        if (val !== thisInputBox.value)
                            thisInputBox.value = val;
                    }
                    const prop_placeholder = upd["placeholder"];
                    if (prop_placeholder !== undefined) {
                        let val = prop_placeholder;
                        if (val !== thisInputBox.placeholder)
                            thisInputBox.placeholder = val;
                    }
                    const prop_password = upd["password"];
                    if (prop_password !== undefined) {
                        let val = prop_password;
                        if (val !== thisInputBox.password)
                            thisInputBox.password = val;
                    }
                    const prop_prompt = upd["prompt"];
                    if (prop_prompt !== undefined) {
                        let val = prop_prompt;
                        if (val !== thisInputBox.prompt)
                            thisInputBox.prompt = val;
                    }
                    const prop_validationMessage = upd["validationMessage"];
                    if (prop_validationMessage !== undefined) {
                        let val = prop_validationMessage;
                        if (val !== thisInputBox.validationMessage)
                            thisInputBox.validationMessage = val;
                    }
                    const prop_title = upd["title"];
                    if (prop_title !== undefined) {
                        let val = prop_title;
                        if (val !== thisInputBox.title)
                            thisInputBox.title = val;
                    }
                    const prop_step = upd["step"];
                    if (prop_step !== undefined) {
                        let val = prop_step;
                        if (val !== thisInputBox.step)
                            thisInputBox.step = val;
                    }
                    const prop_totalSteps = upd["totalSteps"];
                    if (prop_totalSteps !== undefined) {
                        let val = prop_totalSteps;
                        if (val !== thisInputBox.totalSteps)
                            thisInputBox.totalSteps = val;
                    }
                    const prop_enabled = upd["enabled"];
                    if (prop_enabled !== undefined) {
                        let val = prop_enabled;
                        if (val !== thisInputBox.enabled)
                            thisInputBox.enabled = val;
                    }
                    const prop_busy = upd["busy"];
                    if (prop_busy !== undefined) {
                        let val = prop_busy;
                        if (val !== thisInputBox.busy)
                            thisInputBox.busy = val;
                    }
                    const prop_ignoreFocusOut = upd["ignoreFocusOut"];
                    if (prop_ignoreFocusOut !== undefined) {
                        let val = prop_ignoreFocusOut;
                        if (val !== thisInputBox.ignoreFocusOut)
                            thisInputBox.ignoreFocusOut = val;
                    }
                    return Promise.resolve({ value: thisInputBox.value, placeholder: thisInputBox.placeholder, password: thisInputBox.password, prompt: thisInputBox.prompt, validationMessage: thisInputBox.validationMessage, title: thisInputBox.title, step: thisInputBox.step, totalSteps: thisInputBox.totalSteps, enabled: thisInputBox.enabled, busy: thisInputBox.busy, ignoreFocusOut: thisInputBox.ignoreFocusOut });
                }
                default:
                    throw methodname;
            }
        case "QuickPick":
            const thisQuickPick = prog.objects[msg.data[""]];
            if (!thisQuickPick)
                throw "Called vscode.QuickPick." + methodname + " for an already disposed-and-forgotten instance";
            switch (methodname) {
                case "onDidChangeValue": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("QuickPick.onDidChangeValue.handler", msg.data);
                    const arg_handler = (_0) => {
                        if (prog && prog.proc)
                            return prog.callBack("QuickPick.onDidChangeValue.handler", false, handlerFnId, _0, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisQuickPick.onDidChangeValue(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "onDidAccept": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("QuickPick.onDidAccept.handler", msg.data);
                    const arg_handler = () => {
                        if (prog && prog.proc)
                            return prog.callBack("QuickPick.onDidAccept.handler", false, handlerFnId, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisQuickPick.onDidAccept(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "onDidChangeActive": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("QuickPick.onDidChangeActive.handler", msg.data);
                    const arg_handler = (_0) => {
                        if (prog && prog.proc)
                            return prog.callBack("QuickPick.onDidChangeActive.handler", false, handlerFnId, _0, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisQuickPick.onDidChangeActive(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "onDidChangeSelection": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("QuickPick.onDidChangeSelection.handler", msg.data);
                    const arg_handler = (_0) => {
                        if (prog && prog.proc)
                            return prog.callBack("QuickPick.onDidChangeSelection.handler", false, handlerFnId, _0, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisQuickPick.onDidChangeSelection(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "show": {
                    const ret = thisQuickPick.show();
                    return Promise.resolve([ret, { value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }]);
                }
                case "hide": {
                    const ret = thisQuickPick.hide();
                    return Promise.resolve([ret, { value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }]);
                }
                case "onDidHide": {
                    const handlerFnId = msg.data['handler'];
                    if (!(handlerFnId && handlerFnId.length))
                        return ppio.promRej("QuickPick.onDidHide.handler", msg.data);
                    const arg_handler = () => {
                        if (prog && prog.proc)
                            return prog.callBack("QuickPick.onDidHide.handler", false, handlerFnId, ({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut }));
                        return undefined;
                    };
                    const ret = thisQuickPick.onDidHide(arg_handler);
                    const retdisp = ret;
                    const retprom = ret;
                    return (retprom && retprom.then) ? retprom : ((retdisp && retdisp.dispose) ? retdisp : Promise.resolve(ret));
                }
                case "__appzObjBagPullFromPeer__": {
                    return Promise.resolve({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut });
                }
                case "__appzObjBagPushToPeer__": {
                    const upd = msg.data["allUpdates"];
                    if (!upd)
                        return ppio.promRej("QuickPick.set#allUpdates", msg.data);
                    const prop_value = upd["value"];
                    if (prop_value !== undefined) {
                        let val = prop_value;
                        if (val !== thisQuickPick.value)
                            thisQuickPick.value = val;
                    }
                    const prop_placeholder = upd["placeholder"];
                    if (prop_placeholder !== undefined) {
                        let val = prop_placeholder;
                        if (val !== thisQuickPick.placeholder)
                            thisQuickPick.placeholder = val;
                    }
                    const prop_items = upd["items"];
                    if (prop_items !== undefined) {
                        let val = prop_items;
                        if (val !== thisQuickPick.items)
                            thisQuickPick.items = val;
                    }
                    const prop_canSelectMany = upd["canSelectMany"];
                    if (prop_canSelectMany !== undefined) {
                        let val = prop_canSelectMany;
                        if (val !== thisQuickPick.canSelectMany)
                            thisQuickPick.canSelectMany = val;
                    }
                    const prop_matchOnDescription = upd["matchOnDescription"];
                    if (prop_matchOnDescription !== undefined) {
                        let val = prop_matchOnDescription;
                        if (val !== thisQuickPick.matchOnDescription)
                            thisQuickPick.matchOnDescription = val;
                    }
                    const prop_matchOnDetail = upd["matchOnDetail"];
                    if (prop_matchOnDetail !== undefined) {
                        let val = prop_matchOnDetail;
                        if (val !== thisQuickPick.matchOnDetail)
                            thisQuickPick.matchOnDetail = val;
                    }
                    const prop_activeItems = upd["activeItems"];
                    if (prop_activeItems !== undefined) {
                        let val = prop_activeItems;
                        if (val !== thisQuickPick.activeItems)
                            thisQuickPick.activeItems = val;
                    }
                    const prop_selectedItems = upd["selectedItems"];
                    if (prop_selectedItems !== undefined) {
                        let val = prop_selectedItems;
                        if (val !== thisQuickPick.selectedItems)
                            thisQuickPick.selectedItems = val;
                    }
                    const prop_title = upd["title"];
                    if (prop_title !== undefined) {
                        let val = prop_title;
                        if (val !== thisQuickPick.title)
                            thisQuickPick.title = val;
                    }
                    const prop_step = upd["step"];
                    if (prop_step !== undefined) {
                        let val = prop_step;
                        if (val !== thisQuickPick.step)
                            thisQuickPick.step = val;
                    }
                    const prop_totalSteps = upd["totalSteps"];
                    if (prop_totalSteps !== undefined) {
                        let val = prop_totalSteps;
                        if (val !== thisQuickPick.totalSteps)
                            thisQuickPick.totalSteps = val;
                    }
                    const prop_enabled = upd["enabled"];
                    if (prop_enabled !== undefined) {
                        let val = prop_enabled;
                        if (val !== thisQuickPick.enabled)
                            thisQuickPick.enabled = val;
                    }
                    const prop_busy = upd["busy"];
                    if (prop_busy !== undefined) {
                        let val = prop_busy;
                        if (val !== thisQuickPick.busy)
                            thisQuickPick.busy = val;
                    }
                    const prop_ignoreFocusOut = upd["ignoreFocusOut"];
                    if (prop_ignoreFocusOut !== undefined) {
                        let val = prop_ignoreFocusOut;
                        if (val !== thisQuickPick.ignoreFocusOut)
                            thisQuickPick.ignoreFocusOut = val;
                    }
                    return Promise.resolve({ value: thisQuickPick.value, placeholder: thisQuickPick.placeholder, items: thisQuickPick.items, canSelectMany: thisQuickPick.canSelectMany, matchOnDescription: thisQuickPick.matchOnDescription, matchOnDetail: thisQuickPick.matchOnDetail, activeItems: thisQuickPick.activeItems, selectedItems: thisQuickPick.selectedItems, title: thisQuickPick.title, step: thisQuickPick.step, totalSteps: thisQuickPick.totalSteps, enabled: thisQuickPick.enabled, busy: thisQuickPick.busy, ignoreFocusOut: thisQuickPick.ignoreFocusOut });
                }
                default:
                    throw methodname;
            }
        default:
            throw (apiname);
    }
}
exports.handle = handle;
