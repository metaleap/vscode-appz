package main
// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-golang.ts via github.com/metaleap/vscode-appz/src/gen/main.ts

import (
	. "github.com/metaleap/vscode-appz/libs/go"
)

func demo_promptToExit() {
	vsc.Window().ShowWarningMessage1(strFmt("Are you sure you want `{0}` to exit?", appName), []string{"Sure I'm sure"})(func(btn *string) {
		if (nil != btn) {
			vsc.Window().ShowInformationMessage1("So fish and long for all the thanks!", nil)
			quit(nil)
		} else {
			vsc.Window().ShowInformationMessage1("So I'm not a goner yet. I'll stick around then.", nil)
		}
	})
}

func demo_Commands_GetCommands_and_ExecuteCommand() {
	vsc.Commands().GetCommands(false)(func(items []string) {
		var opts QuickPickOptions
		opts.IgnoreFocusOut = true
		opts.PlaceHolder = strFmt("Retrieved {0} command ID(s), pick one to execute or escape now:", len(items))
		vsc.Window().ShowQuickPick2(items, &opts, nil)(func(item *string) {
			if (nil == item) {
				vsc.Window().ShowWarningMessage1("Command selection cancelled, spooked?", nil)
			} else {
				var opts2 *InputBoxOptions
				opts2 = new(InputBoxOptions)
				opts2.IgnoreFocusOut = true
				opts2.PlaceHolder = strFmt("Any param for `{0}` command? Else leave blank.", *item)
				vsc.Window().ShowInputBox(opts2, nil)(func(cmdarg *string) {
					if (nil == cmdarg) {
						vsc.Window().ShowWarningMessage1("Cancelled text input, out of ideas?", nil)
					} else {
						var cmdargs []any
						if "" != (*cmdarg) {
							cmdargs = make([]any, 1)
							cmdargs[0] = *cmdarg
						}
						vsc.Commands().ExecuteCommand(*item, cmdargs)(func(ret any) {
							vsc.Window().ShowInformationMessage1(strFmt("Command result was: `{0}`, kudos!", ret), nil)
						})
					}
				})
			}
		})
	})
}

func demo_Commands_RegisterCommand() {
	var opts *InputBoxOptions
	opts = new(InputBoxOptions)
	opts.IgnoreFocusOut = true
	opts.Value = "foo.bar.baz"
	opts.Prompt = "Enter your command name. The command will accept a single text input and return a result built from it."
	vsc.Window().ShowInputBox(opts, nil)(func(cmdname *string) {
		if (nil == cmdname) {
			vsc.Window().ShowWarningMessage1("Cancelled text input, out of ideas?", nil)
		} else {
			vsc.Commands().RegisterCommand(*cmdname, func(cmdargs []any) any {
				vsc.Window().SetStatusBarMessage1(strFmt("Command `{0}` invoked with: `{1}`", *cmdname, cmdargs[0]), 4242)
				return strFmt("Input to command `{0}` was: `{1}`", *cmdname, cmdargs[0])
			})(func(useToUnregister *Disposable) {
				var opts2 *InputBoxOptions
				opts2 = new(InputBoxOptions)
				opts2.IgnoreFocusOut = true
				opts2.Prompt = strFmt("Command `{0}` registered, try it now?", *cmdname)
				opts2.Value = strFmt("Enter input to command `{0}` here", *cmdname)
				vsc.Window().ShowInputBox(opts2, nil)(func(cmdarg *string) {
					if (nil == cmdarg) {
						vsc.Window().ShowWarningMessage1("Cancelled text input, out of ideas?", nil)
					} else {
						var cmdargs2 []any
						cmdargs2 = make([]any, 1)
						cmdargs2[0] = *cmdarg
						vsc.Commands().ExecuteCommand(*cmdname, cmdargs2)(func(ret any) {
							vsc.Window().ShowInformationMessage1(strFmt("Command result: `{0}`, mad props!", ret), nil)
						})
					}
				})
			})
		}
	})
}

func demo_Languages_GetLanguages() {
	vsc.Languages().GetLanguages()(func(items []string) {
		var opts QuickPickOptions
		opts.IgnoreFocusOut = true
		opts.PlaceHolder = strFmt("Retrieved {0} language ID(s)", len(items))
		vsc.Window().ShowQuickPick2(items, &opts, nil)(nil)
	})
}

func demo_Env_Properties() {
	vsc.Env().Properties()(func(props EnvProperties) {
		var items []string
		items = make([]string, 8)
		{
			items[0] = strFmt("AppName\t\t\t{0}", props.AppName)
			items[1] = strFmt("AppRoot\t\t\t{0}", props.AppRoot)
			items[2] = strFmt("Language\t\t{0}", props.Language)
			items[3] = strFmt("MachineId\t\t{0}", props.MachineId)
			items[4] = strFmt("RemoteName\t\t{0}", props.RemoteName)
			items[5] = strFmt("SessionId\t\t{0}", props.SessionId)
			items[6] = strFmt("Shell\t\t\t{0}", props.Shell)
			items[7] = strFmt("UriScheme\t\t{0}", props.UriScheme)
			var opts QuickPickOptions
			opts.IgnoreFocusOut = true
			opts.PlaceHolder = strFmt("Env has {0} properties:", len(items))
			vsc.Window().ShowQuickPick2(items, &opts, nil)(nil)
		}
	})
}

func demo_Workspace_Properties() {
	vsc.Workspace().Properties()(func(props WorkspaceProperties) {
		var items []string
		items = make([]string, 3)
		{
			items[0] = strFmt("Name\t\t\t{0}", props.Name)
			items[1] = strFmt("WorkspaceFile\t\t{0}", props.WorkspaceFile)
			items[2] = strFmt("WorkspaceFolders\t{0}", props.WorkspaceFolders)
			var opts QuickPickOptions
			opts.IgnoreFocusOut = true
			opts.PlaceHolder = strFmt("Workspace has {0} properties:", len(items))
			vsc.Window().ShowQuickPick2(items, &opts, nil)(nil)
		}
	})
}

func demo_Window_ShowOpenDialog() {
	var opts OpenDialogOptions
	opts.OpenLabel = "Note: won't actually read from specified file path(s)"
	opts.Filters = make(map[string][]string, 2)
	opts.Filters["All"] = []string{"*"}
	opts.Filters["Dummy Filter"] = []string{"dummy", "demo"}
	{
		opts.CanSelectFiles = true
		opts.CanSelectFolders = false
		opts.CanSelectMany = true
	}
	vsc.Window().ShowOpenDialog(opts)(func(filepaths []string) {
		if (nil == filepaths) {
			vsc.Window().ShowWarningMessage1("Cancelled File-Open dialog, chicken?", nil)
		} else {
			vsc.Window().ShowInformationMessage1(strFmt("Selected {0} file path(s), excellent!", len(filepaths)), nil)
		}
	})
}

func demo_Window_ShowSaveDialog() {
	var opts SaveDialogOptions
	opts.SaveLabel = "Note: won't actually write to specified file path"
	opts.Filters = make(map[string][]string, 2)
	opts.Filters["All"] = []string{"*"}
	opts.Filters["Dummy Filter"] = []string{"dummy", "demo"}
	vsc.Window().ShowSaveDialog(opts)(func(filepath *string) {
		if (nil == filepath) {
			vsc.Window().ShowWarningMessage1("Cancelled File-Save dialog, chicken?", nil)
		} else {
			vsc.Window().ShowInformationMessage1(strFmt("Selected file path `{0}`, excellent!", *filepath), nil)
		}
	})
}

func demo_Window_ShowWorkspaceFolderPick() {
	var opts *WorkspaceFolderPickOptions
	opts = new(WorkspaceFolderPickOptions)
	opts.IgnoreFocusOut = true
	opts.PlaceHolder = "Reminder, all local-FS-related 'URIs' sent on the VS Code side turn into standard (non-URI) file-path strings received by the prog side."
	vsc.Window().ShowWorkspaceFolderPick(opts)(func(pickedfolder *WorkspaceFolder) {
		if (nil == pickedfolder) {
			vsc.Window().ShowWarningMessage1("Cancelled pick input, changed your mind?", nil)
		} else {
			vsc.Window().ShowInformationMessage1(strFmt("Selected `{0}` located at `{1}`, respect!", pickedfolder.Name, pickedfolder.Uri), nil)
		}
	})
}

func demo_Env_OpenExternal() {
	var opts *InputBoxOptions
	opts = new(InputBoxOptions)
	opts.IgnoreFocusOut = true
	opts.Value = "http://github.com/metaleap/vscode-appz"
	opts.Prompt = "Enter any URI (of http: or mailto: or any other protocol scheme) to open in the applicable external app registered with your OS to handle that protocol."
	vsc.Window().ShowInputBox(opts, nil)(func(uri *string) {
		if (nil == uri) {
			vsc.Window().ShowWarningMessage1("Cancelled text input, out of ideas?", nil)
		} else {
			vsc.Env().OpenExternal(*uri)(func(ok bool) {
				var did string
				did = "Did"
				if !ok {
					did = did  +  " not"
				}
				vsc.Window().ShowInformationMessage1(strFmt("{0} succeed in opening `{1}`, chapeau!", did, *uri), nil)
			})
		}
	})
}

func demo_Window_ShowQuickPick() {
	var items []QuickPickItem
	items = make([]QuickPickItem, 4)
	items[0].Label = "One"
	items[0].Description = "The first"
	items[0].Detail = "Das erste"
	items[1].Label = "Two"
	items[1].Description = "The second"
	items[1].Detail = "Das zweite"
	items[2].Label = "Three"
	items[2].Description = "The third"
	items[2].Detail = "Das dritte"
	items[3].Label = "Four"
	items[3].Description = "The fourth"
	items[3].Detail = "Das vierte"
	var opts QuickPickOptions
	opts.IgnoreFocusOut = true
	opts.MatchOnDescription = true
	opts.MatchOnDetail = true
	opts.PlaceHolder = "You have 42 seconds before auto-cancellation!"
	opts.OnDidSelectItem = func(item QuickPickItem) any {
		vsc.Window().SetStatusBarMessage1(strFmt("Just selected: {0}", item.Label), 4242)
		return nil
	}
	vsc.Window().ShowQuickPick3(items, opts, cancelIn(42))(func(pickeditems []QuickPickItem) {
		if (nil == pickeditems) {
			vsc.Window().ShowWarningMessage1("Cancelled pick input, not one to tick the boxes?", nil)
		} else {
			vsc.Window().ShowInformationMessage1(strFmt("You picked {0} item(s), good stuff!", len(pickeditems)), nil)
		}
	})
}

func subscribeToMiscEvents() {
	vsc.Extensions().OnDidChange(func() {
		vsc.Window().SetStatusBarMessage1("Some extension(s) were just (un)installed or (de)activated.", 4242)
	})
	vsc.Window().OnDidChangeWindowState(func(evt WindowState) {
		vsc.Window().SetStatusBarMessage1(strFmt("Am I focused? {0}.", evt.Focused), 4242)
	})
	vsc.Languages().OnDidChangeDiagnostics(func(evt DiagnosticChangeEvent) {
		vsc.Window().SetStatusBarMessage1(strFmt("Diag(s) changed for {0} file path(s).", len(evt.Uris)), 4242)
	})
}

func demosMenu() {
	var items []string
	items = []string{"demo_promptToExit", "demo_Commands_GetCommands_and_ExecuteCommand", "demo_Commands_RegisterCommand", "demo_Languages_GetLanguages", "demo_Env_Properties", "demo_Workspace_Properties", "demo_Window_ShowOpenDialog", "demo_Window_ShowSaveDialog", "demo_Window_ShowWorkspaceFolderPick", "demo_Env_OpenExternal", "demo_Window_ShowQuickPick", "demo_Window_ShowInputBox"}
	var opts QuickPickOptions
	opts.IgnoreFocusOut = true
	opts.PlaceHolder = "This menu can be re-opened any time via our custom status-bar item."
	vsc.Window().ShowQuickPick2(items, &opts, nil)(func(menuitem *string) {
		if (nil != menuitem) {
			if "demo_promptToExit" == (*menuitem) {
				demo_promptToExit()
			}
			if "demo_Commands_GetCommands_and_ExecuteCommand" == (*menuitem) {
				demo_Commands_GetCommands_and_ExecuteCommand()
			}
			if "demo_Commands_RegisterCommand" == (*menuitem) {
				demo_Commands_RegisterCommand()
			}
			if "demo_Languages_GetLanguages" == (*menuitem) {
				demo_Languages_GetLanguages()
			}
			if "demo_Env_Properties" == (*menuitem) {
				demo_Env_Properties()
			}
			if "demo_Workspace_Properties" == (*menuitem) {
				demo_Workspace_Properties()
			}
			if "demo_Window_ShowOpenDialog" == (*menuitem) {
				demo_Window_ShowOpenDialog()
			}
			if "demo_Window_ShowSaveDialog" == (*menuitem) {
				demo_Window_ShowSaveDialog()
			}
			if "demo_Window_ShowWorkspaceFolderPick" == (*menuitem) {
				demo_Window_ShowWorkspaceFolderPick()
			}
			if "demo_Env_OpenExternal" == (*menuitem) {
				demo_Env_OpenExternal()
			}
			if "demo_Window_ShowQuickPick" == (*menuitem) {
				demo_Window_ShowQuickPick()
			}
			if "demo_Window_ShowInputBox" == (*menuitem) {
				demo_Window_ShowInputBox()
			}
		}
	})
}

func onUpAndRunning() {
	{
		subscribeToMiscEvents()
	}
	{
		vsc.Window().CreateOutputChannel(appName)(func(it *OutputChannel) {
			setOutChan(it)
			logLn(strFmt("Hi, I'm `{0}`, this is my own custom `OutputChannel` where I leisurely log all your interactions with me. When I'm ended, it too will disappear.", appName))
			logLn("")
			logLn("NOTE that for logging error messages, you won't need to manually create a custom `OutputChannel` at all: just have your prog print to its `stderr` as (presumably) usual, and `vscode-appz` will then create a dedicated `OutputChannel` for (both that initial and all subsequent) `stderr` prints from your prog while it's up and running.")
			it.Show(true)
		})
	}
	{
		var statusitem *StatusBarItem
		var clickcount int
		clickcount = 0
		var mycmd func([]any) any
		mycmd = func(_unused []any) any {
			clickcount = 1 + clickcount
			statusitem.Get()(func(props StatusBarItemProperties) {
				props.Text = strFmt("You clicked me {0} time(s).", clickcount)
				if "editorLightBulb.foreground" == props.Color {
					props.Color = "inputValidation.infoBackground"
				} else {
					props.Color = "editorLightBulb.foreground"
				}
				statusitem.Set(props)(demosMenu)
			})
			return nil
		}
		vsc.Commands().RegisterCommand(cmdName, mycmd)(func(_commandRegisteredAtThisPoint *Disposable) {
			vsc.Window().CreateStatusBarItem(0, nil)(func(it *StatusBarItem) {
				statusitem = it
				var props StatusBarItemProperties
				props.Tooltip = strFmt("Hi from {0}!", appName)
				props.Text = "You clicked me 0 time(s)."
				props.Color = "#BEEF88"
				props.Command = cmdName
				statusitem.Set(props)(func() {
					statusitem.Show()
				})
			})
		})
	}
}

