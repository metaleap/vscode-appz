// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-csharp.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
namespace VscAppz {
	using System;
	using System.Collections.Generic;
	using Newtonsoft.Json;
	using any = System.Object;
	using dict = System.Collections.Generic.Dictionary<string, object>;

	/// <summary>Represents the alignment of status bar items.</summary>
	public enum StatusBarAlignment {
		/// <summary>Aligned to the left side.</summary>
		Left = 1,

		/// <summary>Aligned to the right side.</summary>
		Right = 2,
	}

	/// <summary>Describes the behavior of decorations when typing/editing at their edges.</summary>
	public enum DecorationRangeBehavior {
		/// <summary>The decoration's range will widen when edits occur at the start or end.</summary>
		OpenOpen = 0,

		/// <summary>The decoration's range will not widen when edits occur at the start of end.</summary>
		ClosedClosed = 1,

		/// <summary>The decoration's range will widen when edits occur at the start, but not at the end.</summary>
		OpenClosed = 2,

		/// <summary>The decoration's range will widen when edits occur at the end, but not at the start.</summary>
		ClosedOpen = 3,
	}

	/// <summary>
	/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
	/// The overview ruler supports three lanes.
	/// 
	/// </summary>
	public enum OverviewRulerLane {
		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// 
		/// </summary>
		Left = 1,

		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// 
		/// </summary>
		Center = 2,

		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// 
		/// </summary>
		Right = 4,

		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// 
		/// </summary>
		Full = 7,
	}

	/// <summary>
	/// Type Definition for Visual Studio Code 1.39 Extension API
	/// See https://code.visualstudio.com/api for more information
	/// 
	/// </summary>
	public interface IVscode {
		/// <summary>
		/// Namespace for dealing with the current window of the editor. That is visible
		/// and active editors, as well as, UI elements to show messages, selections, and
		/// asking for user input.
		/// 
		/// </summary>
		IWindow Window { get; }

		/// <summary>Namespace describing the environment the editor runs in.</summary>
		IEnv Env { get; }

		/// <summary>
		/// Namespace for dealing with the current workspace. A workspace is the representation
		/// of the folder that has been opened. There is no workspace when just a file but not a
		/// folder has been opened.
		/// 
		/// The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
		/// events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
		/// the editor-process so that they should be always used instead of nodejs-equivalents.
		/// 
		/// </summary>
		IWorkspace Workspace { get; }

		/// <summary>
		/// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
		/// like IntelliSense, code actions, diagnostics etc.
		/// 
		/// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
		/// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
		/// programming languages.
		/// 
		/// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
		/// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
		/// that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
		/// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
		/// 
		/// 
		/// ```javascript
		/// 
		/// languages.registerHoverProvider('javascript', {
		///  	provideHover(document, position, token) {
		///  		return new Hover('I am a hover!');
		///  	}
		/// });
		/// 
		/// ```
		/// 
		/// 
		/// Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
		/// a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
		/// a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
		/// scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
		/// the score is only checked to be `&gt;0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
		/// score is used for determining the order in which providers are asked to participate.
		/// 
		/// </summary>
		ILanguages Languages { get; }

		/// <summary>
		/// Namespace for dealing with installed extensions. Extensions are represented
		/// by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
		/// 
		/// Extension writers can provide APIs to other extensions by returning their API public
		/// surface from the `activate`-call.
		/// 
		/// 
		/// ```javascript
		/// 
		/// export function activate(context: vscode.ExtensionContext) {
		///  	let api = {
		///  		sum(a, b) {
		///  			return a + b;
		///  		},
		///  		mul(a, b) {
		///  			return a * b;
		///  		}
		///  	};
		///  	// 'export' public api-surface
		///  	return api;
		/// }
		/// 
		/// ```
		/// 
		/// When depending on the API of another extension add an `extensionDependency`-entry
		/// to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
		/// and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
		/// 
		/// 
		/// ```javascript
		/// 
		/// let mathExt = extensions.getExtension('genius.math');
		/// let importedApi = mathExt.exports;
		/// 
		/// console.log(importedApi.mul(42, 1));
		/// 
		/// ```
		/// 
		/// 
		/// </summary>
		IExtensions Extensions { get; }

		/// <summary>
		/// Namespace for dealing with commands. In short, a command is a function with a
		/// unique identifier. The function is sometimes also called _command handler_.
		/// 
		/// Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
		/// and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
		/// can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
		/// 
		/// * palette - Use the `commands`-section in `package.json` to make a command show in
		/// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
		/// * keybinding - Use the `keybindings`-section in `package.json` to enable
		/// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
		/// for your extension.
		/// 
		/// Commands from other extensions and from the editor itself are accessible to an extension. However,
		/// when invoking an editor command not all argument types are supported.
		/// 
		/// This is a sample that registers a command handler and adds an entry for that command to the palette. First
		/// register a command handler with the identifier `extension.sayHello`.
		/// 
		/// ```javascript
		/// 
		/// commands.registerCommand('extension.sayHello', () =&gt; {
		///  	window.showInformationMessage('Hello World!');
		/// });
		/// 
		/// ```
		/// 
		/// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
		/// 
		/// ```json
		/// 
		/// {
		///  	"contributes": {
		///  		"commands": [{
		///  			"command": "extension.sayHello",
		///  			"title": "Hello World"
		///  		}]
		///  	}
		/// }
		/// 
		/// ```
		/// 
		/// 
		/// </summary>
		ICommands Commands { get; }
	}

	/// <summary>
	/// Namespace for dealing with the current window of the editor. That is visible
	/// and active editors, as well as, UI elements to show messages, selections, and
	/// asking for user input.
	/// 
	/// </summary>
	public interface IWindow {
		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// 
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowInformationMessage(string message = default, string[] items = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// 
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowWarningMessage(string message = default, string[] items = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// 
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowErrorMessage(string message = default, string[] items = default);

		/// <summary>
		/// Opens an input box to ask the user for input.
		/// 
		/// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
		/// returned value will be the string typed by the user or an empty string if the user did not type
		/// anything but dismissed the input box with OK.
		/// 
		/// `options` ── Configures the behavior of the input box.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `return` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
		/// 
		/// </summary>
		/// <param name="options">Configures the behavior of the input box.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <return>A promise that resolves to a string the user provided or to `undefined` in case of dismissal.</return>
		Action<Action<string>> ShowInputBox(InputBoxOptions options = default, Cancel token = default);

		/// <summary>
		/// Shows a selection list allowing multiple selections.
		/// 
		/// `items` ── An array of items, or a promise that resolves to an array of items.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `return` ── A promise that resolves to the selected items or `undefined`.
		/// 
		/// </summary>
		/// <param name="items">An array of items, or a promise that resolves to an array of items.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <return>A promise that resolves to the selected items or `undefined`.</return>
		Action<Action<QuickPickItem[]>> ShowQuickPick(QuickPickItem[] items = default, QuickPickOptions options = default, Cancel token = default);

		/// <summary>
		/// Set a message to the status bar. This is a short hand for the more powerful
		/// status bar [items](https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem).
		/// 
		/// `text` ── The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).
		/// 
		/// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
		/// 
		/// `return` ── A disposable which hides the status bar message.
		/// 
		/// </summary>
		/// <param name="text">The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).</param>
		/// <param name="hideAfterTimeout">Timeout in milliseconds after which the message will be disposed.</param>
		/// <return>A disposable which hides the status bar message.</return>
		Action<Action<Disposable>> SetStatusBarMessage(string text = default, int hideAfterTimeout = default);

		/// <summary>
		/// Shows a file save dialog to the user which allows to select a file
		/// for saving-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `return` ── A promise that resolves to the selected resource or `undefined`.
		/// 
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <return>A promise that resolves to the selected resource or `undefined`.</return>
		Action<Action<string>> ShowSaveDialog(SaveDialogOptions options = default);

		/// <summary>
		/// Shows a file open dialog to the user which allows to select a file
		/// for opening-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `return` ── A promise that resolves to the selected resources or `undefined`.
		/// 
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <return>A promise that resolves to the selected resources or `undefined`.</return>
		Action<Action<string[]>> ShowOpenDialog(OpenDialogOptions options = default);

		/// <summary>
		/// Shows a selection list of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) to pick from.
		/// Returns `undefined` if no folder is open.
		/// 
		/// `options` ── Configures the behavior of the workspace folder list.
		/// 
		/// `return` ── A promise that resolves to the workspace folder or `undefined`.
		/// 
		/// </summary>
		/// <param name="options">Configures the behavior of the workspace folder list.</param>
		/// <return>A promise that resolves to the workspace folder or `undefined`.</return>
		Action<Action<WorkspaceFolder>> ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options = default);

		/// <summary>
		/// Represents the current window's state.
		/// 
		/// `return` ── a thenable that resolves when this `State` call has successfully completed at the VSC side and its `WindowState` result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `State` call has successfully completed at the VSC side and its `WindowState` result received back at our end.</return>
		Action<Action<WindowState>> State();

		/// <summary>
		/// An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the focus state of the current window
		/// changes. The value of the event represents whether the window is focused.
		/// 
		/// `listener` ── will be invoked whenever the `OnDidChangeWindowState` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWindowState` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="listener">will be invoked whenever the `OnDidChangeWindowState` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWindowState` event on `Dispose`.</return>
		Action<Action<Disposable>> OnDidChangeWindowState(Action<WindowState> listener = default);

		/// <summary>
		/// Creates a status bar [item](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem).
		/// 
		/// `alignment` ── The alignment of the item.
		/// 
		/// `priority` ── The priority of the item. Higher values mean the item should be shown more to the left.
		/// 
		/// `return` ── A new status bar item.
		/// 
		/// </summary>
		/// <param name="alignment">The alignment of the item.</param>
		/// <param name="priority">The priority of the item. Higher values mean the item should be shown more to the left.</param>
		/// <return>A new status bar item.</return>
		Action<Action<StatusBarItem>> CreateStatusBarItem(StatusBarAlignment? alignment = default, int? priority = default);

		/// <summary>
		/// Creates a new [output channel](https://code.visualstudio.com/api/references/vscode-api#OutputChannel) with the given name.
		/// 
		/// `name` ── Human-readable string which will be used to represent the channel in the UI.
		/// 
		/// `return` ── a thenable that resolves to the newly created `OutputChannel`.
		/// 
		/// </summary>
		/// <param name="name">Human-readable string which will be used to represent the channel in the UI.</param>
		/// <return>a thenable that resolves to the newly created `OutputChannel`.</return>
		Action<Action<OutputChannel>> CreateOutputChannel(string name = default);

		/// <summary>
		/// Create a TextEditorDecorationType that can be used to add decorations to text editors.
		/// 
		/// `options` ── Rendering options for the decoration type.
		/// 
		/// `return` ── A new decoration type instance.
		/// 
		/// </summary>
		/// <param name="options">Rendering options for the decoration type.</param>
		/// <return>A new decoration type instance.</return>
		Action<Action<TextEditorDecorationType>> CreateTextEditorDecorationType(DecorationRenderOptions options = default);

		/// <summary>
		/// Creates a [InputBox](https://code.visualstudio.com/api/references/vscode-api#InputBox) to let the user enter some text input.
		/// 
		/// Note that in many cases the more convenient [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox)
		/// is easier to use. [window.createInputBox](https://code.visualstudio.com/api/references/vscode-api#window.createInputBox) should be used
		/// when [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox) does not offer the required flexibility.
		/// 
		/// `return` ── A new [InputBox](https://code.visualstudio.com/api/references/vscode-api#InputBox).
		/// 
		/// </summary>
		/// <return>A new [InputBox](https://code.visualstudio.com/api/references/vscode-api#InputBox).</return>
		Action<Action<InputBox>> CreateInputBox();

		/// <summary>
		/// Creates a [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick) to let the user pick an item from a list
		/// of items of type T.
		/// 
		/// Note that in many cases the more convenient [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick)
		/// is easier to use. [window.createQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.createQuickPick) should be used
		/// when [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick) does not offer the required flexibility.
		/// 
		/// `return` ── A new [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick).
		/// 
		/// </summary>
		/// <return>A new [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick).</return>
		Action<Action<QuickPick>> CreateQuickPick();

		/// <summary>
		/// Creates a [Terminal](https://code.visualstudio.com/api/references/vscode-api#Terminal) with a backing shell process.
		/// 
		/// `options` ── A TerminalOptions object describing the characteristics of the new terminal.
		/// 
		/// `return` ── A new Terminal.
		/// 
		/// </summary>
		/// <param name="options">A TerminalOptions object describing the characteristics of the new terminal.</param>
		/// <return>A new Terminal.</return>
		Action<Action<Terminal>> CreateTerminal(TerminalOptions options = default);
	}

	/// <summary>Namespace describing the environment the editor runs in.</summary>
	public interface IEnv {
		/// <summary>
		/// Opens an *external* item, e.g. a http(s) or mailto-link, using the
		/// default application.
		/// 
		/// *Note* that [`showTextDocument`](https://code.visualstudio.com/api/references/vscode-api#window.showTextDocument) is the right
		/// way to open a text document inside the editor, not this function.
		/// 
		/// `target` ── The uri that should be opened.
		/// 
		/// `return` ── A promise indicating if open was successful.
		/// 
		/// </summary>
		/// <param name="target">The uri that should be opened.</param>
		/// <return>A promise indicating if open was successful.</return>
		Action<Action<bool>> OpenExternal(string target = default);

		/// <summary>
		/// The application name of the editor, like 'VS Code'.
		/// 
		/// `return` ── a thenable that resolves when this `AppName` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `AppName` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> AppName();

		/// <summary>
		/// The application root folder from which the editor is running.
		/// 
		/// `return` ── a thenable that resolves when this `AppRoot` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `AppRoot` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> AppRoot();

		/// <summary>
		/// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
		/// 
		/// `return` ── a thenable that resolves when this `Language` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `Language` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> Language();

		/// <summary>
		/// A unique identifier for the computer.
		/// 
		/// `return` ── a thenable that resolves when this `MachineId` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `MachineId` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> MachineId();

		/// <summary>
		/// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
		/// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
		/// 
		/// *Note* that the value is `undefined` when there is no remote extension host but that the
		/// value is defined in all extension hosts (local and remote) in case a remote extension host
		/// exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
		/// a specific extension runs remote or not.
		/// 
		/// `return` ── a thenable that resolves when this `RemoteName` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `RemoteName` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> RemoteName();

		/// <summary>
		/// A unique identifier for the current session.
		/// Changes each time the editor is started.
		/// 
		/// `return` ── a thenable that resolves when this `SessionId` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `SessionId` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> SessionId();

		/// <summary>
		/// The detected default shell for the extension host, this is overridden by the
		/// `terminal.integrated.shell` setting for the extension host's platform.
		/// 
		/// `return` ── a thenable that resolves when this `Shell` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `Shell` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> Shell();

		/// <summary>
		/// The custom uri scheme the editor registers to in the operating system.
		/// 
		/// `return` ── a thenable that resolves when this `UriScheme` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `UriScheme` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> UriScheme();

		/// <summary>
		/// Provides single-call access to numerous individual `IEnv` properties at once.
		/// 
		/// `return` ── a thenable that resolves when this `AllProperties` call has successfully completed at the VSC side and its `EnvState` result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `AllProperties` call has successfully completed at the VSC side and its `EnvState` result received back at our end.</return>
		Action<Action<EnvState>> AllProperties();

		/// <summary>The clipboard provides read and write access to the system's clipboard.</summary>
		IClipboard Clipboard();
	}

	/// <summary>The clipboard provides read and write access to the system's clipboard.</summary>
	public interface IClipboard {
		/// <summary>
		/// Read the current clipboard contents as text.
		/// 
		/// `return` ── A thenable that resolves to a string.
		/// 
		/// </summary>
		/// <return>A thenable that resolves to a string.</return>
		Action<Action<string>> ReadText();

		/// <summary>
		/// Writes text into the clipboard.
		/// 
		/// `value` ── 
		/// 
		/// `return` ── A thenable that resolves when writing happened.
		/// 
		/// </summary>
		/// <return>A thenable that resolves when writing happened.</return>
		/// <param name="value"></param>
		Action<Action> WriteText(string value = default);
	}

	/// <summary>
	/// Namespace for dealing with the current workspace. A workspace is the representation
	/// of the folder that has been opened. There is no workspace when just a file but not a
	/// folder has been opened.
	/// 
	/// The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
	/// events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
	/// the editor-process so that they should be always used instead of nodejs-equivalents.
	/// 
	/// </summary>
	public interface IWorkspace {
		/// <summary>
		/// The name of the workspace. `undefined` when no folder
		/// has been opened.
		/// 
		/// `return` ── a thenable that resolves when this `Name` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `Name` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> Name();

		/// <summary>
		/// The location of the workspace file, for example:
		/// 
		/// `file:///Users/name/Development/myProject.code-workspace`
		/// 
		/// or
		/// 
		/// `untitled:1555503116870`
		/// 
		/// for a workspace that is untitled and not yet saved.
		/// 
		/// Depending on the workspace that is opened, the value will be:
		///   * `undefined` when no workspace or  a single folder is opened
		///   * the path of the workspace file as `Uri` otherwise. if the workspace
		/// is untitled, the returned URI will use the `untitled:` scheme
		/// 
		/// The location can e.g. be used with the `vscode.openFolder` command to
		/// open the workspace again after it has been closed.
		/// 
		/// **Example:**
		/// 
		/// ```typescript
		/// 
		/// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
		/// 
		/// ```
		/// 
		/// 
		/// **Note:** it is not advised to use `workspace.workspaceFile` to write
		/// configuration data into the file. You can use `workspace.getConfiguration().update()`
		/// for that purpose which will work both when a single folder is opened as
		/// well as an untitled or saved workspace.
		/// 
		/// `return` ── a thenable that resolves when this `WorkspaceFile` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `WorkspaceFile` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<string>> WorkspaceFile();

		/// <summary>
		/// Save all dirty files.
		/// 
		/// `includeUntitled` ── Also save files that have been created during this session.
		/// 
		/// `return` ── A thenable that resolves when the files have been saved.
		/// 
		/// </summary>
		/// <param name="includeUntitled">Also save files that have been created during this session.</param>
		/// <return>A thenable that resolves when the files have been saved.</return>
		Action<Action<bool>> SaveAll(bool includeUntitled = default);

		/// <summary>
		/// An event that is emitted when a workspace folder is added or removed.
		/// 
		/// `listener` ── will be invoked whenever the `OnDidChangeWorkspaceFolders` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWorkspaceFolders` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="listener">will be invoked whenever the `OnDidChangeWorkspaceFolders` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWorkspaceFolders` event on `Dispose`.</return>
		Action<Action<Disposable>> OnDidChangeWorkspaceFolders(Action<WorkspaceFoldersChangeEvent> listener = default);

		/// <summary>
		/// Returns the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) that contains a given uri.
		/// * returns `undefined` when the given uri doesn't match any workspace folder
		/// * returns the *input* when the given uri is a workspace folder itself
		/// 
		/// `uri` ── An uri.
		/// 
		/// `return` ── A workspace folder or `undefined`
		/// 
		/// </summary>
		/// <param name="uri">An uri.</param>
		/// <return>A workspace folder or `undefined`</return>
		Action<Action<WorkspaceFolder>> GetWorkspaceFolder(string uri = default);

		/// <summary>
		/// List of workspace folders or `undefined` when no folder is open.
		/// *Note* that the first entry corresponds to the value of `rootPath`.
		/// 
		/// `return` ── a thenable that resolves when this `WorkspaceFolders` call has successfully completed at the VSC side and its result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `WorkspaceFolders` call has successfully completed at the VSC side and its result received back at our end.</return>
		Action<Action<WorkspaceFolder[]>> WorkspaceFolders();

		/// <summary>
		/// Find files across all [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) in the workspace.
		/// `findFiles('**​/*.js', '**​/node_modules/**', 10)`
		/// 
		/// `include` ── A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines the files to search for. The glob pattern
		/// will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern)
		/// to restrict the search results to a [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder).
		/// 
		/// `exclude` ── A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines files and folders to exclude. The glob pattern
		/// will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will
		/// apply, when `null` no excludes will apply.
		/// 
		/// `maxResults` ── An upper-bound for the result.
		/// 
		/// `token` ── A token that can be used to signal cancellation to the underlying search engine.
		/// 
		/// `return` ── A thenable that resolves to an array of resource identifiers. Will return no results if no
		/// [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) are opened.
		/// 
		/// </summary>
		/// <param name="include">A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines the files to search for. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern) to restrict the search results to a [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder).</param>
		/// <param name="exclude">A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines files and folders to exclude. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will apply, when `null` no excludes will apply.</param>
		/// <param name="maxResults">An upper-bound for the result.</param>
		/// <param name="token">A token that can be used to signal cancellation to the underlying search engine.</param>
		/// <return>A thenable that resolves to an array of resource identifiers. Will return no results if no [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) are opened.</return>
		Action<Action<string[]>> FindFiles(string include = default, string exclude = default, int? maxResults = default, Cancel token = default);

		/// <summary>
		/// Returns a path that is relative to the workspace folder or folders.
		/// 
		/// When there are no [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) or when the path
		/// is not contained in them, the input is returned.
		/// 
		/// `pathOrUri` ── A path or uri. When a uri is given its [fsPath](https://code.visualstudio.com/api/references/vscode-api#Uri.fsPath) is used.
		/// 
		/// `includeWorkspaceFolder` ── When `true` and when the given path is contained inside a
		/// workspace folder the name of the workspace is prepended. Defaults to `true` when there are
		/// multiple workspace folders and `false` otherwise.
		/// 
		/// `return` ── A path relative to the root or the input.
		/// 
		/// </summary>
		/// <param name="pathOrUri">A path or uri. When a uri is given its [fsPath](https://code.visualstudio.com/api/references/vscode-api#Uri.fsPath) is used.</param>
		/// <param name="includeWorkspaceFolder">When `true` and when the given path is contained inside a workspace folder the name of the workspace is prepended. Defaults to `true` when there are multiple workspace folders and `false` otherwise.</param>
		/// <return>A path relative to the root or the input.</return>
		Action<Action<string>> AsRelativePath(string pathOrUri = default, bool includeWorkspaceFolder = default);

		/// <summary>
		/// Creates a file system watcher.
		/// 
		/// A glob pattern that filters the file events on their absolute path must be provided. Optionally,
		/// flags to ignore certain kinds of events can be provided. To stop listening to events the watcher must be disposed.
		/// 
		/// *Note* that only files within the current [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) can be watched.
		/// 
		/// `globPattern` ── A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that is applied to the absolute paths of created, changed,
		/// and deleted files. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern) to limit events to a certain [workspace folder](#WorkspaceFolder).
		/// 
		/// `ignoreCreateEvents` ── Ignore when files have been created.
		/// 
		/// `ignoreChangeEvents` ── Ignore when files have been changed.
		/// 
		/// `ignoreDeleteEvents` ── Ignore when files have been deleted.
		/// 
		/// `return` ── A new file system watcher instance.
		/// 
		/// </summary>
		/// <param name="globPattern">A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that is applied to the absolute paths of created, changed, and deleted files. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern) to limit events to a certain [workspace folder](#WorkspaceFolder).</param>
		/// <param name="ignoreCreateEvents">Ignore when files have been created.</param>
		/// <param name="ignoreChangeEvents">Ignore when files have been changed.</param>
		/// <param name="ignoreDeleteEvents">Ignore when files have been deleted.</param>
		/// <return>A new file system watcher instance.</return>
		Action<Action<FileSystemWatcher>> CreateFileSystemWatcher(string globPattern = default, bool ignoreCreateEvents = default, bool ignoreChangeEvents = default, bool ignoreDeleteEvents = default);

		/// <summary>
		/// Provides single-call access to numerous individual `IWorkspace` properties at once.
		/// 
		/// `return` ── a thenable that resolves when this `AllProperties` call has successfully completed at the VSC side and its `WorkspaceState` result received back at our end.
		/// 
		/// </summary>
		/// <return>a thenable that resolves when this `AllProperties` call has successfully completed at the VSC side and its `WorkspaceState` result received back at our end.</return>
		Action<Action<WorkspaceState>> AllProperties();
	}

	/// <summary>
	/// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
	/// like IntelliSense, code actions, diagnostics etc.
	/// 
	/// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
	/// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
	/// programming languages.
	/// 
	/// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
	/// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
	/// that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
	/// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
	/// 
	/// 
	/// ```javascript
	/// 
	/// languages.registerHoverProvider('javascript', {
	///  	provideHover(document, position, token) {
	///  		return new Hover('I am a hover!');
	///  	}
	/// });
	/// 
	/// ```
	/// 
	/// 
	/// Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
	/// a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
	/// a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
	/// scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
	/// the score is only checked to be `&gt;0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
	/// score is used for determining the order in which providers are asked to participate.
	/// 
	/// </summary>
	public interface ILanguages {
		/// <summary>
		/// Return the identifiers of all known languages.
		/// 
		/// `return` ── Promise resolving to an array of identifier strings.
		/// 
		/// </summary>
		/// <return>Promise resolving to an array of identifier strings.</return>
		Action<Action<string[]>> GetLanguages();

		/// <summary>
		/// An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the global set of diagnostics changes. This is
		/// newly added and removed diagnostics.
		/// 
		/// `listener` ── will be invoked whenever the `OnDidChangeDiagnostics` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChangeDiagnostics` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="listener">will be invoked whenever the `OnDidChangeDiagnostics` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `listener` from the `OnDidChangeDiagnostics` event on `Dispose`.</return>
		Action<Action<Disposable>> OnDidChangeDiagnostics(Action<DiagnosticChangeEvent> listener = default);
	}

	/// <summary>
	/// Namespace for dealing with installed extensions. Extensions are represented
	/// by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
	/// 
	/// Extension writers can provide APIs to other extensions by returning their API public
	/// surface from the `activate`-call.
	/// 
	/// 
	/// ```javascript
	/// 
	/// export function activate(context: vscode.ExtensionContext) {
	///  	let api = {
	///  		sum(a, b) {
	///  			return a + b;
	///  		},
	///  		mul(a, b) {
	///  			return a * b;
	///  		}
	///  	};
	///  	// 'export' public api-surface
	///  	return api;
	/// }
	/// 
	/// ```
	/// 
	/// When depending on the API of another extension add an `extensionDependency`-entry
	/// to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
	/// and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
	/// 
	/// 
	/// ```javascript
	/// 
	/// let mathExt = extensions.getExtension('genius.math');
	/// let importedApi = mathExt.exports;
	/// 
	/// console.log(importedApi.mul(42, 1));
	/// 
	/// ```
	/// 
	/// 
	/// </summary>
	public interface IExtensions {
		/// <summary>
		/// An event which fires when `extensions.all` changes. This can happen when extensions are
		/// installed, uninstalled, enabled or disabled.
		/// 
		/// `listener` ── will be invoked whenever the `OnDidChange` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChange` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="listener">will be invoked whenever the `OnDidChange` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `listener` from the `OnDidChange` event on `Dispose`.</return>
		Action<Action<Disposable>> OnDidChange(Action listener = default);
	}

	/// <summary>
	/// Namespace for dealing with commands. In short, a command is a function with a
	/// unique identifier. The function is sometimes also called _command handler_.
	/// 
	/// Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
	/// and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
	/// can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
	/// 
	/// * palette - Use the `commands`-section in `package.json` to make a command show in
	/// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
	/// * keybinding - Use the `keybindings`-section in `package.json` to enable
	/// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
	/// for your extension.
	/// 
	/// Commands from other extensions and from the editor itself are accessible to an extension. However,
	/// when invoking an editor command not all argument types are supported.
	/// 
	/// This is a sample that registers a command handler and adds an entry for that command to the palette. First
	/// register a command handler with the identifier `extension.sayHello`.
	/// 
	/// ```javascript
	/// 
	/// commands.registerCommand('extension.sayHello', () =&gt; {
	///  	window.showInformationMessage('Hello World!');
	/// });
	/// 
	/// ```
	/// 
	/// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
	/// 
	/// ```json
	/// 
	/// {
	///  	"contributes": {
	///  		"commands": [{
	///  			"command": "extension.sayHello",
	///  			"title": "Hello World"
	///  		}]
	///  	}
	/// }
	/// 
	/// ```
	/// 
	/// 
	/// </summary>
	public interface ICommands {
		/// <summary>
		/// Registers a command that can be invoked via a keyboard shortcut,
		/// a menu item, an action, or directly.
		/// 
		/// Registering a command with an existing command identifier twice
		/// will cause an error.
		/// 
		/// `command` ── A unique identifier for the command.
		/// 
		/// `callback` ── A command handler function.
		/// 
		/// `return` ── Disposable which unregisters this command on disposal.
		/// 
		/// </summary>
		/// <param name="command">A unique identifier for the command.</param>
		/// <param name="callback">A command handler function.</param>
		/// <return>Disposable which unregisters this command on disposal.</return>
		Action<Action<Disposable>> RegisterCommand(string command = default, Func<any[], any> callback = default);

		/// <summary>
		/// Executes the command denoted by the given command identifier.
		/// 
		/// * *Note 1:* When executing an editor command not all types are allowed to
		/// be passed as arguments. Allowed are the primitive types `string`, `boolean`,
		/// `number`, `undefined`, and `null`, as well as [`Position`](https://code.visualstudio.com/api/references/vscode-api#Position), [`Range`](#Range), [`Uri`](#Uri) and [`Location`](#Location).
		/// * *Note 2:* There are no restrictions when executing commands that have been contributed
		/// by extensions.
		/// 
		/// `command` ── Identifier of the command to execute.
		/// 
		/// `rest` ── Parameters passed to the command function.
		/// 
		/// `return` ── A thenable that resolves to the returned value of the given command. `undefined` when
		/// the command handler function doesn't return anything.
		/// 
		/// </summary>
		/// <param name="command">Identifier of the command to execute.</param>
		/// <param name="rest">Parameters passed to the command function.</param>
		/// <return>A thenable that resolves to the returned value of the given command. `undefined` when the command handler function doesn't return anything.</return>
		Action<Action<any>> ExecuteCommand(string command = default, any[] rest = default);

		/// <summary>
		/// Retrieve the list of all available commands. Commands starting an underscore are
		/// treated as internal commands.
		/// 
		/// `filterInternal` ── Set `true` to not see internal commands (starting with an underscore)
		/// 
		/// `return` ── Thenable that resolves to a list of command ids.
		/// 
		/// </summary>
		/// <param name="filterInternal">Set `true` to not see internal commands (starting with an underscore)</param>
		/// <return>Thenable that resolves to a list of command ids.</return>
		Action<Action<string[]>> GetCommands(bool filterInternal = default);
	}

	/// <summary>Represents theme specific rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).</summary>
	public partial class ThemableDecorationRenderOptions {
		/// <summary>
		/// Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
		/// Alternatively a color from the color registry can be [referenced](https://code.visualstudio.com/api/references/vscode-api#ThemeColor).
		/// 
		/// </summary>
		[JsonProperty("backgroundColor")]
		public string BackgroundColor;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("outline")]
		public string Outline;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// 
		/// </summary>
		[JsonProperty("outlineColor")]
		public string OutlineColor;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// 
		/// </summary>
		[JsonProperty("outlineStyle")]
		public string OutlineStyle;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// 
		/// </summary>
		[JsonProperty("outlineWidth")]
		public string OutlineWidth;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("border")]
		public string Border;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderColor")]
		public string BorderColor;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderRadius")]
		public string BorderRadius;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderSpacing")]
		public string BorderSpacing;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderStyle")]
		public string BorderStyle;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderWidth")]
		public string BorderWidth;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("fontStyle")]
		public string FontStyle;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("fontWeight")]
		public string FontWeight;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("textDecoration")]
		public string TextDecoration;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("cursor")]
		public string Cursor;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("color")]
		public string Color;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("opacity")]
		public string Opacity;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("letterSpacing")]
		public string LetterSpacing;

		/// <summary>An **absolute path** or an URI to an image to be rendered in the gutter.</summary>
		[JsonProperty("gutterIconPath")]
		public string GutterIconPath;

		/// <summary>
		/// Specifies the size of the gutter icon.
		/// Available values are 'auto', 'contain', 'cover' and any percentage value.
		/// For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
		/// 
		/// </summary>
		[JsonProperty("gutterIconSize")]
		public string GutterIconSize;

		/// <summary>The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.</summary>
		[JsonProperty("overviewRulerColor")]
		public string OverviewRulerColor;

		/// <summary>Defines the rendering options of the attachment that is inserted before the decorated text.</summary>
		[JsonProperty("before")]
		public ThemableDecorationAttachmentRenderOptions Before;

		/// <summary>Defines the rendering options of the attachment that is inserted after the decorated text.</summary>
		[JsonProperty("after")]
		public ThemableDecorationAttachmentRenderOptions After;
	}

	/// <summary>Options to configure the behavior of the input box UI.</summary>
	public partial class InputBoxOptions {
		/// <summary>The value to prefill in the input box.</summary>
		[JsonProperty("value")]
		public string Value;

		/// <summary>
		/// Selection of the prefilled [`value`](https://code.visualstudio.com/api/references/vscode-api#InputBoxOptions.value). Defined as tuple of two number where the
		/// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
		/// word will be selected, when empty (start equals end) only the cursor will be set,
		/// otherwise the defined range will be selected.
		/// 
		/// </summary>
		[JsonProperty("valueSelection"), JsonConverter(typeof(json.valueTuples))]
		public (int, int)? ValueSelection;

		/// <summary>The text to display underneath the input box.</summary>
		[JsonProperty("prompt")]
		public string Prompt;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to type.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to show a password prompt that will not show the typed value.</summary>
		[JsonProperty("password")]
		public bool Password;

		/// <summary>Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>
		/// An optional function that will be called to validate input and to give a hint
		/// to the user.
		/// 
		/// `value` ── The current value of the input box.
		/// 
		/// `return` ── A human readable string which is presented as diagnostic message.
		/// Return `undefined`, `null`, or the empty string when 'value' is valid.
		/// 
		/// </summary>
		[JsonIgnore]
		public Func<string, string> ValidateInput;

		[JsonProperty("validateInput_AppzFuncId")]
		internal string ValidateInput_AppzFuncId;
	}

	/// <summary>
	/// Represents an item that can be selected from
	/// a list of items.
	/// 
	/// </summary>
	public partial class QuickPickItem {
		/// <summary>A human readable string which is rendered prominent.</summary>
		[JsonProperty("label"), JsonRequired]
		public string Label;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("description")]
		public string Description;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("detail")]
		public string Detail;

		/// <summary>
		/// Optional flag indicating if this item is picked initially.
		/// (Only honored when the picker allows multiple selections.)
		/// 
		/// </summary>
		[JsonProperty("picked")]
		public bool Picked;

		/// <summary>Always show this item.</summary>
		[JsonProperty("alwaysShow")]
		public bool AlwaysShow;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public dict My;
	}

	/// <summary>Options to configure the behavior of the quick pick UI.</summary>
	public partial class QuickPickOptions {
		/// <summary>An optional flag to include the description when filtering the picks.</summary>
		[JsonProperty("matchOnDescription")]
		public bool MatchOnDescription;

		/// <summary>An optional flag to include the detail when filtering the picks.</summary>
		[JsonProperty("matchOnDetail")]
		public bool MatchOnDetail;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>An optional flag to make the picker accept multiple selections, if true the result is an array of picks.</summary>
		[JsonProperty("canPickMany")]
		public bool CanPickMany;

		/// <summary>An optional function that is invoked whenever an item is selected.</summary>
		[JsonIgnore]
		public Func<QuickPickItem, any> OnDidSelectItem;

		[JsonProperty("onDidSelectItem_AppzFuncId")]
		internal string OnDidSelectItem_AppzFuncId;
	}

	/// <summary>Options to configure the behaviour of a file save dialog.</summary>
	public partial class SaveDialogOptions {
		/// <summary>The resource the dialog shows when opened.</summary>
		[JsonProperty("defaultUri")]
		public string DefaultUri;

		/// <summary>A human-readable string for the save button.</summary>
		[JsonProperty("saveLabel")]
		public string SaveLabel;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// 
		/// ```ts
		/// 
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// 
		/// ```
		/// 
		/// 
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>
	/// Options to configure the behaviour of a file open dialog.
	/// 
	/// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
	/// which enforces to open either files or folder, but *not both*.
	/// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
	/// and the editor then silently adjusts the options to select files.
	/// 
	/// </summary>
	public partial class OpenDialogOptions {
		/// <summary>The resource the dialog shows when opened.</summary>
		[JsonProperty("defaultUri")]
		public string DefaultUri;

		/// <summary>A human-readable string for the open button.</summary>
		[JsonProperty("openLabel")]
		public string OpenLabel;

		/// <summary>Allow to select files, defaults to `true`.</summary>
		[JsonProperty("canSelectFiles")]
		public bool CanSelectFiles;

		/// <summary>Allow to select folders, defaults to `false`.</summary>
		[JsonProperty("canSelectFolders")]
		public bool CanSelectFolders;

		/// <summary>Allow to select many files or folders.</summary>
		[JsonProperty("canSelectMany")]
		public bool CanSelectMany;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// 
		/// ```ts
		/// 
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// 
		/// ```
		/// 
		/// 
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>Options to configure the behaviour of the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) pick UI.</summary>
	public partial class WorkspaceFolderPickOptions {
		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;
	}

	/// <summary>
	/// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
	/// are equal which means there is no notion of an active or master workspace folder.
	/// 
	/// </summary>
	public partial class WorkspaceFolder {
		/// <summary>
		/// The associated uri for this workspace folder.
		/// 
		/// *Note:* The [Uri](https://code.visualstudio.com/api/references/vscode-api#Uri)-type was intentionally chosen such that future releases of the editor can support
		/// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
		/// 
		/// </summary>
		[JsonProperty("uri"), JsonRequired]
		public string Uri;

		/// <summary>
		/// The name of this workspace folder. Defaults to
		/// the basename of its [uri-path](https://code.visualstudio.com/api/references/vscode-api#Uri.path)
		/// 
		/// </summary>
		[JsonProperty("name"), JsonRequired]
		public string Name;

		/// <summary>The ordinal number of this workspace folder.</summary>
		[JsonProperty("index"), JsonRequired]
		public int Index;
	}

	/// <summary>Represents the state of a window.</summary>
	public partial class WindowState {
		/// <summary>Whether the current window is focused.</summary>
		[JsonProperty("focused"), JsonRequired]
		public bool Focused;
	}

	/// <summary>
	/// A status bar item is a status bar contribution that can
	/// show text and icons and run a command on click.
	/// 
	/// </summary>
	public partial class StatusBarItem {
		internal Disposable __disp__;

		/// <summary>Cfg represents this `StatusBarItem`'s current state. All its members get auto-refreshed every time any `StatusBarItem` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method. Your local modifications to its members will **not** be auto-propagated to VSC, this must be done explicitly via its `ApplyChanges` method.</summary>
		public StatusBarItemState Cfg;
	}

	/// <summary>
	/// An output channel is a container for readonly textual information.
	/// 
	/// To get an instance of an `OutputChannel` use
	/// [createOutputChannel](https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel).
	/// 
	/// </summary>
	public partial class OutputChannel {
		internal Disposable __disp__;

		/// <summary>Cfg represents this `OutputChannel`'s current state. All its members get auto-refreshed every time any `OutputChannel` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method.</summary>
		public OutputChannelState Cfg;
	}

	/// <summary>
	/// Type Definition for Visual Studio Code 1.39 Extension API
	/// See https://code.visualstudio.com/api for more information
	/// 
	/// </summary>
	public partial class ThemableDecorationAttachmentRenderOptions {
		/// <summary>Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.</summary>
		[JsonProperty("contentText")]
		public string ContentText;

		/// <summary>
		/// An **absolute path** or an URI to an image to be rendered in the attachment. Either an icon
		/// or a text can be shown, but not both.
		/// 
		/// </summary>
		[JsonProperty("contentIconPath")]
		public string ContentIconPath;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("border")]
		public string Border;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("borderColor")]
		public string BorderColor;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("fontStyle")]
		public string FontStyle;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("fontWeight")]
		public string FontWeight;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("textDecoration")]
		public string TextDecoration;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("color")]
		public string Color;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("backgroundColor")]
		public string BackgroundColor;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("margin")]
		public string Margin;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("width")]
		public string Width;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("height")]
		public string Height;
	}

	/// <summary>Represents rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).</summary>
	public partial class DecorationRenderOptions {
		/// <summary>
		/// Should the decoration be rendered also on the whitespace after the line text.
		/// Defaults to `false`.
		/// 
		/// </summary>
		[JsonProperty("isWholeLine")]
		public bool IsWholeLine;

		/// <summary>
		/// Customize the growing behavior of the decoration when edits occur at the edges of the decoration's range.
		/// Defaults to `DecorationRangeBehavior.OpenOpen`.
		/// 
		/// </summary>
		[JsonProperty("rangeBehavior")]
		public DecorationRangeBehavior? RangeBehavior;

		/// <summary>The position in the overview ruler where the decoration should be rendered.</summary>
		[JsonProperty("overviewRulerLane")]
		public OverviewRulerLane? OverviewRulerLane;

		/// <summary>Overwrite options for light themes.</summary>
		[JsonProperty("light")]
		public ThemableDecorationRenderOptions Light;

		/// <summary>Overwrite options for dark themes.</summary>
		[JsonProperty("dark")]
		public ThemableDecorationRenderOptions Dark;

		/// <summary>
		/// Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
		/// Alternatively a color from the color registry can be [referenced](https://code.visualstudio.com/api/references/vscode-api#ThemeColor).
		/// 
		/// </summary>
		[JsonProperty("backgroundColor")]
		public string BackgroundColor;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("outline")]
		public string Outline;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// 
		/// </summary>
		[JsonProperty("outlineColor")]
		public string OutlineColor;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// 
		/// </summary>
		[JsonProperty("outlineStyle")]
		public string OutlineStyle;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// 
		/// </summary>
		[JsonProperty("outlineWidth")]
		public string OutlineWidth;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("border")]
		public string Border;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderColor")]
		public string BorderColor;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderRadius")]
		public string BorderRadius;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderSpacing")]
		public string BorderSpacing;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderStyle")]
		public string BorderStyle;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// 
		/// </summary>
		[JsonProperty("borderWidth")]
		public string BorderWidth;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("fontStyle")]
		public string FontStyle;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("fontWeight")]
		public string FontWeight;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("textDecoration")]
		public string TextDecoration;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("cursor")]
		public string Cursor;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("color")]
		public string Color;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("opacity")]
		public string Opacity;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("letterSpacing")]
		public string LetterSpacing;

		/// <summary>An **absolute path** or an URI to an image to be rendered in the gutter.</summary>
		[JsonProperty("gutterIconPath")]
		public string GutterIconPath;

		/// <summary>
		/// Specifies the size of the gutter icon.
		/// Available values are 'auto', 'contain', 'cover' and any percentage value.
		/// For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
		/// 
		/// </summary>
		[JsonProperty("gutterIconSize")]
		public string GutterIconSize;

		/// <summary>The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.</summary>
		[JsonProperty("overviewRulerColor")]
		public string OverviewRulerColor;

		/// <summary>Defines the rendering options of the attachment that is inserted before the decorated text.</summary>
		[JsonProperty("before")]
		public ThemableDecorationAttachmentRenderOptions Before;

		/// <summary>Defines the rendering options of the attachment that is inserted after the decorated text.</summary>
		[JsonProperty("after")]
		public ThemableDecorationAttachmentRenderOptions After;
	}

	/// <summary>
	/// Represents a handle to a set of decorations
	/// sharing the same [styling options](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions) in a [text editor](#TextEditor).
	/// 
	/// To get an instance of a `TextEditorDecorationType` use
	/// [createTextEditorDecorationType](https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType).
	/// 
	/// </summary>
	public partial class TextEditorDecorationType {
		internal Disposable __disp__;

		/// <summary>Cfg represents this `TextEditorDecorationType`'s current state. All its members get auto-refreshed every time any `TextEditorDecorationType` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method.</summary>
		public TextEditorDecorationTypeState Cfg;
	}

	/// <summary>
	/// A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user input a text value.
	/// 
	/// Note that in many cases the more convenient [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox)
	/// is easier to use. [window.createInputBox](https://code.visualstudio.com/api/references/vscode-api#window.createInputBox) should be used
	/// when [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox) does not offer the required flexibility.
	/// 
	/// </summary>
	public partial class InputBox {
		internal Disposable __disp__;

		/// <summary>Cfg represents this `InputBox`'s current state. All its members get auto-refreshed every time a (subscribed) `InputBox` event fires or any `InputBox` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method. Your local modifications to its members will **not** be auto-propagated to VSC, this must be done explicitly via its `ApplyChanges` method.</summary>
		public InputBoxState Cfg;
	}

	/// <summary>Button for an action in a [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick) or [InputBox](#InputBox).</summary>
	public partial class QuickInputButton {
		/// <summary>Icon for the button.</summary>
		[JsonProperty("iconPath"), JsonRequired]
		public string IconPath;

		/// <summary>An optional tooltip.</summary>
		[JsonProperty("tooltip")]
		public string Tooltip;
	}

	/// <summary>
	/// A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user pick an item from a
	/// list of items of type T. The items can be filtered through a filter text field and
	/// there is an option [canSelectMany](https://code.visualstudio.com/api/references/vscode-api#QuickPick.canSelectMany) to allow for
	/// selecting multiple items.
	/// 
	/// Note that in many cases the more convenient [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick)
	/// is easier to use. [window.createQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.createQuickPick) should be used
	/// when [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick) does not offer the required flexibility.
	/// 
	/// </summary>
	public partial class QuickPick {
		internal Disposable __disp__;

		/// <summary>Cfg represents this `QuickPick`'s current state. All its members get auto-refreshed every time a (subscribed) `QuickPick` event fires or any `QuickPick` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method. Your local modifications to its members will **not** be auto-propagated to VSC, this must be done explicitly via its `ApplyChanges` method.</summary>
		public QuickPickState Cfg;
	}

	/// <summary>Value-object describing what options a terminal should use.</summary>
	public partial class TerminalOptions {
		/// <summary>A human-readable string which will be used to represent the terminal in the UI.</summary>
		[JsonProperty("name")]
		public string Name;

		/// <summary>A path to a custom shell executable to be used in the terminal.</summary>
		[JsonProperty("shellPath")]
		public string ShellPath;

		/// <summary>
		/// Args for the custom shell executable. A string can be used on Windows only which allows
		/// specifying shell args in [command-line format](https://msdn.microsoft.com/en-au/08dfcab2-eb6e-49a4-80eb-87d4076c98c6).
		/// 
		/// </summary>
		[JsonProperty("shellArgs")]
		public string[] ShellArgs;

		/// <summary>A path or Uri for the current working directory to be used for the terminal.</summary>
		[JsonProperty("cwd")]
		public string Cwd;

		/// <summary>Object with environment variables that will be added to the VS Code process.</summary>
		[JsonProperty("env")]
		public Dictionary<string, string> Env;

		/// <summary>
		/// Whether the terminal process environment should be exactly as provided in
		/// `TerminalOptions.env`. When this is false (default), the environment will be based on the
		/// window's environment and also apply configured platform settings like
		/// `terminal.integrated.windows.env` on top. When this is true, the complete environment
		/// must be provided as nothing will be inherited from the process or any configuration.
		/// 
		/// </summary>
		[JsonProperty("strictEnv")]
		public bool StrictEnv;

		/// <summary>
		/// When enabled the terminal will run the process as normal but not be surfaced to the user
		/// until `Terminal.show` is called. The typical usage for this is when you need to run
		/// something that may need interactivity but only want to tell the user about it when
		/// interaction is needed. Note that the terminals will still be exposed to all extensions
		/// as normal.
		/// 
		/// </summary>
		[JsonProperty("hideFromUser")]
		public bool HideFromUser;
	}

	/// <summary>An individual terminal instance within the integrated terminal.</summary>
	public partial class Terminal {
		internal Disposable __disp__;

		/// <summary>Cfg represents this `Terminal`'s current state. All its members get auto-refreshed every time any `Terminal` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method.</summary>
		public TerminalState Cfg;
	}

	/// <summary>An event describing a change to the set of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders).</summary>
	public partial class WorkspaceFoldersChangeEvent {
		/// <summary>Added workspace folders.</summary>
		[JsonProperty("added"), JsonRequired]
		public WorkspaceFolder[] Added;

		/// <summary>Removed workspace folders.</summary>
		[JsonProperty("removed"), JsonRequired]
		public WorkspaceFolder[] Removed;
	}

	/// <summary>
	/// A file system watcher notifies about changes to files and folders
	/// on disk.
	/// 
	/// To get an instance of a `FileSystemWatcher` use
	/// [createFileSystemWatcher](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher).
	/// 
	/// </summary>
	public partial class FileSystemWatcher {
		internal Disposable __disp__;

		/// <summary>Cfg represents this `FileSystemWatcher`'s current state. All its members get auto-refreshed every time a (subscribed) `FileSystemWatcher` event fires or any `FileSystemWatcher` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method. Your local modifications to its members will **not** be auto-propagated to VSC, this must be done explicitly via its `ApplyChanges` method.</summary>
		public FileSystemWatcherState Cfg;
	}

	/// <summary>The event that is fired when diagnostics change.</summary>
	public partial class DiagnosticChangeEvent {
		/// <summary>An array of resources for which diagnostics have changed.</summary>
		[JsonProperty("uris"), JsonRequired]
		public string[] Uris;
	}

	/// <summary>EnvState gathers various properties of `IEnv`, obtainable via its `AllProperties` method.</summary>
	public partial class EnvState {
		/// <summary>The application name of the editor, like 'VS Code'.</summary>
		[JsonProperty("appName")]
		public string AppName;

		/// <summary>The application root folder from which the editor is running.</summary>
		[JsonProperty("appRoot")]
		public string AppRoot;

		/// <summary>Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.</summary>
		[JsonProperty("language")]
		public string Language;

		/// <summary>A unique identifier for the computer.</summary>
		[JsonProperty("machineId")]
		public string MachineId;

		/// <summary>
		/// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
		/// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
		/// 
		/// *Note* that the value is `undefined` when there is no remote extension host but that the
		/// value is defined in all extension hosts (local and remote) in case a remote extension host
		/// exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
		/// a specific extension runs remote or not.
		/// 
		/// </summary>
		[JsonProperty("remoteName")]
		public string RemoteName;

		/// <summary>
		/// A unique identifier for the current session.
		/// Changes each time the editor is started.
		/// 
		/// </summary>
		[JsonProperty("sessionId")]
		public string SessionId;

		/// <summary>
		/// The detected default shell for the extension host, this is overridden by the
		/// `terminal.integrated.shell` setting for the extension host's platform.
		/// 
		/// </summary>
		[JsonProperty("shell")]
		public string Shell;

		/// <summary>The custom uri scheme the editor registers to in the operating system.</summary>
		[JsonProperty("uriScheme")]
		public string UriScheme;
	}

	/// <summary>WorkspaceState gathers various properties of `IWorkspace`, obtainable via its `AllProperties` method.</summary>
	public partial class WorkspaceState {
		/// <summary>
		/// The name of the workspace. `undefined` when no folder
		/// has been opened.
		/// 
		/// </summary>
		[JsonProperty("name")]
		public string Name;

		/// <summary>
		/// The location of the workspace file, for example:
		/// 
		/// `file:///Users/name/Development/myProject.code-workspace`
		/// 
		/// or
		/// 
		/// `untitled:1555503116870`
		/// 
		/// for a workspace that is untitled and not yet saved.
		/// 
		/// Depending on the workspace that is opened, the value will be:
		///   * `undefined` when no workspace or  a single folder is opened
		///   * the path of the workspace file as `Uri` otherwise. if the workspace
		/// is untitled, the returned URI will use the `untitled:` scheme
		/// 
		/// The location can e.g. be used with the `vscode.openFolder` command to
		/// open the workspace again after it has been closed.
		/// 
		/// **Example:**
		/// 
		/// ```typescript
		/// 
		/// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
		/// 
		/// ```
		/// 
		/// 
		/// **Note:** it is not advised to use `workspace.workspaceFile` to write
		/// configuration data into the file. You can use `workspace.getConfiguration().update()`
		/// for that purpose which will work both when a single folder is opened as
		/// well as an untitled or saved workspace.
		/// 
		/// </summary>
		[JsonProperty("workspaceFile")]
		public string WorkspaceFile;

		/// <summary>
		/// List of workspace folders or `undefined` when no folder is open.
		/// *Note* that the first entry corresponds to the value of `rootPath`.
		/// 
		/// </summary>
		[JsonProperty("workspaceFolders")]
		public WorkspaceFolder[] WorkspaceFolders;
	}

	/// <summary>StatusBarItemState (to be accessed only via `StatusBarItem.Cfg`) is a snapshot of `StatusBarItem` state. It is auto-updated whenever `StatusBarItem` creations and method calls resolve or its event subscribers (if any) are invoked. All read-only properties are exposed as function-valued fields. Changes to any non-read-only properties (ie. non-function-valued fields) must be explicitly propagated to the VSC side via the `ApplyChanges` method.</summary>
	public partial class StatusBarItemState {
		[JsonIgnore]
		internal StatusBarItem __holder__;

		/// <summary>The alignment of this item.</summary>
		[JsonIgnore]
		public Func<StatusBarAlignment> Alignment;

		/// <summary>
		/// The priority of this item. Higher value means the item should
		/// be shown more to the left.
		/// 
		/// </summary>
		[JsonIgnore]
		public Func<int> Priority;

		/// <summary>
		/// The text to show for the entry. You can embed icons in the text by leveraging the syntax:
		/// 
		/// `My text $(icon-name) contains icons like $(icon-name) this one.`
		/// 
		/// Where the icon-name is taken from the [octicon](https://octicons.github.com) icon set, e.g.
		/// `light-bulb`, `thumbsup`, `zap` etc.
		/// 
		/// </summary>
		[JsonProperty("text"), JsonRequired]
		public string Text;

		/// <summary>The tooltip text when you hover over this entry.</summary>
		[JsonProperty("tooltip"), JsonRequired]
		public string Tooltip;

		/// <summary>The foreground color for this entry.</summary>
		[JsonProperty("color"), JsonRequired]
		public string Color;

		/// <summary>
		/// The identifier of a command to run on click. The command must be
		/// [known](https://code.visualstudio.com/api/references/vscode-api#commands.getCommands).
		/// 
		/// </summary>
		[JsonProperty("command"), JsonRequired]
		public string Command;
	}

	/// <summary>OutputChannelState (to be accessed only via `OutputChannel.Cfg`) is a snapshot of `OutputChannel` state. It is auto-updated whenever `OutputChannel` creations and method calls resolve or its event subscribers (if any) are invoked. All read-only properties are exposed as function-valued fields.</summary>
	public partial class OutputChannelState {
		[JsonIgnore]
		internal OutputChannel __holder__;

		/// <summary>The human-readable name of this output channel.</summary>
		[JsonIgnore]
		public Func<string> Name;
	}

	/// <summary>TextEditorDecorationTypeState (to be accessed only via `TextEditorDecorationType.Cfg`) is a snapshot of `TextEditorDecorationType` state. It is auto-updated whenever `TextEditorDecorationType` creations and method calls resolve or its event subscribers (if any) are invoked. All read-only properties are exposed as function-valued fields.</summary>
	public partial class TextEditorDecorationTypeState {
		[JsonIgnore]
		internal TextEditorDecorationType __holder__;

		/// <summary>Internal representation of the handle.</summary>
		[JsonIgnore]
		public Func<string> Key;
	}

	/// <summary>InputBoxState (to be accessed only via `InputBox.Cfg`) is a snapshot of `InputBox` state. It is auto-updated whenever `InputBox` creations and method calls resolve or its event subscribers (if any) are invoked. Changes to any non-read-only properties (ie. non-function-valued fields) must be explicitly propagated to the VSC side via the `ApplyChanges` method.</summary>
	public partial class InputBoxState {
		[JsonIgnore]
		internal InputBox __holder__;

		/// <summary>Current input value.</summary>
		[JsonProperty("value"), JsonRequired]
		public string Value;

		/// <summary>Optional placeholder in the filter text.</summary>
		[JsonProperty("placeholder"), JsonRequired]
		public string Placeholder;

		/// <summary>If the input value should be hidden. Defaults to false.</summary>
		[JsonProperty("password"), JsonRequired]
		public bool Password;

		/// <summary>An optional prompt text providing some ask or explanation to the user.</summary>
		[JsonProperty("prompt"), JsonRequired]
		public string Prompt;

		/// <summary>An optional validation message indicating a problem with the current input value.</summary>
		[JsonProperty("validationMessage"), JsonRequired]
		public string ValidationMessage;

		/// <summary>An optional title.</summary>
		[JsonProperty("title"), JsonRequired]
		public string Title;

		/// <summary>An optional current step count.</summary>
		[JsonProperty("step"), JsonRequired]
		public int? Step;

		/// <summary>An optional total step count.</summary>
		[JsonProperty("totalSteps"), JsonRequired]
		public int? TotalSteps;

		/// <summary>
		/// If the UI should allow for user input. Defaults to true.
		/// 
		/// Change this to false, e.g., while validating user input or
		/// loading data for the next step in user input.
		/// 
		/// </summary>
		[JsonProperty("enabled"), JsonRequired]
		public bool Enabled;

		/// <summary>
		/// If the UI should show a progress indicator. Defaults to false.
		/// 
		/// Change this to true, e.g., while loading more data or validating
		/// user input.
		/// 
		/// </summary>
		[JsonProperty("busy"), JsonRequired]
		public bool Busy;

		/// <summary>If the UI should stay open even when loosing UI focus. Defaults to false.</summary>
		[JsonProperty("ignoreFocusOut"), JsonRequired]
		public bool IgnoreFocusOut;
	}

	/// <summary>QuickPickState (to be accessed only via `QuickPick.Cfg`) is a snapshot of `QuickPick` state. It is auto-updated whenever `QuickPick` creations and method calls resolve or its event subscribers (if any) are invoked. Changes to any non-read-only properties (ie. non-function-valued fields) must be explicitly propagated to the VSC side via the `ApplyChanges` method.</summary>
	public partial class QuickPickState {
		[JsonIgnore]
		internal QuickPick __holder__;

		/// <summary>Current value of the filter text.</summary>
		[JsonProperty("value"), JsonRequired]
		public string Value;

		/// <summary>Optional placeholder in the filter text.</summary>
		[JsonProperty("placeholder"), JsonRequired]
		public string Placeholder;

		/// <summary>Items to pick from.</summary>
		[JsonProperty("items"), JsonRequired]
		public QuickPickItem[] Items;

		/// <summary>If multiple items can be selected at the same time. Defaults to false.</summary>
		[JsonProperty("canSelectMany"), JsonRequired]
		public bool CanSelectMany;

		/// <summary>If the filter text should also be matched against the description of the items. Defaults to false.</summary>
		[JsonProperty("matchOnDescription"), JsonRequired]
		public bool MatchOnDescription;

		/// <summary>If the filter text should also be matched against the detail of the items. Defaults to false.</summary>
		[JsonProperty("matchOnDetail"), JsonRequired]
		public bool MatchOnDetail;

		/// <summary>Active items. This can be read and updated by the extension.</summary>
		[JsonProperty("activeItems"), JsonRequired]
		public QuickPickItem[] ActiveItems;

		/// <summary>Selected items. This can be read and updated by the extension.</summary>
		[JsonProperty("selectedItems"), JsonRequired]
		public QuickPickItem[] SelectedItems;

		/// <summary>An optional title.</summary>
		[JsonProperty("title"), JsonRequired]
		public string Title;

		/// <summary>An optional current step count.</summary>
		[JsonProperty("step"), JsonRequired]
		public int? Step;

		/// <summary>An optional total step count.</summary>
		[JsonProperty("totalSteps"), JsonRequired]
		public int? TotalSteps;

		/// <summary>
		/// If the UI should allow for user input. Defaults to true.
		/// 
		/// Change this to false, e.g., while validating user input or
		/// loading data for the next step in user input.
		/// 
		/// </summary>
		[JsonProperty("enabled"), JsonRequired]
		public bool Enabled;

		/// <summary>
		/// If the UI should show a progress indicator. Defaults to false.
		/// 
		/// Change this to true, e.g., while loading more data or validating
		/// user input.
		/// 
		/// </summary>
		[JsonProperty("busy"), JsonRequired]
		public bool Busy;

		/// <summary>If the UI should stay open even when loosing UI focus. Defaults to false.</summary>
		[JsonProperty("ignoreFocusOut"), JsonRequired]
		public bool IgnoreFocusOut;
	}

	/// <summary>TerminalState (to be accessed only via `Terminal.Cfg`) is a snapshot of `Terminal` state. It is auto-updated whenever `Terminal` creations and method calls resolve or its event subscribers (if any) are invoked. All read-only properties are exposed as function-valued fields.</summary>
	public partial class TerminalState {
		[JsonIgnore]
		internal Terminal __holder__;

		/// <summary>The name of the terminal.</summary>
		[JsonIgnore]
		public Func<string> Name;
	}

	/// <summary>FileSystemWatcherState (to be accessed only via `FileSystemWatcher.Cfg`) is a snapshot of `FileSystemWatcher` state. It is auto-updated whenever `FileSystemWatcher` creations and method calls resolve or its event subscribers (if any) are invoked. Changes to any non-read-only properties (ie. non-function-valued fields) must be explicitly propagated to the VSC side via the `ApplyChanges` method.</summary>
	public partial class FileSystemWatcherState {
		[JsonIgnore]
		internal FileSystemWatcher __holder__;

		/// <summary>
		/// true if this file system watcher has been created such that
		/// it ignores creation file system events.
		/// 
		/// </summary>
		[JsonProperty("ignoreCreateEvents"), JsonRequired]
		public bool IgnoreCreateEvents;

		/// <summary>
		/// true if this file system watcher has been created such that
		/// it ignores change file system events.
		/// 
		/// </summary>
		[JsonProperty("ignoreChangeEvents"), JsonRequired]
		public bool IgnoreChangeEvents;

		/// <summary>
		/// true if this file system watcher has been created such that
		/// it ignores delete file system events.
		/// 
		/// </summary>
		[JsonProperty("ignoreDeleteEvents"), JsonRequired]
		public bool IgnoreDeleteEvents;
	}

	internal partial class impl : IVscode, IWindow, IEnv, IClipboard, IWorkspace, ILanguages, IExtensions, ICommands {

		IWindow IVscode.Window { get {
			return this;
		} }

		IEnv IVscode.Env { get {
			return this;
		} }

		IWorkspace IVscode.Workspace { get {
			return this;
		} }

		ILanguages IVscode.Languages { get {
			return this;
		} }

		IExtensions IVscode.Extensions { get {
			return this;
		} }

		ICommands IVscode.Commands { get {
			return this;
		} }

		Action<Action<string>> IWindow.ShowInformationMessage(string message, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowWarningMessage(string message, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowErrorMessage(string message, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowInputBox(InputBoxOptions options, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInputBox";
			msg.Data = new dict(2);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.ValidateInput_AppzFuncId = "";
				Func<string, string> fn = default;
				fn = options.ValidateInput;
				if ((null != fn)) {
					lock (this) {
						options.ValidateInput_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.ValidateInput_AppzFuncId);
						this.Impl().cbOther[options.ValidateInput_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								string __0 = default;
								if ((null != args[0])) {
									(__0, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
									if (!ok) {
										return (null, false);
									}
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			if ((null != options)) {
				msg.Data["options"] = options;
			}
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return onresp(payload);
			});
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<QuickPickItem[]>> IWindow.ShowQuickPick(QuickPickItem[] items, QuickPickOptions options, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if (true) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.__loadFromJsonish__(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<QuickPickItem[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				QuickPickItem[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new QuickPickItem[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						QuickPickItem __val__result = default;
						__val__result = new QuickPickItem();
						ok = __val__result.__loadFromJsonish__(__item__result);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return onresp(payload);
			});
			return (Action<QuickPickItem[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IWindow.SetStatusBarMessage(string text, int hideAfterTimeout) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.setStatusBarMessage";
			msg.Data = new dict(2);
			msg.Data["text"] = text;
			msg.Data["hideAfterTimeout"] = hideAfterTimeout;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl()));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowSaveDialog(SaveDialogOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showSaveDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> IWindow.ShowOpenDialog(OpenDialogOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showOpenDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceFolder>> IWindow.ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWorkspaceFolderPick";
			msg.Data = new dict(1);
			if ((null != options)) {
				msg.Data["options"] = options;
			}
			Func<any, bool> onresp = default;
			Action<WorkspaceFolder> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceFolder result = default;
				if ((null != payload)) {
					result = new WorkspaceFolder();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceFolder> a0) => {
				onret = a0;
			};
		}

		Action<Action<WindowState>> IWindow.State() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.state";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<WindowState> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WindowState result = default;
				if ((null != payload)) {
					result = new WindowState();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WindowState> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IWindow.OnDidChangeWindowState(Action<WindowState> listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.onDidChangeWindowState";
			msg.Data = new dict(1);
			string listenerFnId = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IWindow.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			listenerFnId = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				WindowState _a_0_ = default;
				_a_0_ = new WindowState();
				ok = _a_0_.__loadFromJsonish__(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = listenerFnId;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), listenerFnId));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<StatusBarItem>> IWindow.CreateStatusBarItem(StatusBarAlignment? alignment, int? priority) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createStatusBarItem";
			msg.Data = new dict(2);
			if ((null != alignment)) {
				msg.Data["alignment"] = alignment;
			}
			if ((null != priority)) {
				msg.Data["priority"] = priority;
			}
			Func<any, bool> onresp = default;
			Action<StatusBarItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				StatusBarItem result = default;
				if ((null != payload)) {
					result = new StatusBarItem();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
					result.__disp__.impl = this.Impl();
				} else {
					return false;
				}
				result.__appzObjBagPullFromPeer__()(() => {
					if ((null != onret)) {
						onret(result);
					}
				});
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<StatusBarItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<OutputChannel>> IWindow.CreateOutputChannel(string name) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createOutputChannel";
			msg.Data = new dict(1);
			msg.Data["name"] = name;
			Func<any, bool> onresp = default;
			Action<OutputChannel> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				OutputChannel result = default;
				if ((null != payload)) {
					result = new OutputChannel();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
					result.__disp__.impl = this.Impl();
				} else {
					return false;
				}
				result.__appzObjBagPullFromPeer__()(() => {
					if ((null != onret)) {
						onret(result);
					}
				});
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<OutputChannel> a0) => {
				onret = a0;
			};
		}

		Action<Action<TextEditorDecorationType>> IWindow.CreateTextEditorDecorationType(DecorationRenderOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createTextEditorDecorationType";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> onresp = default;
			Action<TextEditorDecorationType> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				TextEditorDecorationType result = default;
				if ((null != payload)) {
					result = new TextEditorDecorationType();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
					result.__disp__.impl = this.Impl();
				} else {
					return false;
				}
				result.__appzObjBagPullFromPeer__()(() => {
					if ((null != onret)) {
						onret(result);
					}
				});
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<TextEditorDecorationType> a0) => {
				onret = a0;
			};
		}

		Action<Action<InputBox>> IWindow.CreateInputBox() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createInputBox";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<InputBox> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				InputBox result = default;
				if ((null != payload)) {
					result = new InputBox();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
					result.__disp__.impl = this.Impl();
				} else {
					return false;
				}
				result.__appzObjBagPullFromPeer__()(() => {
					if ((null != onret)) {
						onret(result);
					}
				});
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<InputBox> a0) => {
				onret = a0;
			};
		}

		Action<Action<QuickPick>> IWindow.CreateQuickPick() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createQuickPick";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<QuickPick> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				QuickPick result = default;
				if ((null != payload)) {
					result = new QuickPick();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
					result.__disp__.impl = this.Impl();
				} else {
					return false;
				}
				result.__appzObjBagPullFromPeer__()(() => {
					if ((null != onret)) {
						onret(result);
					}
				});
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<QuickPick> a0) => {
				onret = a0;
			};
		}

		Action<Action<Terminal>> IWindow.CreateTerminal(TerminalOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createTerminal";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> onresp = default;
			Action<Terminal> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Terminal result = default;
				if ((null != payload)) {
					result = new Terminal();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
					result.__disp__.impl = this.Impl();
				} else {
					return false;
				}
				result.__appzObjBagPullFromPeer__()(() => {
					if ((null != onret)) {
						onret(result);
					}
				});
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Terminal> a0) => {
				onret = a0;
			};
		}

		Action<Action<bool>> IEnv.OpenExternal(string target) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.openExternal";
			msg.Data = new dict(1);
			msg.Data["target"] = target;
			Func<any, bool> onresp = default;
			Action<bool> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				bool result = default;
				if ((null != payload)) {
					(result, ok) = (payload is bool) ? (((bool)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<bool> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.AppName() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.appName";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.AppRoot() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.appRoot";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.Language() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.language";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.MachineId() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.machineId";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.RemoteName() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.remoteName";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.SessionId() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.sessionId";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.Shell() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.shell";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.UriScheme() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.uriScheme";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<EnvState>> IEnv.AllProperties() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.AllProperties";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<EnvState> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				EnvState result = default;
				if ((null != payload)) {
					result = new EnvState();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<EnvState> a0) => {
				onret = a0;
			};
		}

		IClipboard IEnv.Clipboard() {
			return this;
		}

		Action<Action<string>> IClipboard.ReadText() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "clipboard.readText";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action> IClipboard.WriteText(string value) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "clipboard.writeText";
			msg.Data = new dict(1);
			msg.Data["value"] = value;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWorkspace.Name() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.name";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWorkspace.WorkspaceFile() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.workspaceFile";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<bool>> IWorkspace.SaveAll(bool includeUntitled) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.saveAll";
			msg.Data = new dict(1);
			msg.Data["includeUntitled"] = includeUntitled;
			Func<any, bool> onresp = default;
			Action<bool> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				bool result = default;
				if ((null != payload)) {
					(result, ok) = (payload is bool) ? (((bool)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<bool> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IWorkspace.OnDidChangeWorkspaceFolders(Action<WorkspaceFoldersChangeEvent> listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.onDidChangeWorkspaceFolders";
			msg.Data = new dict(1);
			string listenerFnId = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IWorkspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			listenerFnId = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				WorkspaceFoldersChangeEvent _a_0_ = default;
				_a_0_ = new WorkspaceFoldersChangeEvent();
				ok = _a_0_.__loadFromJsonish__(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = listenerFnId;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), listenerFnId));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceFolder>> IWorkspace.GetWorkspaceFolder(string uri) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.getWorkspaceFolder";
			msg.Data = new dict(1);
			msg.Data["uri"] = uri;
			Func<any, bool> onresp = default;
			Action<WorkspaceFolder> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceFolder result = default;
				if ((null != payload)) {
					result = new WorkspaceFolder();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceFolder> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceFolder[]>> IWorkspace.WorkspaceFolders() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.workspaceFolders";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<WorkspaceFolder[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceFolder[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new WorkspaceFolder[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						WorkspaceFolder __val__result = default;
						__val__result = new WorkspaceFolder();
						ok = __val__result.__loadFromJsonish__(__item__result);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceFolder[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> IWorkspace.FindFiles(string include, string exclude, int? maxResults, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.findFiles";
			msg.Data = new dict(4);
			msg.Data["include"] = include;
			if ((null != exclude)) {
				msg.Data["exclude"] = exclude;
			}
			if ((null != maxResults)) {
				msg.Data["maxResults"] = maxResults;
			}
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWorkspace.AsRelativePath(string pathOrUri, bool includeWorkspaceFolder) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.asRelativePath";
			msg.Data = new dict(2);
			msg.Data["pathOrUri"] = pathOrUri;
			msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<FileSystemWatcher>> IWorkspace.CreateFileSystemWatcher(string globPattern, bool ignoreCreateEvents, bool ignoreChangeEvents, bool ignoreDeleteEvents) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.createFileSystemWatcher";
			msg.Data = new dict(4);
			msg.Data["globPattern"] = globPattern;
			msg.Data["ignoreCreateEvents"] = ignoreCreateEvents;
			msg.Data["ignoreChangeEvents"] = ignoreChangeEvents;
			msg.Data["ignoreDeleteEvents"] = ignoreDeleteEvents;
			Func<any, bool> onresp = default;
			Action<FileSystemWatcher> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				FileSystemWatcher result = default;
				if ((null != payload)) {
					result = new FileSystemWatcher();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
					result.__disp__.impl = this.Impl();
				} else {
					return false;
				}
				result.__appzObjBagPullFromPeer__()(() => {
					if ((null != onret)) {
						onret(result);
					}
				});
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<FileSystemWatcher> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceState>> IWorkspace.AllProperties() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.AllProperties";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<WorkspaceState> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceState result = default;
				if ((null != payload)) {
					result = new WorkspaceState();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceState> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> ILanguages.GetLanguages() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "languages.getLanguages";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> ILanguages.OnDidChangeDiagnostics(Action<DiagnosticChangeEvent> listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "languages.onDidChangeDiagnostics";
			msg.Data = new dict(1);
			string listenerFnId = default;
			if ((null == listener)) {
				OnError(this.Impl(), "ILanguages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			listenerFnId = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				DiagnosticChangeEvent _a_0_ = default;
				_a_0_ = new DiagnosticChangeEvent();
				ok = _a_0_.__loadFromJsonish__(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = listenerFnId;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), listenerFnId));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IExtensions.OnDidChange(Action listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "extensions.onDidChange";
			msg.Data = new dict(1);
			string listenerFnId = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IExtensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			listenerFnId = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (0 != args.Length) {
					return ok;
				}
				listener();
				return true;
			}, null);
			msg.Data["listener"] = listenerFnId;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), listenerFnId));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> ICommands.RegisterCommand(string command, Func<any[], any> callback) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.registerCommand";
			msg.Data = new dict(2);
			msg.Data["command"] = command;
			string callbackFnId = default;
			if ((null == callback)) {
				OnError(this.Impl(), "ICommands.RegisterCommand: the 'callback' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			callbackFnId = this.Impl().nextSub(null, (any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return (null, ok);
				}
				any ret = default;
				any[] _a_0_ = default;
				(_a_0_, ok) = (args[0] is any[]) ? (((any[])(args[0])), true) : (default, false);
				if (!ok) {
					return (null, false);
				}
				ret = callback(_a_0_);
				return (ret, true);
			});
			msg.Data["callback"] = callbackFnId;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), callbackFnId));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<any>> ICommands.ExecuteCommand(string command, any[] rest) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.executeCommand";
			msg.Data = new dict(2);
			msg.Data["command"] = command;
			msg.Data["rest"] = rest;
			Func<any, bool> onresp = default;
			Action<any> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				any result = default;
				if ((null != payload)) {
					(result, ok) = (payload, true);
					if (ok) {
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<any> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> ICommands.GetCommands(bool filterInternal) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.getCommands";
			msg.Data = new dict(1);
			msg.Data["filterInternal"] = filterInternal;
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

	}

	public partial class StatusBarItem {
		/// <summary>
		/// Shows the entry in the status bar.
		/// 
		/// `return` ── a thenable that resolves when this `Show` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Show() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.show";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class StatusBarItem {
		/// <summary>
		/// Hide the entry in the status bar.
		/// 
		/// `return` ── a thenable that resolves when this `Hide` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Hide() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.hide";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class StatusBarItem /*: IDisposable*/ {
		/// <summary>
		/// Dispose and free associated resources. Call
		/// [hide](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.hide).
		/// 
		/// `return` ── a thenable that resolves when this `Dispose` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Dispose() {
			return this.__disp__.Dispose();
		}
		/*void IDisposable.Dispose() { this.Dispose(); }*/
		internal Action<IVscode, any, any> OnError { get => this.__disp__?.impl?.OnError; }
	}

	public partial class StatusBarItem {
		internal Action<Action> __appzObjBagPullFromPeer__() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.__appzObjBagPullFromPeer__";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				if ((null == this.Cfg)) {
					this.Cfg = new StatusBarItemState();
				}
				this.Cfg.__holder__ = this;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class StatusBarItem {
		internal Action<Action> __appzObjBagPushToPeer__(StatusBarItemState allUpdates = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.__appzObjBagPushToPeer__";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["allUpdates"] = allUpdates;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Append the given value to the channel.
		/// 
		/// `value` ── A string, falsy values will not be printed.
		/// 
		/// `return` ── a thenable that resolves when this `Append` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		/// <param name="value">A string, falsy values will not be printed.</param>
		/// <return>a thenable that resolves when this `Append` call has successfully completed at the VSC side.</return>
		public Action<Action> Append(string value = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.append";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["value"] = value;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Append the given value and a line feed character
		/// to the channel.
		/// 
		/// `value` ── A string, falsy values will be printed.
		/// 
		/// `return` ── a thenable that resolves when this `AppendLine` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		/// <param name="value">A string, falsy values will be printed.</param>
		/// <return>a thenable that resolves when this `AppendLine` call has successfully completed at the VSC side.</return>
		public Action<Action> AppendLine(string value = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.appendLine";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["value"] = value;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Removes all output from the channel.
		/// 
		/// `return` ── a thenable that resolves when this `Clear` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Clear() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.clear";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Reveal this channel in the UI.
		/// 
		/// `preserveFocus` ── When `true` the channel will not take focus.
		/// 
		/// `return` ── a thenable that resolves when this `Show` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		/// <param name="preserveFocus">When `true` the channel will not take focus.</param>
		/// <return>a thenable that resolves when this `Show` call has successfully completed at the VSC side.</return>
		public Action<Action> Show(bool preserveFocus = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.show";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["preserveFocus"] = preserveFocus;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Hide this channel from the UI.
		/// 
		/// `return` ── a thenable that resolves when this `Hide` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Hide() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.hide";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel /*: IDisposable*/ {
		/// <summary>
		/// Dispose and free associated resources.
		/// 
		/// `return` ── a thenable that resolves when this `Dispose` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Dispose() {
			return this.__disp__.Dispose();
		}
		/*void IDisposable.Dispose() { this.Dispose(); }*/
		internal Action<IVscode, any, any> OnError { get => this.__disp__?.impl?.OnError; }
	}

	public partial class OutputChannel {
		internal Action<Action> __appzObjBagPullFromPeer__() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.__appzObjBagPullFromPeer__";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				if ((null == this.Cfg)) {
					this.Cfg = new OutputChannelState();
				}
				this.Cfg.__holder__ = this;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class TextEditorDecorationType /*: IDisposable*/ {
		/// <summary>
		/// Remove this decoration type and all decorations on all text editors using it.
		/// 
		/// `return` ── a thenable that resolves when this `Dispose` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Dispose() {
			return this.__disp__.Dispose();
		}
		/*void IDisposable.Dispose() { this.Dispose(); }*/
		internal Action<IVscode, any, any> OnError { get => this.__disp__?.impl?.OnError; }
	}

	public partial class TextEditorDecorationType {
		internal Action<Action> __appzObjBagPullFromPeer__() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "TextEditorDecorationType.__appzObjBagPullFromPeer__";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				if ((null == this.Cfg)) {
					this.Cfg = new TextEditorDecorationTypeState();
				}
				this.Cfg.__holder__ = this;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class InputBox {
		/// <summary>
		/// An event signaling when the value has changed.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidChangeValue` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeValue` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidChangeValue` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidChangeValue` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidChangeValue(Action<string> handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "InputBox.onDidChangeValue";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "InputBox.OnDidChangeValue: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (2 != args.Length) {
					return ok;
				}
				string _a_0_ = default;
				(_a_0_, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
				if (!ok) {
					return false;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[1]);
					}
					if (!ok) {
						return false;
					}
					handler(_a_0_);
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class InputBox {
		/// <summary>
		/// An event signaling when the user indicated acceptance of the input value.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidAccept` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidAccept` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidAccept` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidAccept` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidAccept(Action handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "InputBox.onDidAccept";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "InputBox.OnDidAccept: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[0]);
					}
					if (!ok) {
						return false;
					}
					handler();
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class InputBox {
		/// <summary>
		/// Makes the input UI visible in its current configuration. Any other input
		/// UI will first fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide) event.
		/// 
		/// `return` ── a thenable that resolves when this `Show` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Show() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "InputBox.show";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class InputBox {
		/// <summary>
		/// Hides this input UI. This will also fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide)
		/// event.
		/// 
		/// `return` ── a thenable that resolves when this `Hide` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Hide() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "InputBox.hide";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class InputBox {
		/// <summary>
		/// An event signaling when this input UI is hidden.
		/// 
		/// There are several reasons why this UI might have to be hidden and
		/// the extension will be notified through [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide).
		/// (Examples include: an explicit call to [QuickInput.hide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.hide),
		/// the user pressing Esc, some other input UI opening, etc.)
		/// 
		/// `handler` ── will be invoked whenever the `OnDidHide` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidHide` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidHide` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidHide` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidHide(Action handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "InputBox.onDidHide";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "InputBox.OnDidHide: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[0]);
					}
					if (!ok) {
						return false;
					}
					handler();
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class InputBox /*: IDisposable*/ {
		/// <summary>
		/// Dispose of this input UI and any associated resources. If it is still
		/// visible, it is first hidden. After this call the input UI is no longer
		/// functional and no additional methods or properties on it should be
		/// accessed. Instead a new input UI should be created.
		/// 
		/// `return` ── a thenable that resolves when this `Dispose` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Dispose() {
			return this.__disp__.Dispose();
		}
		/*void IDisposable.Dispose() { this.Dispose(); }*/
		internal Action<IVscode, any, any> OnError { get => this.__disp__?.impl?.OnError; }
	}

	public partial class InputBox {
		internal Action<Action> __appzObjBagPullFromPeer__() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "InputBox.__appzObjBagPullFromPeer__";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				if ((null == this.Cfg)) {
					this.Cfg = new InputBoxState();
				}
				this.Cfg.__holder__ = this;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class InputBox {
		internal Action<Action> __appzObjBagPushToPeer__(InputBoxState allUpdates = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "InputBox.__appzObjBagPushToPeer__";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["allUpdates"] = allUpdates;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		/// <summary>
		/// An event signaling when the value of the filter text has changed.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidChangeValue` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeValue` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidChangeValue` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidChangeValue` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidChangeValue(Action<string> handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.onDidChangeValue";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "QuickPick.OnDidChangeValue: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (2 != args.Length) {
					return ok;
				}
				string _a_0_ = default;
				(_a_0_, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
				if (!ok) {
					return false;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[1]);
					}
					if (!ok) {
						return false;
					}
					handler(_a_0_);
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		/// <summary>
		/// An event signaling when the user indicated acceptance of the selected item(s).
		/// 
		/// `handler` ── will be invoked whenever the `OnDidAccept` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidAccept` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidAccept` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidAccept` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidAccept(Action handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.onDidAccept";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "QuickPick.OnDidAccept: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[0]);
					}
					if (!ok) {
						return false;
					}
					handler();
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		/// <summary>
		/// An event signaling when the active items have changed.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidChangeActive` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeActive` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidChangeActive` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidChangeActive` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidChangeActive(Action<QuickPickItem[]> handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.onDidChangeActive";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "QuickPick.OnDidChangeActive: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (2 != args.Length) {
					return ok;
				}
				QuickPickItem[] _a_0_ = default;
				any[] __coll___a_0_ = default;
				(__coll___a_0_, ok) = (args[0] is any[]) ? (((any[])(args[0])), true) : (default, false);
				if (!ok) {
					return false;
				}
				_a_0_ = new QuickPickItem[__coll___a_0_.Length];
				int __idx___a_0_ = default;
				__idx___a_0_ = 0;
				foreach (var __item___a_0_ in __coll___a_0_) {
					QuickPickItem __val___a_0_ = default;
					__val___a_0_ = new QuickPickItem();
					ok = __val___a_0_.__loadFromJsonish__(__item___a_0_);
					if (!ok) {
						return false;
					}
					_a_0_[__idx___a_0_] = __val___a_0_;
					__idx___a_0_ = __idx___a_0_ + 1;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[1]);
					}
					if (!ok) {
						return false;
					}
					handler(_a_0_);
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		/// <summary>
		/// An event signaling when the selected items have changed.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidChangeSelection` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeSelection` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidChangeSelection` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidChangeSelection` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidChangeSelection(Action<QuickPickItem[]> handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.onDidChangeSelection";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "QuickPick.OnDidChangeSelection: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (2 != args.Length) {
					return ok;
				}
				QuickPickItem[] _a_0_ = default;
				any[] __coll___a_0_ = default;
				(__coll___a_0_, ok) = (args[0] is any[]) ? (((any[])(args[0])), true) : (default, false);
				if (!ok) {
					return false;
				}
				_a_0_ = new QuickPickItem[__coll___a_0_.Length];
				int __idx___a_0_ = default;
				__idx___a_0_ = 0;
				foreach (var __item___a_0_ in __coll___a_0_) {
					QuickPickItem __val___a_0_ = default;
					__val___a_0_ = new QuickPickItem();
					ok = __val___a_0_.__loadFromJsonish__(__item___a_0_);
					if (!ok) {
						return false;
					}
					_a_0_[__idx___a_0_] = __val___a_0_;
					__idx___a_0_ = __idx___a_0_ + 1;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[1]);
					}
					if (!ok) {
						return false;
					}
					handler(_a_0_);
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		/// <summary>
		/// Makes the input UI visible in its current configuration. Any other input
		/// UI will first fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide) event.
		/// 
		/// `return` ── a thenable that resolves when this `Show` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Show() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.show";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		/// <summary>
		/// Hides this input UI. This will also fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide)
		/// event.
		/// 
		/// `return` ── a thenable that resolves when this `Hide` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Hide() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.hide";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		/// <summary>
		/// An event signaling when this input UI is hidden.
		/// 
		/// There are several reasons why this UI might have to be hidden and
		/// the extension will be notified through [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide).
		/// (Examples include: an explicit call to [QuickInput.hide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.hide),
		/// the user pressing Esc, some other input UI opening, etc.)
		/// 
		/// `handler` ── will be invoked whenever the `OnDidHide` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidHide` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidHide` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidHide` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidHide(Action handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.onDidHide";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "QuickPick.OnDidHide: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[0]);
					}
					if (!ok) {
						return false;
					}
					handler();
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick /*: IDisposable*/ {
		/// <summary>
		/// Dispose of this input UI and any associated resources. If it is still
		/// visible, it is first hidden. After this call the input UI is no longer
		/// functional and no additional methods or properties on it should be
		/// accessed. Instead a new input UI should be created.
		/// 
		/// `return` ── a thenable that resolves when this `Dispose` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Dispose() {
			return this.__disp__.Dispose();
		}
		/*void IDisposable.Dispose() { this.Dispose(); }*/
		internal Action<IVscode, any, any> OnError { get => this.__disp__?.impl?.OnError; }
	}

	public partial class QuickPick {
		internal Action<Action> __appzObjBagPullFromPeer__() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.__appzObjBagPullFromPeer__";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				if ((null == this.Cfg)) {
					this.Cfg = new QuickPickState();
				}
				this.Cfg.__holder__ = this;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class QuickPick {
		internal Action<Action> __appzObjBagPushToPeer__(QuickPickState allUpdates = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "QuickPick.__appzObjBagPushToPeer__";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["allUpdates"] = allUpdates;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class Terminal {
		/// <summary>
		/// Send text to the terminal. The text is written to the stdin of the underlying pty process
		/// (shell) of the terminal.
		/// 
		/// `text` ── The text to send.
		/// 
		/// `addNewLine` ── Whether to add a new line to the text being sent, this is normally
		/// required to run a command in the terminal. The character(s) added are \n or \r\n
		/// depending on the platform. This defaults to `true`.
		/// 
		/// `return` ── a thenable that resolves when this `SendText` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		/// <param name="text">The text to send.</param>
		/// <param name="addNewLine">Whether to add a new line to the text being sent, this is normally required to run a command in the terminal. The character(s) added are \n or \r\n depending on the platform. This defaults to `true`.</param>
		/// <return>a thenable that resolves when this `SendText` call has successfully completed at the VSC side.</return>
		public Action<Action> SendText(string text = default, bool addNewLine = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "Terminal.sendText";
			msg.Data = new dict(3);
			msg.Data[""] = this.__disp__.id;
			msg.Data["text"] = text;
			msg.Data["addNewLine"] = addNewLine;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class Terminal {
		/// <summary>
		/// Show the terminal panel and reveal this terminal in the UI.
		/// 
		/// `preserveFocus` ── When `true` the terminal will not take focus.
		/// 
		/// `return` ── a thenable that resolves when this `Show` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		/// <param name="preserveFocus">When `true` the terminal will not take focus.</param>
		/// <return>a thenable that resolves when this `Show` call has successfully completed at the VSC side.</return>
		public Action<Action> Show(bool preserveFocus = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "Terminal.show";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["preserveFocus"] = preserveFocus;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class Terminal {
		/// <summary>
		/// Hide the terminal panel if this terminal is currently showing.
		/// 
		/// `return` ── a thenable that resolves when this `Hide` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Hide() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "Terminal.hide";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				any[] it = default;
				bool ok = default;
				(it, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
				if (!ok) {
					return false;
				}
				if ((2 != it.Length) || (null == it[1])) {
					return false;
				}
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(it[1]);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class Terminal /*: IDisposable*/ {
		/// <summary>
		/// Dispose and free associated resources.
		/// 
		/// `return` ── a thenable that resolves when this `Dispose` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Dispose() {
			return this.__disp__.Dispose();
		}
		/*void IDisposable.Dispose() { this.Dispose(); }*/
		internal Action<IVscode, any, any> OnError { get => this.__disp__?.impl?.OnError; }
	}

	public partial class Terminal {
		internal Action<Action> __appzObjBagPullFromPeer__() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "Terminal.__appzObjBagPullFromPeer__";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				if ((null == this.Cfg)) {
					this.Cfg = new TerminalState();
				}
				this.Cfg.__holder__ = this;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class FileSystemWatcher {
		/// <summary>
		/// An event which fires on file/folder creation.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidCreate` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidCreate` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidCreate` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidCreate` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidCreate(Action<string> handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "FileSystemWatcher.onDidCreate";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "FileSystemWatcher.OnDidCreate: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (2 != args.Length) {
					return ok;
				}
				string _a_0_ = default;
				(_a_0_, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
				if (!ok) {
					return false;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[1]);
					}
					if (!ok) {
						return false;
					}
					handler(_a_0_);
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class FileSystemWatcher {
		/// <summary>
		/// An event which fires on file/folder change.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidChange` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChange` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidChange` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidChange` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidChange(Action<string> handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "FileSystemWatcher.onDidChange";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "FileSystemWatcher.OnDidChange: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (2 != args.Length) {
					return ok;
				}
				string _a_0_ = default;
				(_a_0_, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
				if (!ok) {
					return false;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[1]);
					}
					if (!ok) {
						return false;
					}
					handler(_a_0_);
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class FileSystemWatcher {
		/// <summary>
		/// An event which fires on file/folder deletion.
		/// 
		/// `handler` ── will be invoked whenever the `OnDidDelete` event fires (mandatory, not optional).
		/// 
		/// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidDelete` event on `Dispose`.
		/// 
		/// </summary>
		/// <param name="handler">will be invoked whenever the `OnDidDelete` event fires (mandatory, not optional).</param>
		/// <return>A `Disposable` that will unsubscribe `handler` from the `OnDidDelete` event on `Dispose`.</return>
		public Action<Action<Disposable>> OnDidDelete(Action<string> handler = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "FileSystemWatcher.onDidDelete";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			string handlerFnId = default;
			if ((null == handler)) {
				OnError(this.__disp__.impl, "FileSystemWatcher.OnDidDelete: the 'handler' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			handlerFnId = this.__disp__.impl.nextSub((any[] args) => {
				bool ok = default;
				if (2 != args.Length) {
					return ok;
				}
				string _a_0_ = default;
				(_a_0_, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
				if (!ok) {
					return false;
				}
				{
					lock (this.Cfg) {
						ok = this.Cfg.__loadFromJsonish__(args[1]);
					}
					if (!ok) {
						return false;
					}
					handler(_a_0_);
				}
				return true;
			}, null);
			msg.Data["handler"] = handlerFnId;
			this.__disp__.addSub(handlerFnId);
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.__loadFromJsonish__(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.__disp__.impl, handlerFnId));
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}
	}

	public partial class FileSystemWatcher /*: IDisposable*/ {
		/// <summary>
		/// Dispose requests the VSC side to forget about this object and release or destroy all resources associated with or occupied by it. All subsequent usage attempts will be rejected.
		/// 
		/// `return` ── a thenable that resolves when this `Dispose` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> Dispose() {
			return this.__disp__.Dispose();
		}
		/*void IDisposable.Dispose() { this.Dispose(); }*/
		internal Action<IVscode, any, any> OnError { get => this.__disp__?.impl?.OnError; }
	}

	public partial class FileSystemWatcher {
		internal Action<Action> __appzObjBagPullFromPeer__() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "FileSystemWatcher.__appzObjBagPullFromPeer__";
			msg.Data = new dict(1);
			msg.Data[""] = this.__disp__.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				if ((null == this.Cfg)) {
					this.Cfg = new FileSystemWatcherState();
				}
				this.Cfg.__holder__ = this;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class FileSystemWatcher {
		internal Action<Action> __appzObjBagPushToPeer__(FileSystemWatcherState allUpdates = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "FileSystemWatcher.__appzObjBagPushToPeer__";
			msg.Data = new dict(2);
			msg.Data[""] = this.__disp__.id;
			msg.Data["allUpdates"] = allUpdates;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				bool ok = default;
				lock (this.Cfg) {
					ok = this.Cfg.__loadFromJsonish__(payload);
				}
				if (!ok) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.__disp__.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class StatusBarItemState {
		/// <summary>
		/// ReFetch requests the current `StatusBarItem` state from the VSC side and upon response refreshes this `StatusBarItemState`'s property values for `alignment`, `priority`, `text`, `tooltip`, `color`, `command` to reflect it.
		/// 
		/// `return` ── a thenable that resolves when this `ReFetch` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ReFetch() {
			return this.__holder__.__appzObjBagPullFromPeer__();
		}
	}

	public partial class StatusBarItemState {
		/// <summary>
		/// ApplyChanges propagates this `StatusBarItemState`'s current property values for `text`, `tooltip`, `color`, `command` to the VSC side to immediately become active there. Note that **all** those property values are transmitted, no omissions.
		/// 
		/// `return` ── a thenable that resolves when this `ApplyChanges` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ApplyChanges() {
			Action<Action> ret = default;
			lock (this) {
				ret = this.__holder__.__appzObjBagPushToPeer__(this);
			}
			return ret;
		}
	}

	public partial class OutputChannelState {
		/// <summary>
		/// ReFetch requests the current `OutputChannel` state from the VSC side and upon response refreshes this `OutputChannelState`'s property value for `name` to reflect it.
		/// 
		/// `return` ── a thenable that resolves when this `ReFetch` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ReFetch() {
			return this.__holder__.__appzObjBagPullFromPeer__();
		}
	}

	public partial class TextEditorDecorationTypeState {
		/// <summary>
		/// ReFetch requests the current `TextEditorDecorationType` state from the VSC side and upon response refreshes this `TextEditorDecorationTypeState`'s property value for `key` to reflect it.
		/// 
		/// `return` ── a thenable that resolves when this `ReFetch` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ReFetch() {
			return this.__holder__.__appzObjBagPullFromPeer__();
		}
	}

	public partial class InputBoxState {
		/// <summary>
		/// ReFetch requests the current `InputBox` state from the VSC side and upon response refreshes this `InputBoxState`'s property values for `value`, `placeholder`, `password`, `prompt`, `validationMessage`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut` to reflect it.
		/// 
		/// `return` ── a thenable that resolves when this `ReFetch` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ReFetch() {
			return this.__holder__.__appzObjBagPullFromPeer__();
		}
	}

	public partial class InputBoxState {
		/// <summary>
		/// ApplyChanges propagates this `InputBoxState`'s current property values for `value`, `placeholder`, `password`, `prompt`, `validationMessage`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut` to the VSC side to immediately become active there. Note that **all** those property values are transmitted, no omissions.
		/// 
		/// `return` ── a thenable that resolves when this `ApplyChanges` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ApplyChanges() {
			Action<Action> ret = default;
			lock (this) {
				ret = this.__holder__.__appzObjBagPushToPeer__(this);
			}
			return ret;
		}
	}

	public partial class QuickPickState {
		/// <summary>
		/// ReFetch requests the current `QuickPick` state from the VSC side and upon response refreshes this `QuickPickState`'s property values for `value`, `placeholder`, `items`, `canSelectMany`, `matchOnDescription`, `matchOnDetail`, `activeItems`, `selectedItems`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut` to reflect it.
		/// 
		/// `return` ── a thenable that resolves when this `ReFetch` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ReFetch() {
			return this.__holder__.__appzObjBagPullFromPeer__();
		}
	}

	public partial class QuickPickState {
		/// <summary>
		/// ApplyChanges propagates this `QuickPickState`'s current property values for `value`, `placeholder`, `items`, `canSelectMany`, `matchOnDescription`, `matchOnDetail`, `activeItems`, `selectedItems`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut` to the VSC side to immediately become active there. Note that **all** those property values are transmitted, no omissions.
		/// 
		/// `return` ── a thenable that resolves when this `ApplyChanges` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ApplyChanges() {
			Action<Action> ret = default;
			lock (this) {
				ret = this.__holder__.__appzObjBagPushToPeer__(this);
			}
			return ret;
		}
	}

	public partial class TerminalState {
		/// <summary>
		/// ReFetch requests the current `Terminal` state from the VSC side and upon response refreshes this `TerminalState`'s property value for `name` to reflect it.
		/// 
		/// `return` ── a thenable that resolves when this `ReFetch` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ReFetch() {
			return this.__holder__.__appzObjBagPullFromPeer__();
		}
	}

	public partial class FileSystemWatcherState {
		/// <summary>
		/// ReFetch requests the current `FileSystemWatcher` state from the VSC side and upon response refreshes this `FileSystemWatcherState`'s property values for `ignoreCreateEvents`, `ignoreChangeEvents`, `ignoreDeleteEvents` to reflect it.
		/// 
		/// `return` ── a thenable that resolves when this `ReFetch` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ReFetch() {
			return this.__holder__.__appzObjBagPullFromPeer__();
		}
	}

	public partial class FileSystemWatcherState {
		/// <summary>
		/// ApplyChanges propagates this `FileSystemWatcherState`'s current property values for `ignoreCreateEvents`, `ignoreChangeEvents`, `ignoreDeleteEvents` to the VSC side to immediately become active there. Note that **all** those property values are transmitted, no omissions.
		/// 
		/// `return` ── a thenable that resolves when this `ApplyChanges` call has successfully completed at the VSC side.
		/// 
		/// </summary>
		public Action<Action> ApplyChanges() {
			Action<Action> ret = default;
			lock (this) {
				ret = this.__holder__.__appzObjBagPushToPeer__(this);
			}
			return ret;
		}
	}

	public partial class QuickPickItem {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("label", out var __) ? (__, true) : (default, false));
			if (ok) {
				string label = default;
				if ((null != val)) {
					(label, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Label = label;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("description", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string description = default;
				if ((null != val)) {
					string _description_ = default;
					(_description_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					description = _description_;
				}
				this.Description = description;
			}
			(val, ok) = (it.TryGetValue("detail", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string detail = default;
				if ((null != val)) {
					string _detail_ = default;
					(_detail_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					detail = _detail_;
				}
				this.Detail = detail;
			}
			(val, ok) = (it.TryGetValue("picked", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				bool picked = default;
				if ((null != val)) {
					(picked, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Picked = picked;
			}
			(val, ok) = (it.TryGetValue("alwaysShow", out var ______) ? (______, true) : (default, false));
			if (ok) {
				bool alwaysShow = default;
				if ((null != val)) {
					(alwaysShow, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.AlwaysShow = alwaysShow;
			}
			(val, ok) = (it.TryGetValue("my", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				dict my = default;
				if ((null != val)) {
					(my, ok) = (val is dict) ? (((dict)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.My = my;
			}
			return true;
		}
	}

	public partial class WorkspaceFolder {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("uri", out var __) ? (__, true) : (default, false));
			if (ok) {
				string uri = default;
				if ((null != val)) {
					(uri, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Uri = uri;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					(name, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Name = name;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("index", out var ____) ? (____, true) : (default, false));
			if (ok) {
				int index = default;
				if ((null != val)) {
					(index, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						double __index__ = default;
						(__index__, ok) = (val is double) ? (((double)(val)), true) : (default, false);
						if (!ok) {
							return false;
						}
						index = ((int)(__index__));
					}
				}
				this.Index = index;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class WindowState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("focused", out var __) ? (__, true) : (default, false));
			if (ok) {
				bool focused = default;
				if ((null != val)) {
					(focused, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Focused = focused;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class StatusBarItem {
		internal bool __loadFromJsonish__(any payload = default) {
			bool ok = default;
			this.__disp__ = new Disposable();
			ok = this.__disp__.__loadFromJsonish__(payload);
			return ok;
		}
	}

	public partial class OutputChannel {
		internal bool __loadFromJsonish__(any payload = default) {
			bool ok = default;
			this.__disp__ = new Disposable();
			ok = this.__disp__.__loadFromJsonish__(payload);
			return ok;
		}
	}

	public partial class TextEditorDecorationType {
		internal bool __loadFromJsonish__(any payload = default) {
			bool ok = default;
			this.__disp__ = new Disposable();
			ok = this.__disp__.__loadFromJsonish__(payload);
			return ok;
		}
	}

	public partial class InputBox {
		internal bool __loadFromJsonish__(any payload = default) {
			bool ok = default;
			this.__disp__ = new Disposable();
			ok = this.__disp__.__loadFromJsonish__(payload);
			return ok;
		}
	}

	public partial class QuickPick {
		internal bool __loadFromJsonish__(any payload = default) {
			bool ok = default;
			this.__disp__ = new Disposable();
			ok = this.__disp__.__loadFromJsonish__(payload);
			return ok;
		}
	}

	public partial class Terminal {
		internal bool __loadFromJsonish__(any payload = default) {
			bool ok = default;
			this.__disp__ = new Disposable();
			ok = this.__disp__.__loadFromJsonish__(payload);
			return ok;
		}
	}

	public partial class EnvState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("appName", out var __) ? (__, true) : (default, false));
			if (ok) {
				string appName = default;
				if ((null != val)) {
					string _appName_ = default;
					(_appName_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					appName = _appName_;
				}
				this.AppName = appName;
			}
			(val, ok) = (it.TryGetValue("appRoot", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string appRoot = default;
				if ((null != val)) {
					string _appRoot_ = default;
					(_appRoot_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					appRoot = _appRoot_;
				}
				this.AppRoot = appRoot;
			}
			(val, ok) = (it.TryGetValue("language", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string language = default;
				if ((null != val)) {
					string _language_ = default;
					(_language_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					language = _language_;
				}
				this.Language = language;
			}
			(val, ok) = (it.TryGetValue("machineId", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				string machineId = default;
				if ((null != val)) {
					string _machineId_ = default;
					(_machineId_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					machineId = _machineId_;
				}
				this.MachineId = machineId;
			}
			(val, ok) = (it.TryGetValue("remoteName", out var ______) ? (______, true) : (default, false));
			if (ok) {
				string remoteName = default;
				if ((null != val)) {
					string _remoteName_ = default;
					(_remoteName_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					remoteName = _remoteName_;
				}
				this.RemoteName = remoteName;
			}
			(val, ok) = (it.TryGetValue("sessionId", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				string sessionId = default;
				if ((null != val)) {
					string _sessionId_ = default;
					(_sessionId_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					sessionId = _sessionId_;
				}
				this.SessionId = sessionId;
			}
			(val, ok) = (it.TryGetValue("shell", out var ________) ? (________, true) : (default, false));
			if (ok) {
				string shell = default;
				if ((null != val)) {
					string _shell_ = default;
					(_shell_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					shell = _shell_;
				}
				this.Shell = shell;
			}
			(val, ok) = (it.TryGetValue("uriScheme", out var _________) ? (_________, true) : (default, false));
			if (ok) {
				string uriScheme = default;
				if ((null != val)) {
					string _uriScheme_ = default;
					(_uriScheme_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					uriScheme = _uriScheme_;
				}
				this.UriScheme = uriScheme;
			}
			return true;
		}
	}

	public partial class WorkspaceFoldersChangeEvent {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("added", out var __) ? (__, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] added = default;
				if ((null != val)) {
					any[] __coll__added = default;
					(__coll__added, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					added = new WorkspaceFolder[__coll__added.Length];
					int __idx__added = default;
					__idx__added = 0;
					foreach (var __item__added in __coll__added) {
						WorkspaceFolder __val__added = default;
						__val__added = new WorkspaceFolder();
						ok = __val__added.__loadFromJsonish__(__item__added);
						if (!ok) {
							return false;
						}
						added[__idx__added] = __val__added;
						__idx__added = __idx__added + 1;
					}
				}
				this.Added = added;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("removed", out var ___) ? (___, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] removed = default;
				if ((null != val)) {
					any[] __coll__removed = default;
					(__coll__removed, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					removed = new WorkspaceFolder[__coll__removed.Length];
					int __idx__removed = default;
					__idx__removed = 0;
					foreach (var __item__removed in __coll__removed) {
						WorkspaceFolder __val__removed = default;
						__val__removed = new WorkspaceFolder();
						ok = __val__removed.__loadFromJsonish__(__item__removed);
						if (!ok) {
							return false;
						}
						removed[__idx__removed] = __val__removed;
						__idx__removed = __idx__removed + 1;
					}
				}
				this.Removed = removed;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class FileSystemWatcher {
		internal bool __loadFromJsonish__(any payload = default) {
			bool ok = default;
			this.__disp__ = new Disposable();
			ok = this.__disp__.__loadFromJsonish__(payload);
			return ok;
		}
	}

	public partial class WorkspaceState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var __) ? (__, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					string _name_ = default;
					(_name_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					name = _name_;
				}
				this.Name = name;
			}
			(val, ok) = (it.TryGetValue("workspaceFile", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string workspaceFile = default;
				if ((null != val)) {
					string _workspaceFile_ = default;
					(_workspaceFile_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					workspaceFile = _workspaceFile_;
				}
				this.WorkspaceFile = workspaceFile;
			}
			(val, ok) = (it.TryGetValue("workspaceFolders", out var ____) ? (____, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] workspaceFolders = default;
				if ((null != val)) {
					any[] __coll__workspaceFolders = default;
					(__coll__workspaceFolders, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					workspaceFolders = new WorkspaceFolder[__coll__workspaceFolders.Length];
					int __idx__workspaceFolders = default;
					__idx__workspaceFolders = 0;
					foreach (var __item__workspaceFolders in __coll__workspaceFolders) {
						WorkspaceFolder __val__workspaceFolders = default;
						__val__workspaceFolders = new WorkspaceFolder();
						ok = __val__workspaceFolders.__loadFromJsonish__(__item__workspaceFolders);
						if (!ok) {
							return false;
						}
						workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders;
						__idx__workspaceFolders = __idx__workspaceFolders + 1;
					}
				}
				this.WorkspaceFolders = workspaceFolders;
			}
			return true;
		}
	}

	public partial class DiagnosticChangeEvent {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("uris", out var __) ? (__, true) : (default, false));
			if (ok) {
				string[] uris = default;
				if ((null != val)) {
					any[] __coll__uris = default;
					(__coll__uris, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					uris = new string[__coll__uris.Length];
					int __idx__uris = default;
					__idx__uris = 0;
					foreach (var __item__uris in __coll__uris) {
						string __val__uris = default;
						(__val__uris, ok) = (__item__uris is string) ? (((string)(__item__uris)), true) : (default, false);
						if (!ok) {
							return false;
						}
						uris[__idx__uris] = __val__uris;
						__idx__uris = __idx__uris + 1;
					}
				}
				this.Uris = uris;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class StatusBarItemState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("alignment", out var __) ? (__, true) : (default, false));
			if (ok) {
				StatusBarAlignment alignment = default;
				if ((null != val)) {
					int i_alignment = default;
					(i_alignment, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						double __i_alignment__ = default;
						(__i_alignment__, ok) = (val is double) ? (((double)(val)), true) : (default, false);
						if (!ok) {
							return false;
						}
						i_alignment = ((int)(__i_alignment__));
					}
					alignment = ((StatusBarAlignment)(i_alignment));
				}
				this.Alignment = () => {
					return alignment;
				};
			}
			(val, ok) = (it.TryGetValue("priority", out var ___) ? (___, true) : (default, false));
			if (ok) {
				int priority = default;
				if ((null != val)) {
					(priority, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						double __priority__ = default;
						(__priority__, ok) = (val is double) ? (((double)(val)), true) : (default, false);
						if (!ok) {
							return false;
						}
						priority = ((int)(__priority__));
					}
				}
				this.Priority = () => {
					return priority;
				};
			}
			(val, ok) = (it.TryGetValue("text", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string text = default;
				if ((null != val)) {
					(text, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Text = text;
			}
			(val, ok) = (it.TryGetValue("tooltip", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				string tooltip = default;
				if ((null != val)) {
					(tooltip, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Tooltip = tooltip;
			}
			(val, ok) = (it.TryGetValue("color", out var ______) ? (______, true) : (default, false));
			if (ok) {
				string color = default;
				if ((null != val)) {
					(color, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Color = color;
			}
			(val, ok) = (it.TryGetValue("command", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				string command = default;
				if ((null != val)) {
					(command, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Command = command;
			}
			return true;
		}
	}

	public partial class OutputChannelState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var __) ? (__, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					(name, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Name = () => {
					return name;
				};
			}
			return true;
		}
	}

	public partial class TextEditorDecorationTypeState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("key", out var __) ? (__, true) : (default, false));
			if (ok) {
				string key = default;
				if ((null != val)) {
					(key, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Key = () => {
					return key;
				};
			}
			return true;
		}
	}

	public partial class InputBoxState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("value", out var __) ? (__, true) : (default, false));
			if (ok) {
				string value = default;
				if ((null != val)) {
					(value, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Value = value;
			}
			(val, ok) = (it.TryGetValue("placeholder", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string placeholder = default;
				if ((null != val)) {
					(placeholder, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Placeholder = placeholder;
			}
			(val, ok) = (it.TryGetValue("password", out var ____) ? (____, true) : (default, false));
			if (ok) {
				bool password = default;
				if ((null != val)) {
					(password, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Password = password;
			}
			(val, ok) = (it.TryGetValue("prompt", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				string prompt = default;
				if ((null != val)) {
					(prompt, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Prompt = prompt;
			}
			(val, ok) = (it.TryGetValue("validationMessage", out var ______) ? (______, true) : (default, false));
			if (ok) {
				string validationMessage = default;
				if ((null != val)) {
					(validationMessage, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.ValidationMessage = validationMessage;
			}
			(val, ok) = (it.TryGetValue("title", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				string title = default;
				if ((null != val)) {
					(title, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Title = title;
			}
			(val, ok) = (it.TryGetValue("step", out var ________) ? (________, true) : (default, false));
			if (ok) {
				int? step = default;
				if ((null != val)) {
					int _step_ = default;
					(_step_, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					step = _step_;
				}
				this.Step = step;
			}
			(val, ok) = (it.TryGetValue("totalSteps", out var _________) ? (_________, true) : (default, false));
			if (ok) {
				int? totalSteps = default;
				if ((null != val)) {
					int _totalSteps_ = default;
					(_totalSteps_, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					totalSteps = _totalSteps_;
				}
				this.TotalSteps = totalSteps;
			}
			(val, ok) = (it.TryGetValue("enabled", out var __________) ? (__________, true) : (default, false));
			if (ok) {
				bool enabled = default;
				if ((null != val)) {
					(enabled, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Enabled = enabled;
			}
			(val, ok) = (it.TryGetValue("busy", out var ___________) ? (___________, true) : (default, false));
			if (ok) {
				bool busy = default;
				if ((null != val)) {
					(busy, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Busy = busy;
			}
			(val, ok) = (it.TryGetValue("ignoreFocusOut", out var ____________) ? (____________, true) : (default, false));
			if (ok) {
				bool ignoreFocusOut = default;
				if ((null != val)) {
					(ignoreFocusOut, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.IgnoreFocusOut = ignoreFocusOut;
			}
			return true;
		}
	}

	public partial class QuickPickState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("value", out var __) ? (__, true) : (default, false));
			if (ok) {
				string value = default;
				if ((null != val)) {
					(value, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Value = value;
			}
			(val, ok) = (it.TryGetValue("placeholder", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string placeholder = default;
				if ((null != val)) {
					(placeholder, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Placeholder = placeholder;
			}
			(val, ok) = (it.TryGetValue("items", out var ____) ? (____, true) : (default, false));
			if (ok) {
				QuickPickItem[] items = default;
				if ((null != val)) {
					any[] __coll__items = default;
					(__coll__items, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					items = new QuickPickItem[__coll__items.Length];
					int __idx__items = default;
					__idx__items = 0;
					foreach (var __item__items in __coll__items) {
						QuickPickItem __val__items = default;
						__val__items = new QuickPickItem();
						ok = __val__items.__loadFromJsonish__(__item__items);
						if (!ok) {
							return false;
						}
						items[__idx__items] = __val__items;
						__idx__items = __idx__items + 1;
					}
				}
				this.Items = items;
			}
			(val, ok) = (it.TryGetValue("canSelectMany", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				bool canSelectMany = default;
				if ((null != val)) {
					(canSelectMany, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.CanSelectMany = canSelectMany;
			}
			(val, ok) = (it.TryGetValue("matchOnDescription", out var ______) ? (______, true) : (default, false));
			if (ok) {
				bool matchOnDescription = default;
				if ((null != val)) {
					(matchOnDescription, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.MatchOnDescription = matchOnDescription;
			}
			(val, ok) = (it.TryGetValue("matchOnDetail", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				bool matchOnDetail = default;
				if ((null != val)) {
					(matchOnDetail, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.MatchOnDetail = matchOnDetail;
			}
			(val, ok) = (it.TryGetValue("activeItems", out var ________) ? (________, true) : (default, false));
			if (ok) {
				QuickPickItem[] activeItems = default;
				if ((null != val)) {
					any[] __coll__activeItems = default;
					(__coll__activeItems, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					activeItems = new QuickPickItem[__coll__activeItems.Length];
					int __idx__activeItems = default;
					__idx__activeItems = 0;
					foreach (var __item__activeItems in __coll__activeItems) {
						QuickPickItem __val__activeItems = default;
						__val__activeItems = new QuickPickItem();
						ok = __val__activeItems.__loadFromJsonish__(__item__activeItems);
						if (!ok) {
							return false;
						}
						activeItems[__idx__activeItems] = __val__activeItems;
						__idx__activeItems = __idx__activeItems + 1;
					}
				}
				this.ActiveItems = activeItems;
			}
			(val, ok) = (it.TryGetValue("selectedItems", out var _________) ? (_________, true) : (default, false));
			if (ok) {
				QuickPickItem[] selectedItems = default;
				if ((null != val)) {
					any[] __coll__selectedItems = default;
					(__coll__selectedItems, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					selectedItems = new QuickPickItem[__coll__selectedItems.Length];
					int __idx__selectedItems = default;
					__idx__selectedItems = 0;
					foreach (var __item__selectedItems in __coll__selectedItems) {
						QuickPickItem __val__selectedItems = default;
						__val__selectedItems = new QuickPickItem();
						ok = __val__selectedItems.__loadFromJsonish__(__item__selectedItems);
						if (!ok) {
							return false;
						}
						selectedItems[__idx__selectedItems] = __val__selectedItems;
						__idx__selectedItems = __idx__selectedItems + 1;
					}
				}
				this.SelectedItems = selectedItems;
			}
			(val, ok) = (it.TryGetValue("title", out var __________) ? (__________, true) : (default, false));
			if (ok) {
				string title = default;
				if ((null != val)) {
					(title, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Title = title;
			}
			(val, ok) = (it.TryGetValue("step", out var ___________) ? (___________, true) : (default, false));
			if (ok) {
				int? step = default;
				if ((null != val)) {
					int _step_ = default;
					(_step_, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					step = _step_;
				}
				this.Step = step;
			}
			(val, ok) = (it.TryGetValue("totalSteps", out var ____________) ? (____________, true) : (default, false));
			if (ok) {
				int? totalSteps = default;
				if ((null != val)) {
					int _totalSteps_ = default;
					(_totalSteps_, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					totalSteps = _totalSteps_;
				}
				this.TotalSteps = totalSteps;
			}
			(val, ok) = (it.TryGetValue("enabled", out var _____________) ? (_____________, true) : (default, false));
			if (ok) {
				bool enabled = default;
				if ((null != val)) {
					(enabled, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Enabled = enabled;
			}
			(val, ok) = (it.TryGetValue("busy", out var ______________) ? (______________, true) : (default, false));
			if (ok) {
				bool busy = default;
				if ((null != val)) {
					(busy, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Busy = busy;
			}
			(val, ok) = (it.TryGetValue("ignoreFocusOut", out var _______________) ? (_______________, true) : (default, false));
			if (ok) {
				bool ignoreFocusOut = default;
				if ((null != val)) {
					(ignoreFocusOut, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.IgnoreFocusOut = ignoreFocusOut;
			}
			return true;
		}
	}

	public partial class TerminalState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var __) ? (__, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					(name, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Name = () => {
					return name;
				};
			}
			return true;
		}
	}

	public partial class FileSystemWatcherState {
		internal bool __loadFromJsonish__(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("ignoreCreateEvents", out var __) ? (__, true) : (default, false));
			if (ok) {
				bool ignoreCreateEvents = default;
				if ((null != val)) {
					(ignoreCreateEvents, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.IgnoreCreateEvents = ignoreCreateEvents;
			}
			(val, ok) = (it.TryGetValue("ignoreChangeEvents", out var ___) ? (___, true) : (default, false));
			if (ok) {
				bool ignoreChangeEvents = default;
				if ((null != val)) {
					(ignoreChangeEvents, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.IgnoreChangeEvents = ignoreChangeEvents;
			}
			(val, ok) = (it.TryGetValue("ignoreDeleteEvents", out var ____) ? (____, true) : (default, false));
			if (ok) {
				bool ignoreDeleteEvents = default;
				if ((null != val)) {
					(ignoreDeleteEvents, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.IgnoreDeleteEvents = ignoreDeleteEvents;
			}
			return true;
		}
	}

}
