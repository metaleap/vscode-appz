// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-csharp.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
namespace VscAppz {
	using System;
	using System.Collections.Generic;
	using Newtonsoft.Json;

	using any = System.Object;
	using dict = System.Collections.Generic.Dictionary<string, object>;

	/// <summary>
	/// Type Definition for Visual Studio Code 1.38 Extension API
	/// See https://code.visualstudio.com/api for more information
	/// </summary>
	public interface IVscode {
		/// <summary>
		/// Namespace for dealing with the current window of the editor. That is visible
		/// and active editors, as well as, UI elements to show messages, selections, and
		/// asking for user input.
		/// </summary>
		IWindow Window { get; }
	}

	/// <summary>
	/// Namespace for dealing with the current window of the editor. That is visible
	/// and active editors, as well as, UI elements to show messages, selections, and
	/// asking for user input.
	/// </summary>
	public interface IWindow {
		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Opens an input box to ask the user for input.
		/// 
		/// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
		/// returned value will be the string typed by the user or an empty string if the user did not type
		/// anything but dismissed the input box with OK.
		/// 
		/// `options` ── Configures the behavior of the input box.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
		/// </summary>
		/// <param name="options">Configures the behavior of the input box.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to a string the user provided or to `undefined` in case of dismissal.</param>
		void ShowInputBox(InputBoxOptions options = default, Cancel token = default, Action<string> andThen = default);

		/// <summary>
		/// Shows a selection list allowing multiple selections.
		/// 
		/// `items` ── An array of strings, or a promise that resolves to an array of strings.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selected items or `undefined`.
		/// </summary>
		/// <param name="items">An array of strings, or a promise that resolves to an array of strings.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selected items or `undefined`.</param>
		void ShowQuickPick(string[] items = default, QuickPickOptions options = default, Cancel token = default, Action<string[]> andThen = default);

		/// <summary>
		/// Shows a selection list.
		/// 
		/// `items` ── An array of strings, or a promise that resolves to an array of strings.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selection or `undefined`.
		/// </summary>
		/// <param name="items">An array of strings, or a promise that resolves to an array of strings.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selection or `undefined`.</param>
		void ShowQuickPick(string[] items = default, QuickPickOptions options = default, Cancel token = default, Action<string> andThen = default);

		/// <summary>
		/// Shows a selection list allowing multiple selections.
		/// 
		/// `items` ── An array of items, or a promise that resolves to an array of items.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selected items or `undefined`.
		/// </summary>
		/// <param name="items">An array of items, or a promise that resolves to an array of items.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selected items or `undefined`.</param>
		void ShowQuickPick(QuickPickItem[] items = default, QuickPickOptions options = default, Cancel token = default, Action<QuickPickItem[]> andThen = default);

		/// <summary>
		/// Shows a selection list.
		/// 
		/// `items` ── An array of items, or a promise that resolves to an array of items.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selected item or `undefined`.
		/// </summary>
		/// <param name="items">An array of items, or a promise that resolves to an array of items.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selected item or `undefined`.</param>
		void ShowQuickPick(QuickPickItem[] items = default, QuickPickOptions options = default, Cancel token = default, Action<QuickPickItem> andThen = default);

		/// <summary>
		/// Set a message to the status bar. This is a short hand for the more powerful
		/// status bar [items](#window.createStatusBarItem).
		/// 
		/// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
		/// 
		/// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
		/// 
		/// `andThen` ── A disposable which hides the status bar message.
		/// </summary>
		/// <param name="text">The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).</param>
		/// <param name="hideAfterTimeout">Timeout in milliseconds after which the message will be disposed.</param>
		/// <param name="andThen">A disposable which hides the status bar message.</param>
		void SetStatusBarMessage(string text = default, int hideAfterTimeout = default, Action<Disposable> andThen = default);

		/// <summary>
		/// Set a message to the status bar. This is a short hand for the more powerful
		/// status bar [items](#window.createStatusBarItem).
		/// 
		/// *Note* that status bar messages stack and that they must be disposed when no
		/// longer used.
		/// 
		/// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
		/// 
		/// `andThen` ── A disposable which hides the status bar message.
		/// </summary>
		/// <param name="text">The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).</param>
		/// <param name="andThen">A disposable which hides the status bar message.</param>
		void SetStatusBarMessage(string text = default, Action<Disposable> andThen = default);

		/// <summary>
		/// Shows a file save dialog to the user which allows to select a file
		/// for saving-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `andThen` ── A promise that resolves to the selected resource or `undefined`.
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <param name="andThen">A promise that resolves to the selected resource or `undefined`.</param>
		void ShowSaveDialog(SaveDialogOptions options = default, Action<string> andThen = default);

		/// <summary>
		/// Shows a file open dialog to the user which allows to select a file
		/// for opening-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `andThen` ── A promise that resolves to the selected resources or `undefined`.
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <param name="andThen">A promise that resolves to the selected resources or `undefined`.</param>
		void ShowOpenDialog(OpenDialogOptions options = default, Action<string[]> andThen = default);

		/// <summary>
		/// Shows a selection list of [workspace folders](#workspace.workspaceFolders) to pick from.
		/// Returns `undefined` if no folder is open.
		/// 
		/// `options` ── Configures the behavior of the workspace folder list.
		/// 
		/// `andThen` ── A promise that resolves to the workspace folder or `undefined`.
		/// </summary>
		/// <param name="options">Configures the behavior of the workspace folder list.</param>
		/// <param name="andThen">A promise that resolves to the workspace folder or `undefined`.</param>
		void ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options = default, Action<WorkspaceFolder> andThen = default);
	}

	/// <summary>Options to configure the behavior of the message.</summary>
	public partial class MessageOptions {
		/// <summary>Indicates that this message should be modal.</summary>
		[JsonProperty("modal")]
		public bool Modal;
	}

	/// <summary>
	/// Represents an action that is shown with an information, warning, or
	/// error message.
	/// </summary>
	public partial class MessageItem {
		/// <summary>A short title like 'Retry', 'Open Log' etc.</summary>
		[JsonProperty("title"), JsonRequired]
		public string Title;

		/// <summary>
		/// A hint for modal dialogs that the item should be triggered
		/// when the user cancels the dialog (e.g. by pressing the ESC
		/// key).
		/// 
		/// Note: this option is ignored for non-modal messages.
		/// </summary>
		[JsonProperty("isCloseAffordance")]
		public bool IsCloseAffordance;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public dict My;
	}

	/// <summary>Options to configure the behavior of the input box UI.</summary>
	public partial class InputBoxOptions {
		/// <summary>The value to prefill in the input box.</summary>
		[JsonProperty("value")]
		public string Value;

		/// <summary>
		/// Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
		/// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
		/// word will be selected, when empty (start equals end) only the cursor will be set,
		/// otherwise the defined range will be selected.
		/// </summary>
		[JsonProperty("valueSelection"), JsonConverter(typeof(json.valueTuples))]
		public (int, int)? ValueSelection;

		/// <summary>The text to display underneath the input box.</summary>
		[JsonProperty("prompt")]
		public string Prompt;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to type.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to show a password prompt that will not show the typed value.</summary>
		[JsonProperty("password")]
		public bool Password;

		/// <summary>Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>
		/// An optional function that will be called to validate input and to give a hint
		/// to the user.
		/// 
		/// `value` ── The current value of the input box.
		/// 
		/// `return` ── A human readable string which is presented as diagnostic message.
		/// Return `undefined`, `null`, or the empty string when 'value' is valid.
		/// </summary>
		[JsonIgnore]
		public Func<string, string> ValidateInput;

		/// <summary>For internal runtime use only.</summary>
		[JsonProperty("validateInput_AppzFuncId")]
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public string ValidateInput_AppzFuncId;
	}

	/// <summary>Options to configure the behavior of the quick pick UI.</summary>
	public partial class QuickPickOptions {
		/// <summary>An optional flag to include the description when filtering the picks.</summary>
		[JsonProperty("matchOnDescription")]
		public bool MatchOnDescription;

		/// <summary>An optional flag to include the detail when filtering the picks.</summary>
		[JsonProperty("matchOnDetail")]
		public bool MatchOnDetail;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>An optional flag to make the picker accept multiple selections, if true the result is an array of picks.</summary>
		[JsonProperty("canPickMany")]
		public bool CanPickMany;

		/// <summary>An optional function that is invoked whenever an item is selected.</summary>
		[JsonIgnore]
		public Func<QuickPickItem, any> OnDidSelectItem;

		/// <summary>For internal runtime use only.</summary>
		[JsonProperty("onDidSelectItem_AppzFuncId")]
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public string OnDidSelectItem_AppzFuncId;
	}

	/// <summary>
	/// Represents an item that can be selected from
	/// a list of items.
	/// </summary>
	public partial class QuickPickItem {
		/// <summary>A human readable string which is rendered prominent.</summary>
		[JsonProperty("label"), JsonRequired]
		public string Label;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("description")]
		public string Description;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("detail")]
		public string Detail;

		/// <summary>
		/// Optional flag indicating if this item is picked initially.
		/// (Only honored when the picker allows multiple selections.)
		/// </summary>
		[JsonProperty("picked")]
		public bool Picked;

		/// <summary>Always show this item.</summary>
		[JsonProperty("alwaysShow")]
		public bool AlwaysShow;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public dict My;
	}

	/// <summary>Options to configure the behaviour of a file save dialog.</summary>
	public partial class SaveDialogOptions {
		/// <summary>A human-readable string for the save button.</summary>
		[JsonProperty("saveLabel")]
		public string SaveLabel;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// ```ts
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// ```
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>
	/// Options to configure the behaviour of a file open dialog.
	/// 
	/// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
	/// which enforces to open either files or folder, but *not both*.
	/// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
	/// and the editor then silently adjusts the options to select files.
	/// </summary>
	public partial class OpenDialogOptions {
		/// <summary>A human-readable string for the open button.</summary>
		[JsonProperty("openLabel")]
		public string OpenLabel;

		/// <summary>Allow to select files, defaults to `true`.</summary>
		[JsonProperty("canSelectFiles")]
		public bool CanSelectFiles;

		/// <summary>Allow to select folders, defaults to `false`.</summary>
		[JsonProperty("canSelectFolders")]
		public bool CanSelectFolders;

		/// <summary>Allow to select many files or folders.</summary>
		[JsonProperty("canSelectMany")]
		public bool CanSelectMany;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// ```ts
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// ```
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>Options to configure the behaviour of the [workspace folder](#WorkspaceFolder) pick UI.</summary>
	public partial class WorkspaceFolderPickOptions {
		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;
	}

	/// <summary>
	/// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
	/// are equal which means there is no notion of an active or master workspace folder.
	/// </summary>
	public partial class WorkspaceFolder {
		/// <summary>
		/// The associated uri for this workspace folder.
		/// 
		/// *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
		/// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
		/// </summary>
		[JsonProperty("uri"), JsonRequired]
		public string Uri;

		/// <summary>
		/// The name of this workspace folder. Defaults to
		/// the basename of its [uri-path](#Uri.path)
		/// </summary>
		[JsonProperty("name"), JsonRequired]
		public string Name;

		/// <summary>The ordinal number of this workspace folder.</summary>
		[JsonProperty("index"), JsonRequired]
		public int Index;
	}

	internal partial class impl : IVscode, IWindow {

		IWindow IVscode.Window { get {
			return this;
		} }

		void IWindow.ShowErrorMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInputBox(InputBoxOptions options, Cancel token, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInputBox";
			msg.Data = new dict(2);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.ValidateInput_AppzFuncId = "";
				Func<string, string> fn = default;
				fn = options.ValidateInput;
				if ((null != fn)) {
					lock (this) {
						options.ValidateInput_AppzFuncId = this.nextFuncId();
						fnids.Add(options.ValidateInput_AppzFuncId);
						this.cbOther[options.ValidateInput_AppzFuncId] = (any[] args) => {
							if ((1 != args.Length)) {
								return (null, false);
							} else {
								bool ok = default;
								string __0 = default;
								if ((null != args[0])) {
									(__0, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
									if ((!ok)) {
										return (null, false);
									}
								}
								return (fn(__0), true);
							}							
						};
					}
				}
			}
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this;
				if (("" == token.fnId)) {
					lock (this) {
						token.fnId = this.nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, (any payload) => {
				if ((fnids.Count != 0)) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.cbOther.Remove(fnid);
						}
					}
				}
				return ((null == on) || on(payload));
			});
		}

		void IWindow.ShowQuickPick(string[] items, QuickPickOptions options, Cancel token, Action<string[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick1";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if (true) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if ((1 != args.Length)) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if ((!ok)) {
										return (null, false);
									}
								} else {
									return (null, false);
								}								
								return (fn(__0), true);
							}							
						};
					}
				}
			}
			msg.Data["items"] = items;
			options.CanPickMany = true;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this;
				if (("" == token.fnId)) {
					lock (this) {
						token.fnId = this.nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = new string[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							string __val__result = default;
							(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
							if ((!ok)) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = (__idx__result + 1);
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, (any payload) => {
				if ((fnids.Count != 0)) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.cbOther.Remove(fnid);
						}
					}
				}
				return ((null == on) || on(payload));
			});
		}

		void IWindow.ShowQuickPick(string[] items, QuickPickOptions options, Cancel token, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick2";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if ((1 != args.Length)) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if ((!ok)) {
										return (null, false);
									}
								} else {
									return (null, false);
								}								
								return (fn(__0), true);
							}							
						};
					}
				}
			}
			msg.Data["items"] = items;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this;
				if (("" == token.fnId)) {
					lock (this) {
						token.fnId = this.nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, (any payload) => {
				if ((fnids.Count != 0)) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.cbOther.Remove(fnid);
						}
					}
				}
				return ((null == on) || on(payload));
			});
		}

		void IWindow.ShowQuickPick(QuickPickItem[] items, QuickPickOptions options, Cancel token, Action<QuickPickItem[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick3";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if (true) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if ((1 != args.Length)) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if ((!ok)) {
										return (null, false);
									}
								} else {
									return (null, false);
								}								
								return (fn(__0), true);
							}							
						};
					}
				}
			}
			msg.Data["items"] = items;
			options.CanPickMany = true;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this;
				if (("" == token.fnId)) {
					lock (this) {
						token.fnId = this.nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					QuickPickItem[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = new QuickPickItem[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							QuickPickItem __val__result = default;
							__val__result = new QuickPickItem();
							ok = __val__result.populateFrom(__item__result);
							if ((!ok)) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = (__idx__result + 1);
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, (any payload) => {
				if ((fnids.Count != 0)) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.cbOther.Remove(fnid);
						}
					}
				}
				return ((null == on) || on(payload));
			});
		}

		void IWindow.ShowQuickPick(QuickPickItem[] items, QuickPickOptions options, Cancel token, Action<QuickPickItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick4";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if ((1 != args.Length)) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if ((!ok)) {
										return (null, false);
									}
								} else {
									return (null, false);
								}								
								return (fn(__0), true);
							}							
						};
					}
				}
			}
			msg.Data["items"] = items;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this;
				if (("" == token.fnId)) {
					lock (this) {
						token.fnId = this.nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					QuickPickItem result = default;
					if ((null != payload)) {
						result = new QuickPickItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, (any payload) => {
				if ((fnids.Count != 0)) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.cbOther.Remove(fnid);
						}
					}
				}
				return ((null == on) || on(payload));
			});
		}

		void IWindow.SetStatusBarMessage(string text, int hideAfterTimeout, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.setStatusBarMessage1";
			msg.Data = new dict(2);
			msg.Data["text"] = text;
			msg.Data["hideAfterTimeout"] = hideAfterTimeout;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					} else {
						return false;
					}					
					andThen(result.bindTo(this));
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.SetStatusBarMessage(string text, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.setStatusBarMessage2";
			msg.Data = new dict(1);
			msg.Data["text"] = text;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					} else {
						return false;
					}					
					andThen(result.bindTo(this));
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowSaveDialog(SaveDialogOptions options, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showSaveDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowOpenDialog(OpenDialogOptions options, Action<string[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showOpenDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
						result = new string[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							string __val__result = default;
							(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
							if ((!ok)) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = (__idx__result + 1);
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options, Action<WorkspaceFolder> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWorkspaceFolderPick";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					WorkspaceFolder result = default;
					if ((null != payload)) {
						result = new WorkspaceFolder();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

	}

	public partial class MessageItem {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if ((!ok)) {
				return false;
			}
			(val, ok) = (it.TryGetValue("title", out var __) ? (__, true) : (default, false));
			if (ok) {
				string title = default;
				if ((null != val)) {
					(title, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.Title = title;
			} else {
				return false;
			}			
			(val, ok) = (it.TryGetValue("isCloseAffordance", out var ___) ? (___, true) : (default, false));
			if (ok) {
				bool isCloseAffordance = default;
				if ((null != val)) {
					(isCloseAffordance, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.IsCloseAffordance = isCloseAffordance;
			}
			(val, ok) = (it.TryGetValue("my", out var ____) ? (____, true) : (default, false));
			if (ok) {
				dict my = default;
				if ((null != val)) {
					(my, ok) = (val is dict) ? (((dict)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.My = my;
			}
			return true;
		}
	}

	public partial class QuickPickItem {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if ((!ok)) {
				return false;
			}
			(val, ok) = (it.TryGetValue("label", out var __) ? (__, true) : (default, false));
			if (ok) {
				string label = default;
				if ((null != val)) {
					(label, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.Label = label;
			} else {
				return false;
			}			
			(val, ok) = (it.TryGetValue("description", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string description = default;
				if ((null != val)) {
					string _description_ = default;
					(_description_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
					description = _description_;
				}
				this.Description = description;
			}
			(val, ok) = (it.TryGetValue("detail", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string detail = default;
				if ((null != val)) {
					string _detail_ = default;
					(_detail_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
					detail = _detail_;
				}
				this.Detail = detail;
			}
			(val, ok) = (it.TryGetValue("picked", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				bool picked = default;
				if ((null != val)) {
					(picked, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.Picked = picked;
			}
			(val, ok) = (it.TryGetValue("alwaysShow", out var ______) ? (______, true) : (default, false));
			if (ok) {
				bool alwaysShow = default;
				if ((null != val)) {
					(alwaysShow, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.AlwaysShow = alwaysShow;
			}
			(val, ok) = (it.TryGetValue("my", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				dict my = default;
				if ((null != val)) {
					(my, ok) = (val is dict) ? (((dict)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.My = my;
			}
			return true;
		}
	}

	public partial class WorkspaceFolder {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if ((!ok)) {
				return false;
			}
			(val, ok) = (it.TryGetValue("uri", out var __) ? (__, true) : (default, false));
			if (ok) {
				string uri = default;
				if ((null != val)) {
					(uri, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.Uri = uri;
			} else {
				return false;
			}			
			(val, ok) = (it.TryGetValue("name", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					(name, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.Name = name;
			} else {
				return false;
			}			
			(val, ok) = (it.TryGetValue("index", out var ____) ? (____, true) : (default, false));
			if (ok) {
				int index = default;
				if ((null != val)) {
					(index, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if ((!ok)) {
						return false;
					}
				}
				this.Index = index;
			} else {
				return false;
			}			
			return true;
		}
	}

}
