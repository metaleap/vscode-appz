// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-csharp.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
namespace VscAppz {
	using System;
	using System.Collections.Generic;
	using Newtonsoft.Json;
	using any = System.Object;
	using dict = System.Collections.Generic.Dictionary<string, object>;

	/// <summary>Represents the alignment of status bar items.</summary>
	public enum StatusBarAlignment {
		/// <summary>Aligned to the left side.</summary>
		Left = 1,

		/// <summary>Aligned to the right side.</summary>
		Right = 2,
	}

	/// <summary>Describes the behavior of decorations when typing/editing at their edges.</summary>
	public enum DecorationRangeBehavior {
		/// <summary>The decoration's range will widen when edits occur at the start or end.</summary>
		OpenOpen = 0,

		/// <summary>The decoration's range will not widen when edits occur at the start of end.</summary>
		ClosedClosed = 1,

		/// <summary>The decoration's range will widen when edits occur at the start, but not at the end.</summary>
		OpenClosed = 2,

		/// <summary>The decoration's range will widen when edits occur at the end, but not at the start.</summary>
		ClosedOpen = 3,
	}

	/// <summary>
	/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
	/// The overview ruler supports three lanes.
	/// </summary>
	public enum OverviewRulerLane {
		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// </summary>
		Left = 1,

		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// </summary>
		Center = 2,

		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// </summary>
		Right = 4,

		/// <summary>
		/// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
		/// The overview ruler supports three lanes.
		/// </summary>
		Full = 7,
	}

	/// <summary>
	/// Type Definition for Visual Studio Code 1.39 Extension API
	/// See https://code.visualstudio.com/api for more information
	/// </summary>
	public interface IVscode {
		/// <summary>
		/// Namespace for dealing with the current window of the editor. That is visible
		/// and active editors, as well as, UI elements to show messages, selections, and
		/// asking for user input.
		/// </summary>
		IWindow Window { get; }

		/// <summary>Namespace describing the environment the editor runs in.</summary>
		IEnv Env { get; }

		/// <summary>
		/// Namespace for dealing with the current workspace. A workspace is the representation
		/// of the folder that has been opened. There is no workspace when just a file but not a
		/// folder has been opened.
		/// 
		/// The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
		/// events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
		/// the editor-process so that they should be always used instead of nodejs-equivalents.
		/// </summary>
		IWorkspace Workspace { get; }

		/// <summary>
		/// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
		/// like IntelliSense, code actions, diagnostics etc.
		/// 
		/// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
		/// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
		/// programming languages.
		/// 
		/// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
		/// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
		/// that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
		/// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
		/// 
		/// 
		/// ```javascript
		/// 
		/// languages.registerHoverProvider('javascript', {
		///  	provideHover(document, position, token) {
		///  		return new Hover('I am a hover!');
		///  	}
		/// });
		/// 
		/// ```
		/// 
		/// 
		/// Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
		/// a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
		/// a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
		/// scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
		/// the score is only checked to be `>0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
		/// score is used for determining the order in which providers are asked to participate.
		/// </summary>
		ILanguages Languages { get; }

		/// <summary>
		/// Namespace for dealing with installed extensions. Extensions are represented
		/// by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
		/// 
		/// Extension writers can provide APIs to other extensions by returning their API public
		/// surface from the `activate`-call.
		/// 
		/// 
		/// ```javascript
		/// 
		/// export function activate(context: vscode.ExtensionContext) {
		///  	let api = {
		///  		sum(a, b) {
		///  			return a + b;
		///  		},
		///  		mul(a, b) {
		///  			return a * b;
		///  		}
		///  	};
		///  	// 'export' public api-surface
		///  	return api;
		/// }
		/// 
		/// ```
		/// 
		/// When depending on the API of another extension add an `extensionDependency`-entry
		/// to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
		/// and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
		/// 
		/// 
		/// ```javascript
		/// 
		/// let mathExt = extensions.getExtension('genius.math');
		/// let importedApi = mathExt.exports;
		/// 
		/// console.log(importedApi.mul(42, 1));
		/// 
		/// ```
		/// 
		/// </summary>
		IExtensions Extensions { get; }

		/// <summary>
		/// Namespace for dealing with commands. In short, a command is a function with a
		/// unique identifier. The function is sometimes also called _command handler_.
		/// 
		/// Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
		/// and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
		/// can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
		/// 
		/// * palette - Use the `commands`-section in `package.json` to make a command show in
		/// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
		/// * keybinding - Use the `keybindings`-section in `package.json` to enable
		/// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
		/// for your extension.
		/// 
		/// Commands from other extensions and from the editor itself are accessible to an extension. However,
		/// when invoking an editor command not all argument types are supported.
		/// 
		/// This is a sample that registers a command handler and adds an entry for that command to the palette. First
		/// register a command handler with the identifier `extension.sayHello`.
		/// 
		/// ```javascript
		/// 
		/// commands.registerCommand('extension.sayHello', () => {
		///  	window.showInformationMessage('Hello World!');
		/// });
		/// 
		/// ```
		/// 
		/// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
		/// 
		/// ```json
		/// 
		/// {
		///  	"contributes": {
		///  		"commands": [{
		///  			"command": "extension.sayHello",
		///  			"title": "Hello World"
		///  		}]
		///  	}
		/// }
		/// 
		/// ```
		/// 
		/// </summary>
		ICommands Commands { get; }
	}

	/// <summary>
	/// Namespace for dealing with the current window of the editor. That is visible
	/// and active editors, as well as, UI elements to show messages, selections, and
	/// asking for user input.
	/// </summary>
	public interface IWindow {
		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowInformationMessage1(string message = default, string[] items = default);

		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowInformationMessage2(string message = default, MessageOptions options = default, string[] items = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<MessageItem>> ShowInformationMessage3(string message = default, MessageItem[] items = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<MessageItem>> ShowInformationMessage4(string message = default, MessageOptions options = default, MessageItem[] items = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowWarningMessage1(string message = default, string[] items = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowWarningMessage2(string message = default, MessageOptions options = default, string[] items = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<MessageItem>> ShowWarningMessage3(string message = default, MessageItem[] items = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<MessageItem>> ShowWarningMessage4(string message = default, MessageOptions options = default, MessageItem[] items = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowErrorMessage1(string message = default, string[] items = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<string>> ShowErrorMessage2(string message = default, MessageOptions options = default, string[] items = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<MessageItem>> ShowErrorMessage3(string message = default, MessageItem[] items = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <return>A thenable that resolves to the selected item or `undefined` when being dismissed.</return>
		Action<Action<MessageItem>> ShowErrorMessage4(string message = default, MessageOptions options = default, MessageItem[] items = default);

		/// <summary>
		/// Opens an input box to ask the user for input.
		/// 
		/// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
		/// returned value will be the string typed by the user or an empty string if the user did not type
		/// anything but dismissed the input box with OK.
		/// 
		/// `options` ── Configures the behavior of the input box.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `return` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
		/// </summary>
		/// <param name="options">Configures the behavior of the input box.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <return>A promise that resolves to a string the user provided or to `undefined` in case of dismissal.</return>
		Action<Action<string>> ShowInputBox(InputBoxOptions options = default, Cancel token = default);

		/// <summary>
		/// Shows a selection list allowing multiple selections.
		/// 
		/// `items` ── An array of strings, or a promise that resolves to an array of strings.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `return` ── A promise that resolves to the selected items or `undefined`.
		/// </summary>
		/// <param name="items">An array of strings, or a promise that resolves to an array of strings.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <return>A promise that resolves to the selected items or `undefined`.</return>
		Action<Action<string[]>> ShowQuickPick1(string[] items = default, QuickPickOptions options = default, Cancel token = default);

		/// <summary>
		/// Shows a selection list.
		/// 
		/// `items` ── An array of strings, or a promise that resolves to an array of strings.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `return` ── A promise that resolves to the selection or `undefined`.
		/// </summary>
		/// <param name="items">An array of strings, or a promise that resolves to an array of strings.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <return>A promise that resolves to the selection or `undefined`.</return>
		Action<Action<string>> ShowQuickPick2(string[] items = default, QuickPickOptions options = default, Cancel token = default);

		/// <summary>
		/// Shows a selection list allowing multiple selections.
		/// 
		/// `items` ── An array of items, or a promise that resolves to an array of items.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `return` ── A promise that resolves to the selected items or `undefined`.
		/// </summary>
		/// <param name="items">An array of items, or a promise that resolves to an array of items.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <return>A promise that resolves to the selected items or `undefined`.</return>
		Action<Action<QuickPickItem[]>> ShowQuickPick3(QuickPickItem[] items = default, QuickPickOptions options = default, Cancel token = default);

		/// <summary>
		/// Shows a selection list.
		/// 
		/// `items` ── An array of items, or a promise that resolves to an array of items.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `return` ── A promise that resolves to the selected item or `undefined`.
		/// </summary>
		/// <param name="items">An array of items, or a promise that resolves to an array of items.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <return>A promise that resolves to the selected item or `undefined`.</return>
		Action<Action<QuickPickItem>> ShowQuickPick4(QuickPickItem[] items = default, QuickPickOptions options = default, Cancel token = default);

		/// <summary>
		/// Set a message to the status bar. This is a short hand for the more powerful
		/// status bar [items](https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem).
		/// 
		/// `text` ── The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).
		/// 
		/// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
		/// 
		/// `return` ── A disposable which hides the status bar message.
		/// </summary>
		/// <param name="text">The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).</param>
		/// <param name="hideAfterTimeout">Timeout in milliseconds after which the message will be disposed.</param>
		/// <return>A disposable which hides the status bar message.</return>
		Action<Action<Disposable>> SetStatusBarMessage1(string text = default, int hideAfterTimeout = default);

		/// <summary>
		/// Set a message to the status bar. This is a short hand for the more powerful
		/// status bar [items](https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem).
		/// 
		/// *Note* that status bar messages stack and that they must be disposed when no
		/// longer used.
		/// 
		/// `text` ── The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).
		/// 
		/// `return` ── A disposable which hides the status bar message.
		/// </summary>
		/// <param name="text">The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).</param>
		/// <return>A disposable which hides the status bar message.</return>
		Action<Action<Disposable>> SetStatusBarMessage2(string text = default);

		/// <summary>
		/// Shows a file save dialog to the user which allows to select a file
		/// for saving-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `return` ── A promise that resolves to the selected resource or `undefined`.
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <return>A promise that resolves to the selected resource or `undefined`.</return>
		Action<Action<string>> ShowSaveDialog(SaveDialogOptions options = default);

		/// <summary>
		/// Shows a file open dialog to the user which allows to select a file
		/// for opening-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `return` ── A promise that resolves to the selected resources or `undefined`.
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <return>A promise that resolves to the selected resources or `undefined`.</return>
		Action<Action<string[]>> ShowOpenDialog(OpenDialogOptions options = default);

		/// <summary>
		/// Shows a selection list of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) to pick from.
		/// Returns `undefined` if no folder is open.
		/// 
		/// `options` ── Configures the behavior of the workspace folder list.
		/// 
		/// `return` ── A promise that resolves to the workspace folder or `undefined`.
		/// </summary>
		/// <param name="options">Configures the behavior of the workspace folder list.</param>
		/// <return>A promise that resolves to the workspace folder or `undefined`.</return>
		Action<Action<WorkspaceFolder>> ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options = default);

		/// <summary>Represents the current window's state.</summary>
		Action<Action<WindowState>> State();

		/// <summary>
		/// An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the focus state of the current window
		/// changes. The value of the event represents whether the window is focused.
		/// </summary>
		Action<Action<Disposable>> OnDidChangeWindowState(Action<WindowState> listener = default);

		/// <summary>
		/// Creates a status bar [item](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem).
		/// 
		/// `alignment` ── The alignment of the item.
		/// 
		/// `priority` ── The priority of the item. Higher values mean the item should be shown more to the left.
		/// 
		/// `return` ── A new status bar item.
		/// </summary>
		/// <param name="alignment">The alignment of the item.</param>
		/// <param name="priority">The priority of the item. Higher values mean the item should be shown more to the left.</param>
		/// <return>A new status bar item.</return>
		Action<Action<StatusBarItem>> CreateStatusBarItem(StatusBarAlignment? alignment = default, int? priority = default);

		/// <summary>
		/// Creates a new [output channel](https://code.visualstudio.com/api/references/vscode-api#OutputChannel) with the given name.
		/// 
		/// `name` ── Human-readable string which will be used to represent the channel in the UI.
		/// </summary>
		/// <param name="name">Human-readable string which will be used to represent the channel in the UI.</param>
		Action<Action<OutputChannel>> CreateOutputChannel(string name = default);

		/// <summary>
		/// Create a TextEditorDecorationType that can be used to add decorations to text editors.
		/// 
		/// `options` ── Rendering options for the decoration type.
		/// 
		/// `return` ── A new decoration type instance.
		/// </summary>
		/// <param name="options">Rendering options for the decoration type.</param>
		/// <return>A new decoration type instance.</return>
		Action<Action<TextEditorDecorationType>> CreateTextEditorDecorationType(DecorationRenderOptions options = default);
	}

	/// <summary>Namespace describing the environment the editor runs in.</summary>
	public interface IEnv {
		/// <summary>
		/// Opens an *external* item, e.g. a http(s) or mailto-link, using the
		/// default application.
		/// 
		/// *Note* that [`showTextDocument`](https://code.visualstudio.com/api/references/vscode-api#window.showTextDocument) is the right
		/// way to open a text document inside the editor, not this function.
		/// 
		/// `target` ── The uri that should be opened.
		/// 
		/// `return` ── A promise indicating if open was successful.
		/// </summary>
		/// <param name="target">The uri that should be opened.</param>
		/// <return>A promise indicating if open was successful.</return>
		Action<Action<bool>> OpenExternal(string target = default);

		/// <summary>The application name of the editor, like 'VS Code'.</summary>
		Action<Action<string>> AppName();

		/// <summary>The application root folder from which the editor is running.</summary>
		Action<Action<string>> AppRoot();

		/// <summary>Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.</summary>
		Action<Action<string>> Language();

		/// <summary>A unique identifier for the computer.</summary>
		Action<Action<string>> MachineId();

		/// <summary>
		/// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
		/// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
		/// 
		/// *Note* that the value is `undefined` when there is no remote extension host but that the
		/// value is defined in all extension hosts (local and remote) in case a remote extension host
		/// exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
		/// a specific extension runs remote or not.
		/// </summary>
		Action<Action<string>> RemoteName();

		/// <summary>
		/// A unique identifier for the current session.
		/// Changes each time the editor is started.
		/// </summary>
		Action<Action<string>> SessionId();

		/// <summary>
		/// The detected default shell for the extension host, this is overridden by the
		/// `terminal.integrated.shell` setting for the extension host's platform.
		/// </summary>
		Action<Action<string>> Shell();

		/// <summary>The custom uri scheme the editor registers to in the operating system.</summary>
		Action<Action<string>> UriScheme();

		/// <summary>Provides single-call access to numerous individual `IEnv` properties at once.</summary>
		Action<Action<EnvProperties>> Properties();

		/// <summary>The clipboard provides read and write access to the system's clipboard.</summary>
		IClipboard Clipboard();
	}

	/// <summary>The clipboard provides read and write access to the system's clipboard.</summary>
	public interface IClipboard {
		/// <summary>
		/// Read the current clipboard contents as text.
		/// 
		/// `return` ── A thenable that resolves to a string.
		/// </summary>
		/// <return>A thenable that resolves to a string.</return>
		Action<Action<string>> ReadText();

		/// <summary>
		/// Writes text into the clipboard.
		/// 
		/// `return` ── A thenable that resolves when writing happened.
		/// </summary>
		/// <return>A thenable that resolves when writing happened.</return>
		Action<Action> WriteText(string value = default);
	}

	/// <summary>
	/// Namespace for dealing with the current workspace. A workspace is the representation
	/// of the folder that has been opened. There is no workspace when just a file but not a
	/// folder has been opened.
	/// 
	/// The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
	/// events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
	/// the editor-process so that they should be always used instead of nodejs-equivalents.
	/// </summary>
	public interface IWorkspace {
		/// <summary>
		/// The name of the workspace. `undefined` when no folder
		/// has been opened.
		/// </summary>
		Action<Action<string>> Name();

		/// <summary>
		/// The location of the workspace file, for example:
		/// 
		/// `file:///Users/name/Development/myProject.code-workspace`
		/// 
		/// or
		/// 
		/// `untitled:1555503116870`
		/// 
		/// for a workspace that is untitled and not yet saved.
		/// 
		/// Depending on the workspace that is opened, the value will be:
		///   * `undefined` when no workspace or  a single folder is opened
		///   * the path of the workspace file as `Uri` otherwise. if the workspace
		/// is untitled, the returned URI will use the `untitled:` scheme
		/// 
		/// The location can e.g. be used with the `vscode.openFolder` command to
		/// open the workspace again after it has been closed.
		/// 
		/// **Example:**
		/// 
		/// ```typescript
		/// 
		/// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
		/// 
		/// ```
		/// 
		/// 
		/// **Note:** it is not advised to use `workspace.workspaceFile` to write
		/// configuration data into the file. You can use `workspace.getConfiguration().update()`
		/// for that purpose which will work both when a single folder is opened as
		/// well as an untitled or saved workspace.
		/// </summary>
		Action<Action<string>> WorkspaceFile();

		/// <summary>
		/// Save all dirty files.
		/// 
		/// `includeUntitled` ── Also save files that have been created during this session.
		/// 
		/// `return` ── A thenable that resolves when the files have been saved.
		/// </summary>
		/// <param name="includeUntitled">Also save files that have been created during this session.</param>
		/// <return>A thenable that resolves when the files have been saved.</return>
		Action<Action<bool>> SaveAll(bool includeUntitled = default);

		/// <summary>An event that is emitted when a workspace folder is added or removed.</summary>
		Action<Action<Disposable>> OnDidChangeWorkspaceFolders(Action<WorkspaceFoldersChangeEvent> listener = default);

		/// <summary>
		/// Returns the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) that contains a given uri.
		/// * returns `undefined` when the given uri doesn't match any workspace folder
		/// * returns the *input* when the given uri is a workspace folder itself
		/// 
		/// `uri` ── An uri.
		/// 
		/// `return` ── A workspace folder or `undefined`
		/// </summary>
		/// <param name="uri">An uri.</param>
		/// <return>A workspace folder or `undefined`</return>
		Action<Action<WorkspaceFolder>> GetWorkspaceFolder(string uri = default);

		/// <summary>
		/// List of workspace folders or `undefined` when no folder is open.
		/// *Note* that the first entry corresponds to the value of `rootPath`.
		/// </summary>
		Action<Action<WorkspaceFolder[]>> WorkspaceFolders();

		/// <summary>
		/// Find files across all [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) in the workspace.
		/// `findFiles('**​/*.js', '**​/node_modules/**', 10)`
		/// 
		/// `include` ── A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines the files to search for. The glob pattern
		/// will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern)
		/// to restrict the search results to a [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder).
		/// 
		/// `exclude` ── A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines files and folders to exclude. The glob pattern
		/// will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will
		/// apply, when `null` no excludes will apply.
		/// 
		/// `maxResults` ── An upper-bound for the result.
		/// 
		/// `token` ── A token that can be used to signal cancellation to the underlying search engine.
		/// 
		/// `return` ── A thenable that resolves to an array of resource identifiers. Will return no results if no
		/// [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) are opened.
		/// </summary>
		/// <param name="include">A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines the files to search for. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern) to restrict the search results to a [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder).</param>
		/// <param name="exclude">A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines files and folders to exclude. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will apply, when `null` no excludes will apply.</param>
		/// <param name="maxResults">An upper-bound for the result.</param>
		/// <param name="token">A token that can be used to signal cancellation to the underlying search engine.</param>
		/// <return>A thenable that resolves to an array of resource identifiers. Will return no results if no [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) are opened.</return>
		Action<Action<string[]>> FindFiles(string include = default, string exclude = default, int? maxResults = default, Cancel token = default);

		/// <summary>
		/// Returns a path that is relative to the workspace folder or folders.
		/// 
		/// When there are no [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) or when the path
		/// is not contained in them, the input is returned.
		/// 
		/// `pathOrUri` ── A path or uri. When a uri is given its [fsPath](https://code.visualstudio.com/api/references/vscode-api#Uri.fsPath) is used.
		/// 
		/// `includeWorkspaceFolder` ── When `true` and when the given path is contained inside a
		/// workspace folder the name of the workspace is prepended. Defaults to `true` when there are
		/// multiple workspace folders and `false` otherwise.
		/// 
		/// `return` ── A path relative to the root or the input.
		/// </summary>
		/// <param name="pathOrUri">A path or uri. When a uri is given its [fsPath](https://code.visualstudio.com/api/references/vscode-api#Uri.fsPath) is used.</param>
		/// <param name="includeWorkspaceFolder">When `true` and when the given path is contained inside a workspace folder the name of the workspace is prepended. Defaults to `true` when there are multiple workspace folders and `false` otherwise.</param>
		/// <return>A path relative to the root or the input.</return>
		Action<Action<string>> AsRelativePath(string pathOrUri = default, bool includeWorkspaceFolder = default);

		/// <summary>Provides single-call access to numerous individual `IWorkspace` properties at once.</summary>
		Action<Action<WorkspaceProperties>> Properties();
	}

	/// <summary>
	/// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
	/// like IntelliSense, code actions, diagnostics etc.
	/// 
	/// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
	/// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
	/// programming languages.
	/// 
	/// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
	/// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
	/// that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
	/// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
	/// 
	/// 
	/// ```javascript
	/// 
	/// languages.registerHoverProvider('javascript', {
	///  	provideHover(document, position, token) {
	///  		return new Hover('I am a hover!');
	///  	}
	/// });
	/// 
	/// ```
	/// 
	/// 
	/// Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
	/// a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
	/// a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
	/// scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
	/// the score is only checked to be `>0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
	/// score is used for determining the order in which providers are asked to participate.
	/// </summary>
	public interface ILanguages {
		/// <summary>
		/// Return the identifiers of all known languages.
		/// 
		/// `return` ── Promise resolving to an array of identifier strings.
		/// </summary>
		/// <return>Promise resolving to an array of identifier strings.</return>
		Action<Action<string[]>> GetLanguages();

		/// <summary>
		/// An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the global set of diagnostics changes. This is
		/// newly added and removed diagnostics.
		/// </summary>
		Action<Action<Disposable>> OnDidChangeDiagnostics(Action<DiagnosticChangeEvent> listener = default);
	}

	/// <summary>
	/// Namespace for dealing with installed extensions. Extensions are represented
	/// by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
	/// 
	/// Extension writers can provide APIs to other extensions by returning their API public
	/// surface from the `activate`-call.
	/// 
	/// 
	/// ```javascript
	/// 
	/// export function activate(context: vscode.ExtensionContext) {
	///  	let api = {
	///  		sum(a, b) {
	///  			return a + b;
	///  		},
	///  		mul(a, b) {
	///  			return a * b;
	///  		}
	///  	};
	///  	// 'export' public api-surface
	///  	return api;
	/// }
	/// 
	/// ```
	/// 
	/// When depending on the API of another extension add an `extensionDependency`-entry
	/// to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
	/// and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
	/// 
	/// 
	/// ```javascript
	/// 
	/// let mathExt = extensions.getExtension('genius.math');
	/// let importedApi = mathExt.exports;
	/// 
	/// console.log(importedApi.mul(42, 1));
	/// 
	/// ```
	/// 
	/// </summary>
	public interface IExtensions {
		/// <summary>
		/// An event which fires when `extensions.all` changes. This can happen when extensions are
		/// installed, uninstalled, enabled or disabled.
		/// </summary>
		Action<Action<Disposable>> OnDidChange(Action listener = default);
	}

	/// <summary>
	/// Namespace for dealing with commands. In short, a command is a function with a
	/// unique identifier. The function is sometimes also called _command handler_.
	/// 
	/// Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
	/// and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
	/// can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
	/// 
	/// * palette - Use the `commands`-section in `package.json` to make a command show in
	/// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
	/// * keybinding - Use the `keybindings`-section in `package.json` to enable
	/// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
	/// for your extension.
	/// 
	/// Commands from other extensions and from the editor itself are accessible to an extension. However,
	/// when invoking an editor command not all argument types are supported.
	/// 
	/// This is a sample that registers a command handler and adds an entry for that command to the palette. First
	/// register a command handler with the identifier `extension.sayHello`.
	/// 
	/// ```javascript
	/// 
	/// commands.registerCommand('extension.sayHello', () => {
	///  	window.showInformationMessage('Hello World!');
	/// });
	/// 
	/// ```
	/// 
	/// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
	/// 
	/// ```json
	/// 
	/// {
	///  	"contributes": {
	///  		"commands": [{
	///  			"command": "extension.sayHello",
	///  			"title": "Hello World"
	///  		}]
	///  	}
	/// }
	/// 
	/// ```
	/// 
	/// </summary>
	public interface ICommands {
		/// <summary>
		/// Registers a command that can be invoked via a keyboard shortcut,
		/// a menu item, an action, or directly.
		/// 
		/// Registering a command with an existing command identifier twice
		/// will cause an error.
		/// 
		/// `command` ── A unique identifier for the command.
		/// 
		/// `callback` ── A command handler function.
		/// 
		/// `return` ── Disposable which unregisters this command on disposal.
		/// </summary>
		/// <param name="command">A unique identifier for the command.</param>
		/// <param name="callback">A command handler function.</param>
		/// <return>Disposable which unregisters this command on disposal.</return>
		Action<Action<Disposable>> RegisterCommand(string command = default, Func<any[], any> callback = default);

		/// <summary>
		/// Executes the command denoted by the given command identifier.
		/// 
		/// * *Note 1:* When executing an editor command not all types are allowed to
		/// be passed as arguments. Allowed are the primitive types `string`, `boolean`,
		/// `number`, `undefined`, and `null`, as well as [`Position`](https://code.visualstudio.com/api/references/vscode-api#Position), [`Range`](#Range), [`Uri`](#Uri) and [`Location`](#Location).
		/// * *Note 2:* There are no restrictions when executing commands that have been contributed
		/// by extensions.
		/// 
		/// `command` ── Identifier of the command to execute.
		/// 
		/// `rest` ── Parameters passed to the command function.
		/// 
		/// `return` ── A thenable that resolves to the returned value of the given command. `undefined` when
		/// the command handler function doesn't return anything.
		/// </summary>
		/// <param name="command">Identifier of the command to execute.</param>
		/// <param name="rest">Parameters passed to the command function.</param>
		/// <return>A thenable that resolves to the returned value of the given command. `undefined` when the command handler function doesn't return anything.</return>
		Action<Action<any>> ExecuteCommand(string command = default, any[] rest = default);

		/// <summary>
		/// Retrieve the list of all available commands. Commands starting an underscore are
		/// treated as internal commands.
		/// 
		/// `filterInternal` ── Set `true` to not see internal commands (starting with an underscore)
		/// 
		/// `return` ── Thenable that resolves to a list of command ids.
		/// </summary>
		/// <param name="filterInternal">Set `true` to not see internal commands (starting with an underscore)</param>
		/// <return>Thenable that resolves to a list of command ids.</return>
		Action<Action<string[]>> GetCommands(bool filterInternal = default);
	}

	/// <summary>Options to configure the behavior of the message.</summary>
	public partial class MessageOptions {
		/// <summary>Indicates that this message should be modal.</summary>
		[JsonProperty("modal")]
		public bool Modal;
	}

	/// <summary>
	/// Represents an action that is shown with an information, warning, or
	/// error message.
	/// </summary>
	public partial class MessageItem {
		/// <summary>A short title like 'Retry', 'Open Log' etc.</summary>
		[JsonProperty("title"), JsonRequired]
		public string Title;

		/// <summary>
		/// A hint for modal dialogs that the item should be triggered
		/// when the user cancels the dialog (e.g. by pressing the ESC
		/// key).
		/// 
		/// Note: this option is ignored for non-modal messages.
		/// </summary>
		[JsonProperty("isCloseAffordance")]
		public bool IsCloseAffordance;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public dict My;
	}

	/// <summary>Options to configure the behavior of the input box UI.</summary>
	public partial class InputBoxOptions {
		/// <summary>The value to prefill in the input box.</summary>
		[JsonProperty("value")]
		public string Value;

		/// <summary>
		/// Selection of the prefilled [`value`](https://code.visualstudio.com/api/references/vscode-api#InputBoxOptions.value). Defined as tuple of two number where the
		/// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
		/// word will be selected, when empty (start equals end) only the cursor will be set,
		/// otherwise the defined range will be selected.
		/// </summary>
		[JsonProperty("valueSelection"), JsonConverter(typeof(json.valueTuples))]
		public (int, int)? ValueSelection;

		/// <summary>The text to display underneath the input box.</summary>
		[JsonProperty("prompt")]
		public string Prompt;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to type.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to show a password prompt that will not show the typed value.</summary>
		[JsonProperty("password")]
		public bool Password;

		/// <summary>Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>
		/// An optional function that will be called to validate input and to give a hint
		/// to the user.
		/// 
		/// `value` ── The current value of the input box.
		/// 
		/// `return` ── A human readable string which is presented as diagnostic message.
		/// Return `undefined`, `null`, or the empty string when 'value' is valid.
		/// </summary>
		[JsonIgnore]
		public Func<string, string> ValidateInput;

		/// <summary>For internal runtime use only.</summary>
		[JsonProperty("validateInput_AppzFuncId")]
		internal string ValidateInput_AppzFuncId;
	}

	/// <summary>Options to configure the behavior of the quick pick UI.</summary>
	public partial class QuickPickOptions {
		/// <summary>An optional flag to include the description when filtering the picks.</summary>
		[JsonProperty("matchOnDescription")]
		public bool MatchOnDescription;

		/// <summary>An optional flag to include the detail when filtering the picks.</summary>
		[JsonProperty("matchOnDetail")]
		public bool MatchOnDetail;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>An optional flag to make the picker accept multiple selections, if true the result is an array of picks.</summary>
		[JsonProperty("canPickMany")]
		public bool CanPickMany;

		/// <summary>An optional function that is invoked whenever an item is selected.</summary>
		[JsonIgnore]
		public Func<QuickPickItem, any> OnDidSelectItem;

		/// <summary>For internal runtime use only.</summary>
		[JsonProperty("onDidSelectItem_AppzFuncId")]
		internal string OnDidSelectItem_AppzFuncId;
	}

	/// <summary>
	/// Represents an item that can be selected from
	/// a list of items.
	/// </summary>
	public partial class QuickPickItem {
		/// <summary>A human readable string which is rendered prominent.</summary>
		[JsonProperty("label"), JsonRequired]
		public string Label;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("description")]
		public string Description;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("detail")]
		public string Detail;

		/// <summary>
		/// Optional flag indicating if this item is picked initially.
		/// (Only honored when the picker allows multiple selections.)
		/// </summary>
		[JsonProperty("picked")]
		public bool Picked;

		/// <summary>Always show this item.</summary>
		[JsonProperty("alwaysShow")]
		public bool AlwaysShow;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public dict My;
	}

	/// <summary>Options to configure the behaviour of a file save dialog.</summary>
	public partial class SaveDialogOptions {
		/// <summary>The resource the dialog shows when opened.</summary>
		[JsonProperty("defaultUri")]
		public string DefaultUri;

		/// <summary>A human-readable string for the save button.</summary>
		[JsonProperty("saveLabel")]
		public string SaveLabel;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// 
		/// ```ts
		/// 
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// 
		/// ```
		/// 
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>
	/// Options to configure the behaviour of a file open dialog.
	/// 
	/// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
	/// which enforces to open either files or folder, but *not both*.
	/// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
	/// and the editor then silently adjusts the options to select files.
	/// </summary>
	public partial class OpenDialogOptions {
		/// <summary>The resource the dialog shows when opened.</summary>
		[JsonProperty("defaultUri")]
		public string DefaultUri;

		/// <summary>A human-readable string for the open button.</summary>
		[JsonProperty("openLabel")]
		public string OpenLabel;

		/// <summary>Allow to select files, defaults to `true`.</summary>
		[JsonProperty("canSelectFiles")]
		public bool CanSelectFiles;

		/// <summary>Allow to select folders, defaults to `false`.</summary>
		[JsonProperty("canSelectFolders")]
		public bool CanSelectFolders;

		/// <summary>Allow to select many files or folders.</summary>
		[JsonProperty("canSelectMany")]
		public bool CanSelectMany;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// 
		/// ```ts
		/// 
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// 
		/// ```
		/// 
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>Options to configure the behaviour of the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) pick UI.</summary>
	public partial class WorkspaceFolderPickOptions {
		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;
	}

	/// <summary>
	/// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
	/// are equal which means there is no notion of an active or master workspace folder.
	/// </summary>
	public partial class WorkspaceFolder {
		/// <summary>
		/// The associated uri for this workspace folder.
		/// 
		/// *Note:* The [Uri](https://code.visualstudio.com/api/references/vscode-api#Uri)-type was intentionally chosen such that future releases of the editor can support
		/// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
		/// </summary>
		[JsonProperty("uri"), JsonRequired]
		public string Uri;

		/// <summary>
		/// The name of this workspace folder. Defaults to
		/// the basename of its [uri-path](https://code.visualstudio.com/api/references/vscode-api#Uri.path)
		/// </summary>
		[JsonProperty("name"), JsonRequired]
		public string Name;

		/// <summary>The ordinal number of this workspace folder.</summary>
		[JsonProperty("index"), JsonRequired]
		public int Index;
	}

	/// <summary>Represents the state of a window.</summary>
	public partial class WindowState {
		/// <summary>Whether the current window is focused.</summary>
		[JsonProperty("focused"), JsonRequired]
		public bool Focused;
	}

	/// <summary>
	/// A status bar item is a status bar contribution that can
	/// show text and icons and run a command on click.
	/// </summary>
	public partial class StatusBarItem {
		internal Disposable disp;
	}

	/// <summary>
	/// An output channel is a container for readonly textual information.
	/// 
	/// To get an instance of an `OutputChannel` use
	/// [createOutputChannel](https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel).
	/// </summary>
	public partial class OutputChannel {
		internal Disposable disp;
	}

	/// <summary>Represents rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).</summary>
	public partial class DecorationRenderOptions {
		/// <summary>
		/// Should the decoration be rendered also on the whitespace after the line text.
		/// Defaults to `false`.
		/// </summary>
		[JsonProperty("isWholeLine")]
		public bool IsWholeLine;

		/// <summary>
		/// Customize the growing behavior of the decoration when edits occur at the edges of the decoration's range.
		/// Defaults to `DecorationRangeBehavior.OpenOpen`.
		/// </summary>
		[JsonProperty("rangeBehavior")]
		public DecorationRangeBehavior? RangeBehavior;

		/// <summary>The position in the overview ruler where the decoration should be rendered.</summary>
		[JsonProperty("overviewRulerLane")]
		public OverviewRulerLane? OverviewRulerLane;

		/// <summary>Overwrite options for light themes.</summary>
		[JsonProperty("light")]
		public ThemableDecorationRenderOptions Light;

		/// <summary>Overwrite options for dark themes.</summary>
		[JsonProperty("dark")]
		public ThemableDecorationRenderOptions Dark;
	}

	/// <summary>Represents theme specific rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).</summary>
	public partial class ThemableDecorationRenderOptions {
		/// <summary>
		/// Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
		/// Alternatively a color from the color registry can be [referenced](https://code.visualstudio.com/api/references/vscode-api#ThemeColor).
		/// </summary>
		[JsonProperty("backgroundColor")]
		public string BackgroundColor;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("outline")]
		public string Outline;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// </summary>
		[JsonProperty("outlineColor")]
		public string OutlineColor;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// </summary>
		[JsonProperty("outlineStyle")]
		public string OutlineStyle;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'outline' for setting one or more of the individual outline properties.
		/// </summary>
		[JsonProperty("outlineWidth")]
		public string OutlineWidth;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("border")]
		public string Border;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// </summary>
		[JsonProperty("borderColor")]
		public string BorderColor;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// </summary>
		[JsonProperty("borderRadius")]
		public string BorderRadius;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// </summary>
		[JsonProperty("borderSpacing")]
		public string BorderSpacing;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// </summary>
		[JsonProperty("borderStyle")]
		public string BorderStyle;

		/// <summary>
		/// CSS styling property that will be applied to text enclosed by a decoration.
		/// Better use 'border' for setting one or more of the individual border properties.
		/// </summary>
		[JsonProperty("borderWidth")]
		public string BorderWidth;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("fontStyle")]
		public string FontStyle;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("fontWeight")]
		public string FontWeight;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("textDecoration")]
		public string TextDecoration;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("cursor")]
		public string Cursor;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("color")]
		public string Color;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("opacity")]
		public string Opacity;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("letterSpacing")]
		public string LetterSpacing;

		/// <summary>An **absolute path** or an URI to an image to be rendered in the gutter.</summary>
		[JsonProperty("gutterIconPath")]
		public string GutterIconPath;

		/// <summary>
		/// Specifies the size of the gutter icon.
		/// Available values are 'auto', 'contain', 'cover' and any percentage value.
		/// For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
		/// </summary>
		[JsonProperty("gutterIconSize")]
		public string GutterIconSize;

		/// <summary>The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.</summary>
		[JsonProperty("overviewRulerColor")]
		public string OverviewRulerColor;

		/// <summary>Defines the rendering options of the attachment that is inserted before the decorated text.</summary>
		[JsonProperty("before")]
		public ThemableDecorationAttachmentRenderOptions Before;

		/// <summary>Defines the rendering options of the attachment that is inserted after the decorated text.</summary>
		[JsonProperty("after")]
		public ThemableDecorationAttachmentRenderOptions After;
	}

	/// <summary>
	/// Type Definition for Visual Studio Code 1.39 Extension API
	/// See https://code.visualstudio.com/api for more information
	/// </summary>
	public partial class ThemableDecorationAttachmentRenderOptions {
		/// <summary>Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.</summary>
		[JsonProperty("contentText")]
		public string ContentText;

		/// <summary>
		/// An **absolute path** or an URI to an image to be rendered in the attachment. Either an icon
		/// or a text can be shown, but not both.
		/// </summary>
		[JsonProperty("contentIconPath")]
		public string ContentIconPath;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("border")]
		public string Border;

		/// <summary>CSS styling property that will be applied to text enclosed by a decoration.</summary>
		[JsonProperty("borderColor")]
		public string BorderColor;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("fontStyle")]
		public string FontStyle;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("fontWeight")]
		public string FontWeight;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("textDecoration")]
		public string TextDecoration;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("color")]
		public string Color;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("backgroundColor")]
		public string BackgroundColor;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("margin")]
		public string Margin;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("width")]
		public string Width;

		/// <summary>CSS styling property that will be applied to the decoration attachment.</summary>
		[JsonProperty("height")]
		public string Height;
	}

	/// <summary>
	/// Represents a handle to a set of decorations
	/// sharing the same [styling options](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions) in a [text editor](#TextEditor).
	/// 
	/// To get an instance of a `TextEditorDecorationType` use
	/// [createTextEditorDecorationType](https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType).
	/// </summary>
	public partial class TextEditorDecorationType {
		internal Disposable disp;
	}

	/// <summary>An event describing a change to the set of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders).</summary>
	public partial class WorkspaceFoldersChangeEvent {
		/// <summary>Added workspace folders.</summary>
		[JsonProperty("added"), JsonRequired]
		public WorkspaceFolder[] Added;

		/// <summary>Removed workspace folders.</summary>
		[JsonProperty("removed"), JsonRequired]
		public WorkspaceFolder[] Removed;
	}

	/// <summary>The event that is fired when diagnostics change.</summary>
	public partial class DiagnosticChangeEvent {
		/// <summary>An array of resources for which diagnostics have changed.</summary>
		[JsonProperty("uris"), JsonRequired]
		public string[] Uris;
	}

	/// <summary>Namespace describing the environment the editor runs in.</summary>
	public partial class EnvProperties {
		/// <summary>The application name of the editor, like 'VS Code'.</summary>
		[JsonProperty("appName")]
		public string AppName;

		/// <summary>The application root folder from which the editor is running.</summary>
		[JsonProperty("appRoot")]
		public string AppRoot;

		/// <summary>Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.</summary>
		[JsonProperty("language")]
		public string Language;

		/// <summary>A unique identifier for the computer.</summary>
		[JsonProperty("machineId")]
		public string MachineId;

		/// <summary>
		/// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
		/// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
		/// 
		/// *Note* that the value is `undefined` when there is no remote extension host but that the
		/// value is defined in all extension hosts (local and remote) in case a remote extension host
		/// exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
		/// a specific extension runs remote or not.
		/// </summary>
		[JsonProperty("remoteName")]
		public string RemoteName;

		/// <summary>
		/// A unique identifier for the current session.
		/// Changes each time the editor is started.
		/// </summary>
		[JsonProperty("sessionId")]
		public string SessionId;

		/// <summary>
		/// The detected default shell for the extension host, this is overridden by the
		/// `terminal.integrated.shell` setting for the extension host's platform.
		/// </summary>
		[JsonProperty("shell")]
		public string Shell;

		/// <summary>The custom uri scheme the editor registers to in the operating system.</summary>
		[JsonProperty("uriScheme")]
		public string UriScheme;
	}

	/// <summary>
	/// Namespace for dealing with the current workspace. A workspace is the representation
	/// of the folder that has been opened. There is no workspace when just a file but not a
	/// folder has been opened.
	/// 
	/// The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
	/// events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
	/// the editor-process so that they should be always used instead of nodejs-equivalents.
	/// </summary>
	public partial class WorkspaceProperties {
		/// <summary>
		/// The name of the workspace. `undefined` when no folder
		/// has been opened.
		/// </summary>
		[JsonProperty("name")]
		public string Name;

		/// <summary>
		/// The location of the workspace file, for example:
		/// 
		/// `file:///Users/name/Development/myProject.code-workspace`
		/// 
		/// or
		/// 
		/// `untitled:1555503116870`
		/// 
		/// for a workspace that is untitled and not yet saved.
		/// 
		/// Depending on the workspace that is opened, the value will be:
		///   * `undefined` when no workspace or  a single folder is opened
		///   * the path of the workspace file as `Uri` otherwise. if the workspace
		/// is untitled, the returned URI will use the `untitled:` scheme
		/// 
		/// The location can e.g. be used with the `vscode.openFolder` command to
		/// open the workspace again after it has been closed.
		/// 
		/// **Example:**
		/// 
		/// ```typescript
		/// 
		/// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
		/// 
		/// ```
		/// 
		/// 
		/// **Note:** it is not advised to use `workspace.workspaceFile` to write
		/// configuration data into the file. You can use `workspace.getConfiguration().update()`
		/// for that purpose which will work both when a single folder is opened as
		/// well as an untitled or saved workspace.
		/// </summary>
		[JsonProperty("workspaceFile")]
		public string WorkspaceFile;

		/// <summary>
		/// List of workspace folders or `undefined` when no folder is open.
		/// *Note* that the first entry corresponds to the value of `rootPath`.
		/// </summary>
		[JsonProperty("workspaceFolders")]
		public WorkspaceFolder[] WorkspaceFolders;
	}

	/// <summary>
	/// A status bar item is a status bar contribution that can
	/// show text and icons and run a command on click.
	/// </summary>
	public partial class StatusBarItemProperties {
		/// <summary>The alignment of this item.</summary>
		[JsonIgnore]
		public Func<StatusBarAlignment> Alignment;

		/// <summary>
		/// The priority of this item. Higher value means the item should
		/// be shown more to the left.
		/// </summary>
		[JsonIgnore]
		public Func<int> Priority;

		/// <summary>
		/// The text to show for the entry. You can embed icons in the text by leveraging the syntax:
		/// 
		/// `My text $(icon-name) contains icons like $(icon-name) this one.`
		/// 
		/// Where the icon-name is taken from the [octicon](https://octicons.github.com) icon set, e.g.
		/// `light-bulb`, `thumbsup`, `zap` etc.
		/// </summary>
		[JsonProperty("text")]
		public string Text;

		/// <summary>The tooltip text when you hover over this entry.</summary>
		[JsonProperty("tooltip")]
		public string Tooltip;

		/// <summary>The foreground color for this entry.</summary>
		[JsonProperty("color")]
		public string Color;

		/// <summary>
		/// The identifier of a command to run on click. The command must be
		/// [known](https://code.visualstudio.com/api/references/vscode-api#commands.getCommands).
		/// </summary>
		[JsonProperty("command")]
		public string Command;
	}

	/// <summary>
	/// An output channel is a container for readonly textual information.
	/// 
	/// To get an instance of an `OutputChannel` use
	/// [createOutputChannel](https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel).
	/// </summary>
	public partial class OutputChannelProperties {
		/// <summary>The human-readable name of this output channel.</summary>
		[JsonIgnore]
		public Func<string> Name;
	}

	/// <summary>
	/// Represents a handle to a set of decorations
	/// sharing the same [styling options](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions) in a [text editor](#TextEditor).
	/// 
	/// To get an instance of a `TextEditorDecorationType` use
	/// [createTextEditorDecorationType](https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType).
	/// </summary>
	public partial class TextEditorDecorationTypeProperties {
		/// <summary>Internal representation of the handle.</summary>
		[JsonIgnore]
		public Func<string> Key;
	}

	internal partial class impl : IVscode, IWindow, IEnv, IClipboard, IWorkspace, ILanguages, IExtensions, ICommands {

		IWindow IVscode.Window { get {
			return this;
		} }

		IEnv IVscode.Env { get {
			return this;
		} }

		IWorkspace IVscode.Workspace { get {
			return this;
		} }

		ILanguages IVscode.Languages { get {
			return this;
		} }

		IExtensions IVscode.Extensions { get {
			return this;
		} }

		ICommands IVscode.Commands { get {
			return this;
		} }

		Action<Action<string>> IWindow.ShowInformationMessage1(string message, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowInformationMessage2(string message, MessageOptions options, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<MessageItem>> IWindow.ShowInformationMessage3(string message, MessageItem[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<MessageItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				MessageItem result = default;
				if ((null != payload)) {
					result = new MessageItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<MessageItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<MessageItem>> IWindow.ShowInformationMessage4(string message, MessageOptions options, MessageItem[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<MessageItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				MessageItem result = default;
				if ((null != payload)) {
					result = new MessageItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<MessageItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowWarningMessage1(string message, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowWarningMessage2(string message, MessageOptions options, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<MessageItem>> IWindow.ShowWarningMessage3(string message, MessageItem[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<MessageItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				MessageItem result = default;
				if ((null != payload)) {
					result = new MessageItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<MessageItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<MessageItem>> IWindow.ShowWarningMessage4(string message, MessageOptions options, MessageItem[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<MessageItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				MessageItem result = default;
				if ((null != payload)) {
					result = new MessageItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<MessageItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowErrorMessage1(string message, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowErrorMessage2(string message, MessageOptions options, string[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<MessageItem>> IWindow.ShowErrorMessage3(string message, MessageItem[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<MessageItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				MessageItem result = default;
				if ((null != payload)) {
					result = new MessageItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<MessageItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<MessageItem>> IWindow.ShowErrorMessage4(string message, MessageOptions options, MessageItem[] items) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> onresp = default;
			Action<MessageItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				MessageItem result = default;
				if ((null != payload)) {
					result = new MessageItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<MessageItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowInputBox(InputBoxOptions options, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInputBox";
			msg.Data = new dict(2);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.ValidateInput_AppzFuncId = "";
				Func<string, string> fn = default;
				fn = options.ValidateInput;
				if ((null != fn)) {
					lock (this) {
						options.ValidateInput_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.ValidateInput_AppzFuncId);
						this.Impl().cbOther[options.ValidateInput_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								string __0 = default;
								if ((null != args[0])) {
									(__0, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
									if (!ok) {
										return (null, false);
									}
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			if ((null != options)) {
				msg.Data["options"] = options;
			}
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == onresp) || onresp(payload);
			});
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> IWindow.ShowQuickPick1(string[] items, QuickPickOptions options, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick1";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if (true) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			options.CanPickMany = true;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == onresp) || onresp(payload);
			});
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowQuickPick2(string[] items, QuickPickOptions options, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick2";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			if ((null != options)) {
				msg.Data["options"] = options;
			}
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == onresp) || onresp(payload);
			});
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<QuickPickItem[]>> IWindow.ShowQuickPick3(QuickPickItem[] items, QuickPickOptions options, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick3";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if (true) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			options.CanPickMany = true;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<QuickPickItem[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				QuickPickItem[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new QuickPickItem[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						QuickPickItem __val__result = default;
						__val__result = new QuickPickItem();
						ok = __val__result.populateFrom(__item__result);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == onresp) || onresp(payload);
			});
			return (Action<QuickPickItem[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<QuickPickItem>> IWindow.ShowQuickPick4(QuickPickItem[] items, QuickPickOptions options, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick4";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			if ((null != options)) {
				msg.Data["options"] = options;
			}
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<QuickPickItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				QuickPickItem result = default;
				if ((null != payload)) {
					result = new QuickPickItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == onresp) || onresp(payload);
			});
			return (Action<QuickPickItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IWindow.SetStatusBarMessage1(string text, int hideAfterTimeout) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.setStatusBarMessage1";
			msg.Data = new dict(2);
			msg.Data["text"] = text;
			msg.Data["hideAfterTimeout"] = hideAfterTimeout;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl()));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IWindow.SetStatusBarMessage2(string text) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.setStatusBarMessage2";
			msg.Data = new dict(1);
			msg.Data["text"] = text;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl()));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWindow.ShowSaveDialog(SaveDialogOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showSaveDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> IWindow.ShowOpenDialog(OpenDialogOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showOpenDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceFolder>> IWindow.ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWorkspaceFolderPick";
			msg.Data = new dict(1);
			if ((null != options)) {
				msg.Data["options"] = options;
			}
			Func<any, bool> onresp = default;
			Action<WorkspaceFolder> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceFolder result = default;
				if ((null != payload)) {
					result = new WorkspaceFolder();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceFolder> a0) => {
				onret = a0;
			};
		}

		Action<Action<WindowState>> IWindow.State() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.state";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<WindowState> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WindowState result = default;
				if ((null != payload)) {
					result = new WindowState();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WindowState> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IWindow.OnDidChangeWindowState(Action<WindowState> listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.onDidChangeWindowState";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IWindow.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				WindowState _a_0_ = default;
				_a_0_ = new WindowState();
				ok = _a_0_.populateFrom(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), _fnid_listener));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<StatusBarItem>> IWindow.CreateStatusBarItem(StatusBarAlignment? alignment, int? priority) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createStatusBarItem";
			msg.Data = new dict(2);
			if ((null != alignment)) {
				msg.Data["alignment"] = alignment;
			}
			if ((null != priority)) {
				msg.Data["priority"] = priority;
			}
			Func<any, bool> onresp = default;
			Action<StatusBarItem> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				StatusBarItem result = default;
				if ((null != payload)) {
					result = new StatusBarItem();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
					result.disp.impl = this.Impl();
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<StatusBarItem> a0) => {
				onret = a0;
			};
		}

		Action<Action<OutputChannel>> IWindow.CreateOutputChannel(string name) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createOutputChannel";
			msg.Data = new dict(1);
			msg.Data["name"] = name;
			Func<any, bool> onresp = default;
			Action<OutputChannel> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				OutputChannel result = default;
				if ((null != payload)) {
					result = new OutputChannel();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
					result.disp.impl = this.Impl();
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<OutputChannel> a0) => {
				onret = a0;
			};
		}

		Action<Action<TextEditorDecorationType>> IWindow.CreateTextEditorDecorationType(DecorationRenderOptions options) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createTextEditorDecorationType";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> onresp = default;
			Action<TextEditorDecorationType> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				TextEditorDecorationType result = default;
				if ((null != payload)) {
					result = new TextEditorDecorationType();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
					result.disp.impl = this.Impl();
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<TextEditorDecorationType> a0) => {
				onret = a0;
			};
		}

		Action<Action<bool>> IEnv.OpenExternal(string target) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.openExternal";
			msg.Data = new dict(1);
			msg.Data["target"] = target;
			Func<any, bool> onresp = default;
			Action<bool> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				bool result = default;
				if ((null != payload)) {
					(result, ok) = (payload is bool) ? (((bool)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<bool> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.AppName() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.appName";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.AppRoot() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.appRoot";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.Language() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.language";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.MachineId() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.machineId";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.RemoteName() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.remoteName";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.SessionId() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.sessionId";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.Shell() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.shell";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IEnv.UriScheme() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.uriScheme";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<EnvProperties>> IEnv.Properties() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.Properties";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<EnvProperties> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				EnvProperties result = default;
				if ((null != payload)) {
					result = new EnvProperties();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<EnvProperties> a0) => {
				onret = a0;
			};
		}

		IClipboard IEnv.Clipboard() {
			return this;
		}

		Action<Action<string>> IClipboard.ReadText() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "clipboard.readText";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action> IClipboard.WriteText(string value) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "clipboard.writeText";
			msg.Data = new dict(1);
			msg.Data["value"] = value;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWorkspace.Name() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.name";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWorkspace.WorkspaceFile() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.workspaceFile";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<bool>> IWorkspace.SaveAll(bool includeUntitled) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.saveAll";
			msg.Data = new dict(1);
			msg.Data["includeUntitled"] = includeUntitled;
			Func<any, bool> onresp = default;
			Action<bool> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				bool result = default;
				if ((null != payload)) {
					(result, ok) = (payload is bool) ? (((bool)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<bool> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IWorkspace.OnDidChangeWorkspaceFolders(Action<WorkspaceFoldersChangeEvent> listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.onDidChangeWorkspaceFolders";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IWorkspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				WorkspaceFoldersChangeEvent _a_0_ = default;
				_a_0_ = new WorkspaceFoldersChangeEvent();
				ok = _a_0_.populateFrom(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), _fnid_listener));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceFolder>> IWorkspace.GetWorkspaceFolder(string uri) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.getWorkspaceFolder";
			msg.Data = new dict(1);
			msg.Data["uri"] = uri;
			Func<any, bool> onresp = default;
			Action<WorkspaceFolder> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceFolder result = default;
				if ((null != payload)) {
					result = new WorkspaceFolder();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceFolder> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceFolder[]>> IWorkspace.WorkspaceFolders() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.workspaceFolders";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<WorkspaceFolder[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceFolder[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new WorkspaceFolder[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						WorkspaceFolder __val__result = default;
						__val__result = new WorkspaceFolder();
						ok = __val__result.populateFrom(__item__result);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceFolder[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> IWorkspace.FindFiles(string include, string exclude, int? maxResults, Cancel token) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.findFiles";
			msg.Data = new dict(4);
			msg.Data["include"] = include;
			if ((null != exclude)) {
				msg.Data["exclude"] = exclude;
			}
			if ((null != maxResults)) {
				msg.Data["maxResults"] = maxResults;
			}
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<string>> IWorkspace.AsRelativePath(string pathOrUri, bool includeWorkspaceFolder) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.asRelativePath";
			msg.Data = new dict(2);
			msg.Data["pathOrUri"] = pathOrUri;
			msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder;
			Func<any, bool> onresp = default;
			Action<string> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string result = default;
				if ((null != payload)) {
					string _result_ = default;
					(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = _result_;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string> a0) => {
				onret = a0;
			};
		}

		Action<Action<WorkspaceProperties>> IWorkspace.Properties() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.Properties";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<WorkspaceProperties> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				WorkspaceProperties result = default;
				if ((null != payload)) {
					result = new WorkspaceProperties();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<WorkspaceProperties> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> ILanguages.GetLanguages() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "languages.getLanguages";
			msg.Data = new dict(0);
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> ILanguages.OnDidChangeDiagnostics(Action<DiagnosticChangeEvent> listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "languages.onDidChangeDiagnostics";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "ILanguages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				DiagnosticChangeEvent _a_0_ = default;
				_a_0_ = new DiagnosticChangeEvent();
				ok = _a_0_.populateFrom(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), _fnid_listener));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> IExtensions.OnDidChange(Action listener) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "extensions.onDidChange";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IExtensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (0 != args.Length) {
					return ok;
				}
				listener();
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), _fnid_listener));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<Disposable>> ICommands.RegisterCommand(string command, Func<any[], any> callback) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.registerCommand";
			msg.Data = new dict(2);
			msg.Data["command"] = command;
			string _fnid_callback = default;
			if ((null == callback)) {
				OnError(this.Impl(), "ICommands.RegisterCommand: the 'callback' arg (which is not optional but required) was not passed by the caller", null);
				return null;
			}
			_fnid_callback = this.Impl().nextSub(null, (any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return (null, ok);
				}
				any ret = default;
				any[] _a_0_ = default;
				(_a_0_, ok) = (args[0] is any[]) ? (((any[])(args[0])), true) : (default, false);
				if (!ok) {
					return (null, false);
				}
				ret = callback(_a_0_);
				return (ret, true);
			});
			msg.Data["callback"] = _fnid_callback;
			Func<any, bool> onresp = default;
			Action<Disposable> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				Disposable result = default;
				if ((null != payload)) {
					result = new Disposable();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				} else {
					return false;
				}
				if ((null != onret)) {
					onret(result.bind(this.Impl(), _fnid_callback));
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<Disposable> a0) => {
				onret = a0;
			};
		}

		Action<Action<any>> ICommands.ExecuteCommand(string command, any[] rest) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.executeCommand";
			msg.Data = new dict(2);
			msg.Data["command"] = command;
			msg.Data["rest"] = rest;
			Func<any, bool> onresp = default;
			Action<any> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				any result = default;
				if ((null != payload)) {
					(result, ok) = (payload, true);
					if (ok) {
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<any> a0) => {
				onret = a0;
			};
		}

		Action<Action<string[]>> ICommands.GetCommands(bool filterInternal) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.getCommands";
			msg.Data = new dict(1);
			msg.Data["filterInternal"] = filterInternal;
			Func<any, bool> onresp = default;
			Action<string[]> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				string[] result = default;
				if ((null != payload)) {
					any[] __coll__result = default;
					(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
					if (!ok) {
						return false;
					}
					result = new string[__coll__result.Length];
					int __idx__result = default;
					__idx__result = 0;
					foreach (var __item__result in __coll__result) {
						string __val__result = default;
						(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result[__idx__result] = __val__result;
						__idx__result = __idx__result + 1;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.Impl().send(msg, onresp);
			return (Action<string[]> a0) => {
				onret = a0;
			};
		}

	}

	public partial class StatusBarItem {
		/// <summary>Shows the entry in the status bar.</summary>
		public Action<Action> Show() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.show";
			msg.Data = new dict(1);
			msg.Data[""] = this.disp.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class StatusBarItem {
		/// <summary>Hide the entry in the status bar.</summary>
		public Action<Action> Hide() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.hide";
			msg.Data = new dict(1);
			msg.Data[""] = this.disp.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class StatusBarItem : IDisposable {
		/// <summary>
		/// Dispose and free associated resources. Call
		/// [hide](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.hide).
		/// </summary>
		public Action<Action> Dispose() {
			return this.disp.Dispose();
		}
		void IDisposable.Dispose() { this.Dispose(); }
	}

	public partial class StatusBarItem {
		/// <summary>Obtains this `StatusBarItem`'s current property values for: `alignment`, `priority`, `text`, `tooltip`, `color`, `command`.</summary>
		public Action<Action<StatusBarItemProperties>> Get() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.appzObjPropsGet";
			msg.Data = new dict(1);
			msg.Data[""] = this.disp.id;
			Func<any, bool> onresp = default;
			Action<StatusBarItemProperties> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				StatusBarItemProperties result = default;
				if ((null != payload)) {
					result = new StatusBarItemProperties();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action<StatusBarItemProperties> a0) => {
				onret = a0;
			};
		}
	}

	public partial class StatusBarItem {
		/// <summary>Updates this `StatusBarItem`'s current property values for: `text`, `tooltip`, `color`, `command`.</summary>
		public Action<Action> Set(StatusBarItemProperties allUpdates = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "StatusBarItem.appzObjPropsSet";
			msg.Data = new dict(2);
			msg.Data[""] = this.disp.id;
			msg.Data["allUpdates"] = allUpdates;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Append the given value to the channel.
		/// 
		/// `value` ── A string, falsy values will not be printed.
		/// </summary>
		/// <param name="value">A string, falsy values will not be printed.</param>
		public Action<Action> Append(string value = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.append";
			msg.Data = new dict(2);
			msg.Data[""] = this.disp.id;
			msg.Data["value"] = value;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Append the given value and a line feed character
		/// to the channel.
		/// 
		/// `value` ── A string, falsy values will be printed.
		/// </summary>
		/// <param name="value">A string, falsy values will be printed.</param>
		public Action<Action> AppendLine(string value = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.appendLine";
			msg.Data = new dict(2);
			msg.Data[""] = this.disp.id;
			msg.Data["value"] = value;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>Removes all output from the channel.</summary>
		public Action<Action> Clear() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.clear";
			msg.Data = new dict(1);
			msg.Data[""] = this.disp.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>
		/// Reveal this channel in the UI.
		/// 
		/// `preserveFocus` ── When `true` the channel will not take focus.
		/// </summary>
		/// <param name="preserveFocus">When `true` the channel will not take focus.</param>
		public Action<Action> Show(bool preserveFocus = default) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.show";
			msg.Data = new dict(2);
			msg.Data[""] = this.disp.id;
			msg.Data["preserveFocus"] = preserveFocus;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel {
		/// <summary>Hide this channel from the UI.</summary>
		public Action<Action> Hide() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.hide";
			msg.Data = new dict(1);
			msg.Data[""] = this.disp.id;
			Func<any, bool> onresp = default;
			Action onret = default;
			onresp = (any payload) => {
				if ((null != payload)) {
					return false;
				}
				if ((null != onret)) {
					onret();
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action a0) => {
				onret = a0;
			};
		}
	}

	public partial class OutputChannel : IDisposable {
		/// <summary>Dispose and free associated resources.</summary>
		public Action<Action> Dispose() {
			return this.disp.Dispose();
		}
		void IDisposable.Dispose() { this.Dispose(); }
	}

	public partial class OutputChannel {
		/// <summary>Obtains this `OutputChannel`'s current property value for: `name`.</summary>
		public Action<Action<OutputChannelProperties>> Get() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "OutputChannel.appzObjPropsGet";
			msg.Data = new dict(1);
			msg.Data[""] = this.disp.id;
			Func<any, bool> onresp = default;
			Action<OutputChannelProperties> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				OutputChannelProperties result = default;
				if ((null != payload)) {
					result = new OutputChannelProperties();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action<OutputChannelProperties> a0) => {
				onret = a0;
			};
		}
	}

	public partial class TextEditorDecorationType : IDisposable {
		/// <summary>Remove this decoration type and all decorations on all text editors using it.</summary>
		public Action<Action> Dispose() {
			return this.disp.Dispose();
		}
		void IDisposable.Dispose() { this.Dispose(); }
	}

	public partial class TextEditorDecorationType {
		/// <summary>Obtains this `TextEditorDecorationType`'s current property value for: `key`.</summary>
		public Action<Action<TextEditorDecorationTypeProperties>> Get() {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "TextEditorDecorationType.appzObjPropsGet";
			msg.Data = new dict(1);
			msg.Data[""] = this.disp.id;
			Func<any, bool> onresp = default;
			Action<TextEditorDecorationTypeProperties> onret = default;
			onresp = (any payload) => {
				bool ok = default;
				TextEditorDecorationTypeProperties result = default;
				if ((null != payload)) {
					result = new TextEditorDecorationTypeProperties();
					ok = result.populateFrom(payload);
					if (!ok) {
						return false;
					}
				}
				if ((null != onret)) {
					onret(result);
				}
				return true;
			};
			this.disp.impl.send(msg, onresp);
			return (Action<TextEditorDecorationTypeProperties> a0) => {
				onret = a0;
			};
		}
	}

	public partial class MessageItem {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("title", out var __) ? (__, true) : (default, false));
			if (ok) {
				string title = default;
				if ((null != val)) {
					(title, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Title = title;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("isCloseAffordance", out var ___) ? (___, true) : (default, false));
			if (ok) {
				bool isCloseAffordance = default;
				if ((null != val)) {
					(isCloseAffordance, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.IsCloseAffordance = isCloseAffordance;
			}
			(val, ok) = (it.TryGetValue("my", out var ____) ? (____, true) : (default, false));
			if (ok) {
				dict my = default;
				if ((null != val)) {
					(my, ok) = (val is dict) ? (((dict)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.My = my;
			}
			return true;
		}
	}

	public partial class QuickPickItem {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("label", out var __) ? (__, true) : (default, false));
			if (ok) {
				string label = default;
				if ((null != val)) {
					(label, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Label = label;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("description", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string description = default;
				if ((null != val)) {
					string _description_ = default;
					(_description_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					description = _description_;
				}
				this.Description = description;
			}
			(val, ok) = (it.TryGetValue("detail", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string detail = default;
				if ((null != val)) {
					string _detail_ = default;
					(_detail_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					detail = _detail_;
				}
				this.Detail = detail;
			}
			(val, ok) = (it.TryGetValue("picked", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				bool picked = default;
				if ((null != val)) {
					(picked, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Picked = picked;
			}
			(val, ok) = (it.TryGetValue("alwaysShow", out var ______) ? (______, true) : (default, false));
			if (ok) {
				bool alwaysShow = default;
				if ((null != val)) {
					(alwaysShow, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.AlwaysShow = alwaysShow;
			}
			(val, ok) = (it.TryGetValue("my", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				dict my = default;
				if ((null != val)) {
					(my, ok) = (val is dict) ? (((dict)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.My = my;
			}
			return true;
		}
	}

	public partial class WorkspaceFolder {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("uri", out var __) ? (__, true) : (default, false));
			if (ok) {
				string uri = default;
				if ((null != val)) {
					(uri, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Uri = uri;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					(name, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Name = name;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("index", out var ____) ? (____, true) : (default, false));
			if (ok) {
				int index = default;
				if ((null != val)) {
					(index, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						double __index__ = default;
						(__index__, ok) = (val is double) ? (((double)(val)), true) : (default, false);
						if (!ok) {
							return false;
						}
						index = ((int)(__index__));
					}
				}
				this.Index = index;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class WindowState {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("focused", out var __) ? (__, true) : (default, false));
			if (ok) {
				bool focused = default;
				if ((null != val)) {
					(focused, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Focused = focused;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class StatusBarItem {
		internal bool populateFrom(any payload = default) {
			bool ok = default;
			this.disp = new Disposable();
			ok = this.disp.populateFrom(payload);
			return ok;
		}
	}

	public partial class OutputChannel {
		internal bool populateFrom(any payload = default) {
			bool ok = default;
			this.disp = new Disposable();
			ok = this.disp.populateFrom(payload);
			return ok;
		}
	}

	public partial class TextEditorDecorationType {
		internal bool populateFrom(any payload = default) {
			bool ok = default;
			this.disp = new Disposable();
			ok = this.disp.populateFrom(payload);
			return ok;
		}
	}

	public partial class EnvProperties {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("appName", out var __) ? (__, true) : (default, false));
			if (ok) {
				string appName = default;
				if ((null != val)) {
					string _appName_ = default;
					(_appName_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					appName = _appName_;
				}
				this.AppName = appName;
			}
			(val, ok) = (it.TryGetValue("appRoot", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string appRoot = default;
				if ((null != val)) {
					string _appRoot_ = default;
					(_appRoot_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					appRoot = _appRoot_;
				}
				this.AppRoot = appRoot;
			}
			(val, ok) = (it.TryGetValue("language", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string language = default;
				if ((null != val)) {
					string _language_ = default;
					(_language_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					language = _language_;
				}
				this.Language = language;
			}
			(val, ok) = (it.TryGetValue("machineId", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				string machineId = default;
				if ((null != val)) {
					string _machineId_ = default;
					(_machineId_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					machineId = _machineId_;
				}
				this.MachineId = machineId;
			}
			(val, ok) = (it.TryGetValue("remoteName", out var ______) ? (______, true) : (default, false));
			if (ok) {
				string remoteName = default;
				if ((null != val)) {
					string _remoteName_ = default;
					(_remoteName_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					remoteName = _remoteName_;
				}
				this.RemoteName = remoteName;
			}
			(val, ok) = (it.TryGetValue("sessionId", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				string sessionId = default;
				if ((null != val)) {
					string _sessionId_ = default;
					(_sessionId_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					sessionId = _sessionId_;
				}
				this.SessionId = sessionId;
			}
			(val, ok) = (it.TryGetValue("shell", out var ________) ? (________, true) : (default, false));
			if (ok) {
				string shell = default;
				if ((null != val)) {
					string _shell_ = default;
					(_shell_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					shell = _shell_;
				}
				this.Shell = shell;
			}
			(val, ok) = (it.TryGetValue("uriScheme", out var _________) ? (_________, true) : (default, false));
			if (ok) {
				string uriScheme = default;
				if ((null != val)) {
					string _uriScheme_ = default;
					(_uriScheme_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					uriScheme = _uriScheme_;
				}
				this.UriScheme = uriScheme;
			}
			return true;
		}
	}

	public partial class WorkspaceFoldersChangeEvent {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("added", out var __) ? (__, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] added = default;
				if ((null != val)) {
					any[] __coll__added = default;
					(__coll__added, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					added = new WorkspaceFolder[__coll__added.Length];
					int __idx__added = default;
					__idx__added = 0;
					foreach (var __item__added in __coll__added) {
						WorkspaceFolder __val__added = default;
						__val__added = new WorkspaceFolder();
						ok = __val__added.populateFrom(__item__added);
						if (!ok) {
							return false;
						}
						added[__idx__added] = __val__added;
						__idx__added = __idx__added + 1;
					}
				}
				this.Added = added;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("removed", out var ___) ? (___, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] removed = default;
				if ((null != val)) {
					any[] __coll__removed = default;
					(__coll__removed, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					removed = new WorkspaceFolder[__coll__removed.Length];
					int __idx__removed = default;
					__idx__removed = 0;
					foreach (var __item__removed in __coll__removed) {
						WorkspaceFolder __val__removed = default;
						__val__removed = new WorkspaceFolder();
						ok = __val__removed.populateFrom(__item__removed);
						if (!ok) {
							return false;
						}
						removed[__idx__removed] = __val__removed;
						__idx__removed = __idx__removed + 1;
					}
				}
				this.Removed = removed;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class WorkspaceProperties {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var __) ? (__, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					string _name_ = default;
					(_name_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					name = _name_;
				}
				this.Name = name;
			}
			(val, ok) = (it.TryGetValue("workspaceFile", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string workspaceFile = default;
				if ((null != val)) {
					string _workspaceFile_ = default;
					(_workspaceFile_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					workspaceFile = _workspaceFile_;
				}
				this.WorkspaceFile = workspaceFile;
			}
			(val, ok) = (it.TryGetValue("workspaceFolders", out var ____) ? (____, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] workspaceFolders = default;
				if ((null != val)) {
					any[] __coll__workspaceFolders = default;
					(__coll__workspaceFolders, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					workspaceFolders = new WorkspaceFolder[__coll__workspaceFolders.Length];
					int __idx__workspaceFolders = default;
					__idx__workspaceFolders = 0;
					foreach (var __item__workspaceFolders in __coll__workspaceFolders) {
						WorkspaceFolder __val__workspaceFolders = default;
						__val__workspaceFolders = new WorkspaceFolder();
						ok = __val__workspaceFolders.populateFrom(__item__workspaceFolders);
						if (!ok) {
							return false;
						}
						workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders;
						__idx__workspaceFolders = __idx__workspaceFolders + 1;
					}
				}
				this.WorkspaceFolders = workspaceFolders;
			}
			return true;
		}
	}

	public partial class DiagnosticChangeEvent {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("uris", out var __) ? (__, true) : (default, false));
			if (ok) {
				string[] uris = default;
				if ((null != val)) {
					any[] __coll__uris = default;
					(__coll__uris, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					uris = new string[__coll__uris.Length];
					int __idx__uris = default;
					__idx__uris = 0;
					foreach (var __item__uris in __coll__uris) {
						string __val__uris = default;
						(__val__uris, ok) = (__item__uris is string) ? (((string)(__item__uris)), true) : (default, false);
						if (!ok) {
							return false;
						}
						uris[__idx__uris] = __val__uris;
						__idx__uris = __idx__uris + 1;
					}
				}
				this.Uris = uris;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class StatusBarItemProperties {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("alignment", out var __) ? (__, true) : (default, false));
			if (ok) {
				StatusBarAlignment alignment = default;
				if ((null != val)) {
					int i_alignment = default;
					(i_alignment, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						double __i_alignment__ = default;
						(__i_alignment__, ok) = (val is double) ? (((double)(val)), true) : (default, false);
						if (!ok) {
							return false;
						}
						i_alignment = ((int)(__i_alignment__));
					}
					alignment = ((StatusBarAlignment)(i_alignment));
				}
				this.Alignment = () => {
					return alignment;
				};
			}
			(val, ok) = (it.TryGetValue("priority", out var ___) ? (___, true) : (default, false));
			if (ok) {
				int priority = default;
				if ((null != val)) {
					(priority, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						double __priority__ = default;
						(__priority__, ok) = (val is double) ? (((double)(val)), true) : (default, false);
						if (!ok) {
							return false;
						}
						priority = ((int)(__priority__));
					}
				}
				this.Priority = () => {
					return priority;
				};
			}
			(val, ok) = (it.TryGetValue("text", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string text = default;
				if ((null != val)) {
					(text, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Text = text;
			}
			(val, ok) = (it.TryGetValue("tooltip", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				string tooltip = default;
				if ((null != val)) {
					(tooltip, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Tooltip = tooltip;
			}
			(val, ok) = (it.TryGetValue("color", out var ______) ? (______, true) : (default, false));
			if (ok) {
				string color = default;
				if ((null != val)) {
					(color, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Color = color;
			}
			(val, ok) = (it.TryGetValue("command", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				string command = default;
				if ((null != val)) {
					(command, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Command = command;
			}
			return true;
		}
	}

	public partial class OutputChannelProperties {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var __) ? (__, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					(name, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Name = () => {
					return name;
				};
			}
			return true;
		}
	}

	public partial class TextEditorDecorationTypeProperties {
		internal bool populateFrom(any payload = default) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("key", out var __) ? (__, true) : (default, false));
			if (ok) {
				string key = default;
				if ((null != val)) {
					(key, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Key = () => {
					return key;
				};
			}
			return true;
		}
	}

}
