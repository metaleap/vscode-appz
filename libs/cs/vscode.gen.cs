//DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-csharp.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
namespace VscAppz {
	using System;
	using System.Collections.Generic;
	using Newtonsoft.Json;

	using Any = System.Object;
	using Dict = System.Collections.Generic.Dictionary<string, object>;

	/// <summary>Additional metadata about the type of a diagnostic.</summary>
	public enum DiagnosticTag {
		/// <summary>
		/// Unused or unnecessary code.
		/// 
		/// Diagnostics with this tag are rendered faded out. The amount of fading
		/// is controlled by the `"editorUnnecessaryCode.opacity"` theme color. For
		/// example, `"editorUnnecessaryCode.opacity": "#000000c0"` will render the
		/// code with 75% opacity. For high contrast themes, use the
		/// `"editorUnnecessaryCode.border"` theme color to underline unnecessary code
		/// instead of fading it out.
		/// </summary>
		Unnecessary = 1,

		/// <summary>
		/// Deprecated or obsolete code.
		/// 
		/// Diagnostics with this tag are rendered with a strike through.
		/// </summary>
		Deprecated = 2,
	}

	/// <summary>Represents the severity of diagnostics.</summary>
	public enum DiagnosticSeverity {
		/// <summary>Something not allowed by the rules of a language or other means.</summary>
		Error = 0,

		/// <summary>Something suspicious but allowed.</summary>
		Warning = 1,

		/// <summary>Something to inform about but not a problem.</summary>
		Information = 2,

		/// <summary>
		/// Something to hint to a better way of doing it, like proposing
		/// a refactoring.
		/// </summary>
		Hint = 3,
	}

	/// <summary>
	/// Type Definition for Visual Studio Code 1.38 Extension API
	/// See https://code.visualstudio.com/api for more information
	/// </summary>
	public interface IVscode {
		/// <summary>
		/// Namespace for dealing with the current window of the editor. That is visible
		/// and active editors, as well as, UI elements to show messages, selections, and
		/// asking for user input.
		/// </summary>
		IWindow Window { get; }
	}

	/// <summary>
	/// Namespace for dealing with the current window of the editor. That is visible
	/// and active editors, as well as, UI elements to show messages, selections, and
	/// asking for user input.
	/// </summary>
	public interface IWindow {
		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Opens an input box to ask the user for input.
		/// 
		/// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
		/// returned value will be the string typed by the user or an empty string if the user did not type
		/// anything but dismissed the input box with OK.
		/// 
		/// `options` ── Configures the behavior of the input box.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
		/// </summary>
		/// <param name="options">Configures the behavior of the input box.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to a string the user provided or to `undefined` in case of dismissal.</param>
		void ShowInputBox(InputBoxOptions options = default, Action<string> andThen = default);
	}

	/// <summary>Options to configure the behavior of the message.</summary>
	public partial class MessageOptions {
		/// <summary>Indicates that this message should be modal.</summary>
		[JsonProperty("modal")]
		public bool Modal;
	}

	/// <summary>
	/// Represents an action that is shown with an information, warning, or
	/// error message.
	/// </summary>
	public partial class MessageItem {
		/// <summary>A short title like 'Retry', 'Open Log' etc.</summary>
		[JsonProperty("title"), JsonRequired]
		public string Title;

		/// <summary>
		/// A hint for modal dialogs that the item should be triggered
		/// when the user cancels the dialog (e.g. by pressing the ESC
		/// key).
		/// 
		/// Note: this option is ignored for non-modal messages.
		/// </summary>
		[JsonProperty("isCloseAffordance")]
		public bool IsCloseAffordance;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public Dict My;
	}

	/// <summary>Options to configure the behavior of the input box UI.</summary>
	public partial class InputBoxOptions {
		/// <summary>The value to prefill in the input box.</summary>
		[JsonProperty("value")]
		public string Value;

		/// <summary>
		/// Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
		/// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
		/// word will be selected, when empty (start equals end) only the cursor will be set,
		/// otherwise the defined range will be selected.
		/// </summary>
		[JsonProperty("valueSelection"), JsonConverter(typeof(json.valueTuples))]
		public (int, int)? ValueSelection;

		/// <summary>The text to display underneath the input box.</summary>
		[JsonProperty("prompt")]
		public string Prompt;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to type.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to show a password prompt that will not show the typed value.</summary>
		[JsonProperty("password")]
		public bool Password;

		/// <summary>Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>
		/// An optional function that will be called to validate input and to give a hint
		/// to the user.
		/// 
		/// `value` ── The current value of the input box.
		/// 
		/// `return` ── A human readable string which is presented as diagnostic message.
		/// Return `undefined`, `null`, or the empty string when 'value' is valid.
		/// </summary>
		[JsonIgnore]
		public Func<string, string> ValidateInput;

		/// <summary>For internal runtime use only.</summary>
		[JsonProperty("validateInput_AppzFuncId")]
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public string ValidateInput_AppzFuncId;
	}

	internal partial class impl : IVscode, IWindow {

		IWindow IVscode.Window { get {
			return this;
		} }

		void IWindow.ShowErrorMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage1";
			msg.Data = new Dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage2";
			msg.Data = new Dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage3";
			msg.Data = new Dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage4";
			msg.Data = new Dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage1";
			msg.Data = new Dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage2";
			msg.Data = new Dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage3";
			msg.Data = new Dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage4";
			msg.Data = new Dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage1";
			msg.Data = new Dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage2";
			msg.Data = new Dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage3";
			msg.Data = new Dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage4";
			msg.Data = new Dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, on);
		}

		void IWindow.ShowInputBox(InputBoxOptions options, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInputBox";
			msg.Data = new Dict(1);
			List<string> fnids = default;
			fnids = new List<string>(1);
			lock (this) {
				if ((null != options)) {
					options.ValidateInput_AppzFuncId = "";
					Func<string, string> fn = default;
					fn = options.ValidateInput;
					if ((null != fn)) {
						options.ValidateInput_AppzFuncId = this.nextFuncId();
						fnids.Add(options.ValidateInput_AppzFuncId);
						this.cbOther[options.ValidateInput_AppzFuncId] = (Any[] args) => {
							if ((1 != args.Length)) {
								return (null, false);
							} else {
								bool ok = default;
								string __0 = default;
								if ((null != args[0])) {
									(__0, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
									if ((!ok)) {
										return (null, false);
									}
								}
								return (fn(__0), true);
							}							
						};
					}
				}
			}
			msg.Data["options"] = options;
			Func<Any, bool> on = default;
			if ((null != andThen)) {
				on = (Any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if ((!ok)) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.send(msg, (Any payload) => {
				if ((fnids.Count != 0)) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.cbOther.Remove(fnid);
						}
					}
				}
				return ((null == on) || on(payload));
			});
		}

	}

	public partial class MessageItem {
		internal bool populateFrom(Any payload) {
			Dict dict = default;
			bool ok = default;
			Any val = default;
			(dict, ok) = (payload is Dict) ? (((Dict)(payload)), true) : (default, false);
			if ((!ok)) {
				return false;
			}
			(val, ok) = (dict.TryGetValue("title", out var __) ? (__, true) : (default, false));
			if (ok) {
				string title = default;
				(title, ok) = (null == val) ? (default, true) : (val is string) ? (((string)(val)), true) : (default, false);
				if ((!ok)) {
					return false;
				}
				this.Title = title;
			} else {
				return false;
			}			
			(val, ok) = (dict.TryGetValue("isCloseAffordance", out var ___) ? (___, true) : (default, false));
			if (ok) {
				bool isCloseAffordance = default;
				(isCloseAffordance, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
				if ((!ok)) {
					return false;
				}
				this.IsCloseAffordance = isCloseAffordance;
			}
			(val, ok) = (dict.TryGetValue("my", out var ____) ? (____, true) : (default, false));
			if (ok) {
				Dict my = default;
				(my, ok) = (null == val) ? (default, true) : (val is Dict) ? (((Dict)(val)), true) : (default, false);
				if ((!ok)) {
					return false;
				}
				this.My = my;
			}
			return true;
		}
	}

}
