// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-csharp.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
namespace VscAppz {
	using System;
	using System.Collections.Generic;
	using Newtonsoft.Json;
	using any = System.Object;
	using dict = System.Collections.Generic.Dictionary<string, object>;

	/// <summary>Represents the alignment of status bar items.</summary>
	public enum StatusBarAlignment {
		/// <summary>Aligned to the left side.</summary>
		Left = 1,

		/// <summary>Aligned to the right side.</summary>
		Right = 2,
	}

	/// <summary>
	/// Type Definition for Visual Studio Code 1.38 Extension API
	/// See https://code.visualstudio.com/api for more information
	/// </summary>
	public interface IVscode {
		/// <summary>
		/// Namespace for dealing with the current window of the editor. That is visible
		/// and active editors, as well as, UI elements to show messages, selections, and
		/// asking for user input.
		/// </summary>
		IWindow Window { get; }

		/// <summary>Namespace describing the environment the editor runs in.</summary>
		IEnv Env { get; }

		/// <summary>
		/// Namespace for dealing with the current workspace. A workspace is the representation
		/// of the folder that has been opened. There is no workspace when just a file but not a
		/// folder has been opened.
		/// 
		/// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
		/// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
		/// the editor-process so that they should be always used instead of nodejs-equivalents.
		/// </summary>
		IWorkspace Workspace { get; }

		/// <summary>
		/// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
		/// like IntelliSense, code actions, diagnostics etc.
		/// 
		/// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
		/// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
		/// programming languages.
		/// 
		/// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
		/// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
		/// that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
		/// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
		/// 
		/// ```javascript
		/// languages.registerHoverProvider('javascript', {
		///  	provideHover(document, position, token) {
		///  		return new Hover('I am a hover!');
		///  	}
		/// });
		/// ```
		/// 
		/// Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
		/// a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
		/// a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
		/// scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
		/// the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
		/// score is used for determining the order in which providers are asked to participate.
		/// </summary>
		ILanguages Languages { get; }

		/// <summary>
		/// Namespace for dealing with installed extensions. Extensions are represented
		/// by an [extension](#Extension)-interface which enables reflection on them.
		/// 
		/// Extension writers can provide APIs to other extensions by returning their API public
		/// surface from the `activate`-call.
		/// 
		/// ```javascript
		/// export function activate(context: vscode.ExtensionContext) {
		///  	let api = {
		///  		sum(a, b) {
		///  			return a + b;
		///  		},
		///  		mul(a, b) {
		///  			return a * b;
		///  		}
		///  	};
		///  	// 'export' public api-surface
		///  	return api;
		/// }
		/// ```
		/// When depending on the API of another extension add an `extensionDependency`-entry
		/// to `package.json`, and use the [getExtension](#extensions.getExtension)-function
		/// and the [exports](#Extension.exports)-property, like below:
		/// 
		/// ```javascript
		/// let mathExt = extensions.getExtension('genius.math');
		/// let importedApi = mathExt.exports;
		/// 
		/// console.log(importedApi.mul(42, 1));
		/// ```
		/// </summary>
		IExtensions Extensions { get; }

		/// <summary>
		/// Namespace for dealing with commands. In short, a command is a function with a
		/// unique identifier. The function is sometimes also called _command handler_.
		/// 
		/// Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
		/// and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
		/// can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
		/// 
		/// * palette - Use the `commands`-section in `package.json` to make a command show in
		/// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
		/// * keybinding - Use the `keybindings`-section in `package.json` to enable
		/// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
		/// for your extension.
		/// 
		/// Commands from other extensions and from the editor itself are accessible to an extension. However,
		/// when invoking an editor command not all argument types are supported.
		/// 
		/// This is a sample that registers a command handler and adds an entry for that command to the palette. First
		/// register a command handler with the identifier `extension.sayHello`.
		/// ```javascript
		/// commands.registerCommand('extension.sayHello', () => {
		///  	window.showInformationMessage('Hello World!');
		/// });
		/// ```
		/// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
		/// ```json
		/// {
		///  	"contributes": {
		///  		"commands": [{
		///  			"command": "extension.sayHello",
		///  			"title": "Hello World"
		///  		}]
		///  	}
		/// }
		/// ```
		/// </summary>
		ICommands Commands { get; }
	}

	/// <summary>
	/// Namespace for dealing with the current window of the editor. That is visible
	/// and active editors, as well as, UI elements to show messages, selections, and
	/// asking for user input.
	/// </summary>
	public interface IWindow {
		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an information message to users. Optionally provide an array of items which will be presented as
		/// clickable buttons.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an information message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowInformationMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show a warning message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowWarningMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageOptions options = default, string[] items = default, Action<string> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Show an error message.
		/// 
		/// `message` ── The message to show.
		/// 
		/// `options` ── Configures the behaviour of the message.
		/// 
		/// `items` ── A set of items that will be rendered as actions in the message.
		/// 
		/// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
		/// </summary>
		/// <param name="message">The message to show.</param>
		/// <param name="options">Configures the behaviour of the message.</param>
		/// <param name="items">A set of items that will be rendered as actions in the message.</param>
		/// <param name="andThen">A thenable that resolves to the selected item or `undefined` when being dismissed.</param>
		void ShowErrorMessage(string message = default, MessageOptions options = default, MessageItem[] items = default, Action<MessageItem> andThen = default);

		/// <summary>
		/// Opens an input box to ask the user for input.
		/// 
		/// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
		/// returned value will be the string typed by the user or an empty string if the user did not type
		/// anything but dismissed the input box with OK.
		/// 
		/// `options` ── Configures the behavior of the input box.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
		/// </summary>
		/// <param name="options">Configures the behavior of the input box.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to a string the user provided or to `undefined` in case of dismissal.</param>
		void ShowInputBox(InputBoxOptions options = default, Cancel token = default, Action<string> andThen = default);

		/// <summary>
		/// Shows a selection list allowing multiple selections.
		/// 
		/// `items` ── An array of strings, or a promise that resolves to an array of strings.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selected items or `undefined`.
		/// </summary>
		/// <param name="items">An array of strings, or a promise that resolves to an array of strings.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selected items or `undefined`.</param>
		void ShowQuickPick(string[] items = default, QuickPickOptions options = default, Cancel token = default, Action<string[]> andThen = default);

		/// <summary>
		/// Shows a selection list.
		/// 
		/// `items` ── An array of strings, or a promise that resolves to an array of strings.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selection or `undefined`.
		/// </summary>
		/// <param name="items">An array of strings, or a promise that resolves to an array of strings.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selection or `undefined`.</param>
		void ShowQuickPick(string[] items = default, QuickPickOptions options = default, Cancel token = default, Action<string> andThen = default);

		/// <summary>
		/// Shows a selection list allowing multiple selections.
		/// 
		/// `items` ── An array of items, or a promise that resolves to an array of items.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selected items or `undefined`.
		/// </summary>
		/// <param name="items">An array of items, or a promise that resolves to an array of items.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selected items or `undefined`.</param>
		void ShowQuickPick(QuickPickItem[] items = default, QuickPickOptions options = default, Cancel token = default, Action<QuickPickItem[]> andThen = default);

		/// <summary>
		/// Shows a selection list.
		/// 
		/// `items` ── An array of items, or a promise that resolves to an array of items.
		/// 
		/// `options` ── Configures the behavior of the selection list.
		/// 
		/// `token` ── A token that can be used to signal cancellation.
		/// 
		/// `andThen` ── A promise that resolves to the selected item or `undefined`.
		/// </summary>
		/// <param name="items">An array of items, or a promise that resolves to an array of items.</param>
		/// <param name="options">Configures the behavior of the selection list.</param>
		/// <param name="token">A token that can be used to signal cancellation.</param>
		/// <param name="andThen">A promise that resolves to the selected item or `undefined`.</param>
		void ShowQuickPick(QuickPickItem[] items = default, QuickPickOptions options = default, Cancel token = default, Action<QuickPickItem> andThen = default);

		/// <summary>
		/// Set a message to the status bar. This is a short hand for the more powerful
		/// status bar [items](#window.createStatusBarItem).
		/// 
		/// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
		/// 
		/// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
		/// 
		/// `andThen` ── A disposable which hides the status bar message.
		/// </summary>
		/// <param name="text">The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).</param>
		/// <param name="hideAfterTimeout">Timeout in milliseconds after which the message will be disposed.</param>
		/// <param name="andThen">A disposable which hides the status bar message.</param>
		void SetStatusBarMessage(string text = default, int hideAfterTimeout = default, Action<Disposable> andThen = default);

		/// <summary>
		/// Set a message to the status bar. This is a short hand for the more powerful
		/// status bar [items](#window.createStatusBarItem).
		/// 
		/// *Note* that status bar messages stack and that they must be disposed when no
		/// longer used.
		/// 
		/// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
		/// 
		/// `andThen` ── A disposable which hides the status bar message.
		/// </summary>
		/// <param name="text">The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).</param>
		/// <param name="andThen">A disposable which hides the status bar message.</param>
		void SetStatusBarMessage(string text = default, Action<Disposable> andThen = default);

		/// <summary>
		/// Shows a file save dialog to the user which allows to select a file
		/// for saving-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `andThen` ── A promise that resolves to the selected resource or `undefined`.
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <param name="andThen">A promise that resolves to the selected resource or `undefined`.</param>
		void ShowSaveDialog(SaveDialogOptions options = default, Action<string> andThen = default);

		/// <summary>
		/// Shows a file open dialog to the user which allows to select a file
		/// for opening-purposes.
		/// 
		/// `options` ── Options that control the dialog.
		/// 
		/// `andThen` ── A promise that resolves to the selected resources or `undefined`.
		/// </summary>
		/// <param name="options">Options that control the dialog.</param>
		/// <param name="andThen">A promise that resolves to the selected resources or `undefined`.</param>
		void ShowOpenDialog(OpenDialogOptions options = default, Action<string[]> andThen = default);

		/// <summary>
		/// Shows a selection list of [workspace folders](#workspace.workspaceFolders) to pick from.
		/// Returns `undefined` if no folder is open.
		/// 
		/// `options` ── Configures the behavior of the workspace folder list.
		/// 
		/// `andThen` ── A promise that resolves to the workspace folder or `undefined`.
		/// </summary>
		/// <param name="options">Configures the behavior of the workspace folder list.</param>
		/// <param name="andThen">A promise that resolves to the workspace folder or `undefined`.</param>
		void ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options = default, Action<WorkspaceFolder> andThen = default);

		/// <summary>Represents the current window's state.</summary>
		void State(Action<WindowState> andThen = default);

		/// <summary>
		/// An [event](#Event) which fires when the focus state of the current window
		/// changes. The value of the event represents whether the window is focused.
		/// </summary>
		void OnDidChangeWindowState(Action<WindowState> listener = default, Action<Disposable> andThen = default);

		/// <summary>
		/// Creates a status bar [item](#StatusBarItem).
		/// 
		/// `alignment` ── The alignment of the item.
		/// 
		/// `priority` ── The priority of the item. Higher values mean the item should be shown more to the left.
		/// 
		/// `andThen` ── A new status bar item.
		/// </summary>
		/// <param name="alignment">The alignment of the item.</param>
		/// <param name="priority">The priority of the item. Higher values mean the item should be shown more to the left.</param>
		/// <param name="andThen">A new status bar item.</param>
		void CreateStatusBarItem(StatusBarAlignment? alignment = default, int? priority = default, Action<StatusBarItem> andThen = default);
	}

	/// <summary>Namespace describing the environment the editor runs in.</summary>
	public interface IEnv {
		/// <summary>
		/// Opens an *external* item, e.g. a http(s) or mailto-link, using the
		/// default application.
		/// 
		/// *Note* that [`showTextDocument`](#window.showTextDocument) is the right
		/// way to open a text document inside the editor, not this function.
		/// 
		/// `target` ── The uri that should be opened.
		/// 
		/// `andThen` ── A promise indicating if open was successful.
		/// </summary>
		/// <param name="target">The uri that should be opened.</param>
		/// <param name="andThen">A promise indicating if open was successful.</param>
		void OpenExternal(string target = default, Action<bool> andThen = default);

		/// <summary>The application name of the editor, like 'VS Code'.</summary>
		void AppName(Action<string> andThen = default);

		/// <summary>The application root folder from which the editor is running.</summary>
		void AppRoot(Action<string> andThen = default);

		/// <summary>Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.</summary>
		void Language(Action<string> andThen = default);

		/// <summary>A unique identifier for the computer.</summary>
		void MachineId(Action<string> andThen = default);

		/// <summary>
		/// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
		/// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
		/// 
		/// *Note* that the value is `undefined` when there is no remote extension host but that the
		/// value is defined in all extension hosts (local and remote) in case a remote extension host
		/// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
		/// a specific extension runs remote or not.
		/// </summary>
		void RemoteName(Action<string> andThen = default);

		/// <summary>
		/// A unique identifier for the current session.
		/// Changes each time the editor is started.
		/// </summary>
		void SessionId(Action<string> andThen = default);

		/// <summary>
		/// The detected default shell for the extension host, this is overridden by the
		/// `terminal.integrated.shell` setting for the extension host's platform.
		/// </summary>
		void Shell(Action<string> andThen = default);

		/// <summary>The custom uri scheme the editor registers to in the operating system.</summary>
		void UriScheme(Action<string> andThen = default);

		/// <summary>Provides single-call access to numerous individual `IEnv` properties at once.</summary>
		void Properties(Action<EnvProperties> then = default);
	}

	/// <summary>
	/// Namespace for dealing with the current workspace. A workspace is the representation
	/// of the folder that has been opened. There is no workspace when just a file but not a
	/// folder has been opened.
	/// 
	/// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
	/// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
	/// the editor-process so that they should be always used instead of nodejs-equivalents.
	/// </summary>
	public interface IWorkspace {
		/// <summary>
		/// The name of the workspace. `undefined` when no folder
		/// has been opened.
		/// </summary>
		void Name(Action<string> andThen = default);

		/// <summary>
		/// The location of the workspace file, for example:
		/// 
		/// `file:///Users/name/Development/myProject.code-workspace`
		/// 
		/// or
		/// 
		/// `untitled:1555503116870`
		/// 
		/// for a workspace that is untitled and not yet saved.
		/// 
		/// Depending on the workspace that is opened, the value will be:
		///   * `undefined` when no workspace or  a single folder is opened
		///   * the path of the workspace file as `Uri` otherwise. if the workspace
		/// is untitled, the returned URI will use the `untitled:` scheme
		/// 
		/// The location can e.g. be used with the `vscode.openFolder` command to
		/// open the workspace again after it has been closed.
		/// 
		/// **Example:**
		/// ```typescript
		/// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
		/// ```
		/// 
		/// **Note:** it is not advised to use `workspace.workspaceFile` to write
		/// configuration data into the file. You can use `workspace.getConfiguration().update()`
		/// for that purpose which will work both when a single folder is opened as
		/// well as an untitled or saved workspace.
		/// </summary>
		void WorkspaceFile(Action<string> andThen = default);

		/// <summary>
		/// Save all dirty files.
		/// 
		/// `includeUntitled` ── Also save files that have been created during this session.
		/// 
		/// `andThen` ── A thenable that resolves when the files have been saved.
		/// </summary>
		/// <param name="includeUntitled">Also save files that have been created during this session.</param>
		/// <param name="andThen">A thenable that resolves when the files have been saved.</param>
		void SaveAll(bool includeUntitled = default, Action<bool> andThen = default);

		/// <summary>An event that is emitted when a workspace folder is added or removed.</summary>
		void OnDidChangeWorkspaceFolders(Action<WorkspaceFoldersChangeEvent> listener = default, Action<Disposable> andThen = default);

		/// <summary>
		/// Returns the [workspace folder](#WorkspaceFolder) that contains a given uri.
		/// * returns `undefined` when the given uri doesn't match any workspace folder
		/// * returns the *input* when the given uri is a workspace folder itself
		/// 
		/// `uri` ── An uri.
		/// 
		/// `andThen` ── A workspace folder or `undefined`
		/// </summary>
		/// <param name="uri">An uri.</param>
		/// <param name="andThen">A workspace folder or `undefined`</param>
		void GetWorkspaceFolder(string uri = default, Action<WorkspaceFolder> andThen = default);

		/// <summary>
		/// List of workspace folders or `undefined` when no folder is open.
		/// *Note* that the first entry corresponds to the value of `rootPath`.
		/// </summary>
		void WorkspaceFolders(Action<WorkspaceFolder[]> andThen = default);

		/// <summary>
		/// Find files across all [workspace folders](#workspace.workspaceFolders) in the workspace.
		/// `findFiles('**​/*.js', '**​/node_modules/**', 10)`
		/// 
		/// `include` ── A [glob pattern](#GlobPattern) that defines the files to search for. The glob pattern
		/// will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](#RelativePattern)
		/// to restrict the search results to a [workspace folder](#WorkspaceFolder).
		/// 
		/// `exclude` ── A [glob pattern](#GlobPattern) that defines files and folders to exclude. The glob pattern
		/// will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will
		/// apply, when `null` no excludes will apply.
		/// 
		/// `maxResults` ── An upper-bound for the result.
		/// 
		/// `token` ── A token that can be used to signal cancellation to the underlying search engine.
		/// 
		/// `andThen` ── A thenable that resolves to an array of resource identifiers. Will return no results if no
		/// [workspace folders](#workspace.workspaceFolders) are opened.
		/// </summary>
		/// <param name="include">A [glob pattern](#GlobPattern) that defines the files to search for. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](#RelativePattern) to restrict the search results to a [workspace folder](#WorkspaceFolder).</param>
		/// <param name="exclude">A [glob pattern](#GlobPattern) that defines files and folders to exclude. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will apply, when `null` no excludes will apply.</param>
		/// <param name="maxResults">An upper-bound for the result.</param>
		/// <param name="token">A token that can be used to signal cancellation to the underlying search engine.</param>
		/// <param name="andThen">A thenable that resolves to an array of resource identifiers. Will return no results if no [workspace folders](#workspace.workspaceFolders) are opened.</param>
		void FindFiles(string include = default, string exclude = default, int? maxResults = default, Cancel token = default, Action<string[]> andThen = default);

		/// <summary>
		/// Returns a path that is relative to the workspace folder or folders.
		/// 
		/// When there are no [workspace folders](#workspace.workspaceFolders) or when the path
		/// is not contained in them, the input is returned.
		/// 
		/// `pathOrUri` ── A path or uri. When a uri is given its [fsPath](#Uri.fsPath) is used.
		/// 
		/// `includeWorkspaceFolder` ── When `true` and when the given path is contained inside a
		/// workspace folder the name of the workspace is prepended. Defaults to `true` when there are
		/// multiple workspace folders and `false` otherwise.
		/// 
		/// `andThen` ── A path relative to the root or the input.
		/// </summary>
		/// <param name="pathOrUri">A path or uri. When a uri is given its [fsPath](#Uri.fsPath) is used.</param>
		/// <param name="includeWorkspaceFolder">When `true` and when the given path is contained inside a workspace folder the name of the workspace is prepended. Defaults to `true` when there are multiple workspace folders and `false` otherwise.</param>
		/// <param name="andThen">A path relative to the root or the input.</param>
		void AsRelativePath(string pathOrUri = default, bool includeWorkspaceFolder = default, Action<string> andThen = default);

		/// <summary>Provides single-call access to numerous individual `IWorkspace` properties at once.</summary>
		void Properties(Action<WorkspaceProperties> then = default);
	}

	/// <summary>
	/// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
	/// like IntelliSense, code actions, diagnostics etc.
	/// 
	/// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
	/// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
	/// programming languages.
	/// 
	/// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
	/// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
	/// that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
	/// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
	/// 
	/// ```javascript
	/// languages.registerHoverProvider('javascript', {
	///  	provideHover(document, position, token) {
	///  		return new Hover('I am a hover!');
	///  	}
	/// });
	/// ```
	/// 
	/// Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
	/// a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
	/// a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
	/// scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
	/// the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
	/// score is used for determining the order in which providers are asked to participate.
	/// </summary>
	public interface ILanguages {
		/// <summary>
		/// Return the identifiers of all known languages.
		/// 
		/// `andThen` ── Promise resolving to an array of identifier strings.
		/// </summary>
		/// <param name="andThen">Promise resolving to an array of identifier strings.</param>
		void GetLanguages(Action<string[]> andThen = default);

		/// <summary>
		/// An [event](#Event) which fires when the global set of diagnostics changes. This is
		/// newly added and removed diagnostics.
		/// </summary>
		void OnDidChangeDiagnostics(Action<DiagnosticChangeEvent> listener = default, Action<Disposable> andThen = default);
	}

	/// <summary>
	/// Namespace for dealing with installed extensions. Extensions are represented
	/// by an [extension](#Extension)-interface which enables reflection on them.
	/// 
	/// Extension writers can provide APIs to other extensions by returning their API public
	/// surface from the `activate`-call.
	/// 
	/// ```javascript
	/// export function activate(context: vscode.ExtensionContext) {
	///  	let api = {
	///  		sum(a, b) {
	///  			return a + b;
	///  		},
	///  		mul(a, b) {
	///  			return a * b;
	///  		}
	///  	};
	///  	// 'export' public api-surface
	///  	return api;
	/// }
	/// ```
	/// When depending on the API of another extension add an `extensionDependency`-entry
	/// to `package.json`, and use the [getExtension](#extensions.getExtension)-function
	/// and the [exports](#Extension.exports)-property, like below:
	/// 
	/// ```javascript
	/// let mathExt = extensions.getExtension('genius.math');
	/// let importedApi = mathExt.exports;
	/// 
	/// console.log(importedApi.mul(42, 1));
	/// ```
	/// </summary>
	public interface IExtensions {
		/// <summary>
		/// An event which fires when `extensions.all` changes. This can happen when extensions are
		/// installed, uninstalled, enabled or disabled.
		/// </summary>
		void OnDidChange(Action listener = default, Action<Disposable> andThen = default);
	}

	/// <summary>
	/// Namespace for dealing with commands. In short, a command is a function with a
	/// unique identifier. The function is sometimes also called _command handler_.
	/// 
	/// Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
	/// and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
	/// can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
	/// 
	/// * palette - Use the `commands`-section in `package.json` to make a command show in
	/// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
	/// * keybinding - Use the `keybindings`-section in `package.json` to enable
	/// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
	/// for your extension.
	/// 
	/// Commands from other extensions and from the editor itself are accessible to an extension. However,
	/// when invoking an editor command not all argument types are supported.
	/// 
	/// This is a sample that registers a command handler and adds an entry for that command to the palette. First
	/// register a command handler with the identifier `extension.sayHello`.
	/// ```javascript
	/// commands.registerCommand('extension.sayHello', () => {
	///  	window.showInformationMessage('Hello World!');
	/// });
	/// ```
	/// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
	/// ```json
	/// {
	///  	"contributes": {
	///  		"commands": [{
	///  			"command": "extension.sayHello",
	///  			"title": "Hello World"
	///  		}]
	///  	}
	/// }
	/// ```
	/// </summary>
	public interface ICommands {
		/// <summary>
		/// Registers a command that can be invoked via a keyboard shortcut,
		/// a menu item, an action, or directly.
		/// 
		/// Registering a command with an existing command identifier twice
		/// will cause an error.
		/// 
		/// `command` ── A unique identifier for the command.
		/// 
		/// `callback` ── A command handler function.
		/// 
		/// `andThen` ── Disposable which unregisters this command on disposal.
		/// </summary>
		/// <param name="command">A unique identifier for the command.</param>
		/// <param name="callback">A command handler function.</param>
		/// <param name="andThen">Disposable which unregisters this command on disposal.</param>
		void RegisterCommand(string command = default, Func<any[], any> callback = default, Action<Disposable> andThen = default);

		/// <summary>
		/// Executes the command denoted by the given command identifier.
		/// 
		/// * *Note 1:* When executing an editor command not all types are allowed to
		/// be passed as arguments. Allowed are the primitive types `string`, `boolean`,
		/// `number`, `undefined`, and `null`, as well as [`Position`](#Position), [`Range`](#Range), [`Uri`](#Uri) and [`Location`](#Location).
		/// * *Note 2:* There are no restrictions when executing commands that have been contributed
		/// by extensions.
		/// 
		/// `command` ── Identifier of the command to execute.
		/// 
		/// `rest` ── Parameters passed to the command function.
		/// 
		/// `andThen` ── A thenable that resolves to the returned value of the given command. `undefined` when
		/// the command handler function doesn't return anything.
		/// </summary>
		/// <param name="command">Identifier of the command to execute.</param>
		/// <param name="rest">Parameters passed to the command function.</param>
		/// <param name="andThen">A thenable that resolves to the returned value of the given command. `undefined` when the command handler function doesn't return anything.</param>
		void ExecuteCommand(string command = default, any[] rest = default, Action<any> andThen = default);

		/// <summary>
		/// Retrieve the list of all available commands. Commands starting an underscore are
		/// treated as internal commands.
		/// 
		/// `filterInternal` ── Set `true` to not see internal commands (starting with an underscore)
		/// 
		/// `andThen` ── Thenable that resolves to a list of command ids.
		/// </summary>
		/// <param name="filterInternal">Set `true` to not see internal commands (starting with an underscore)</param>
		/// <param name="andThen">Thenable that resolves to a list of command ids.</param>
		void GetCommands(bool filterInternal = default, Action<string[]> andThen = default);
	}

	/// <summary>Options to configure the behavior of the message.</summary>
	public partial class MessageOptions {
		/// <summary>Indicates that this message should be modal.</summary>
		[JsonProperty("modal")]
		public bool Modal;
	}

	/// <summary>
	/// Represents an action that is shown with an information, warning, or
	/// error message.
	/// </summary>
	public partial class MessageItem {
		/// <summary>A short title like 'Retry', 'Open Log' etc.</summary>
		[JsonProperty("title"), JsonRequired]
		public string Title;

		/// <summary>
		/// A hint for modal dialogs that the item should be triggered
		/// when the user cancels the dialog (e.g. by pressing the ESC
		/// key).
		/// 
		/// Note: this option is ignored for non-modal messages.
		/// </summary>
		[JsonProperty("isCloseAffordance")]
		public bool IsCloseAffordance;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public dict My;
	}

	/// <summary>Options to configure the behavior of the input box UI.</summary>
	public partial class InputBoxOptions {
		/// <summary>The value to prefill in the input box.</summary>
		[JsonProperty("value")]
		public string Value;

		/// <summary>
		/// Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
		/// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
		/// word will be selected, when empty (start equals end) only the cursor will be set,
		/// otherwise the defined range will be selected.
		/// </summary>
		[JsonProperty("valueSelection"), JsonConverter(typeof(json.valueTuples))]
		public (int, int)? ValueSelection;

		/// <summary>The text to display underneath the input box.</summary>
		[JsonProperty("prompt")]
		public string Prompt;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to type.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to show a password prompt that will not show the typed value.</summary>
		[JsonProperty("password")]
		public bool Password;

		/// <summary>Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>
		/// An optional function that will be called to validate input and to give a hint
		/// to the user.
		/// 
		/// `value` ── The current value of the input box.
		/// 
		/// `return` ── A human readable string which is presented as diagnostic message.
		/// Return `undefined`, `null`, or the empty string when 'value' is valid.
		/// </summary>
		[JsonIgnore]
		public Func<string, string> ValidateInput;

		/// <summary>For internal runtime use only.</summary>
		[JsonProperty("validateInput_AppzFuncId")]
		internal string ValidateInput_AppzFuncId;
	}

	/// <summary>Options to configure the behavior of the quick pick UI.</summary>
	public partial class QuickPickOptions {
		/// <summary>An optional flag to include the description when filtering the picks.</summary>
		[JsonProperty("matchOnDescription")]
		public bool MatchOnDescription;

		/// <summary>An optional flag to include the detail when filtering the picks.</summary>
		[JsonProperty("matchOnDetail")]
		public bool MatchOnDetail;

		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;

		/// <summary>An optional flag to make the picker accept multiple selections, if true the result is an array of picks.</summary>
		[JsonProperty("canPickMany")]
		public bool CanPickMany;

		/// <summary>An optional function that is invoked whenever an item is selected.</summary>
		[JsonIgnore]
		public Func<QuickPickItem, any> OnDidSelectItem;

		/// <summary>For internal runtime use only.</summary>
		[JsonProperty("onDidSelectItem_AppzFuncId")]
		internal string OnDidSelectItem_AppzFuncId;
	}

	/// <summary>
	/// Represents an item that can be selected from
	/// a list of items.
	/// </summary>
	public partial class QuickPickItem {
		/// <summary>A human readable string which is rendered prominent.</summary>
		[JsonProperty("label"), JsonRequired]
		public string Label;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("description")]
		public string Description;

		/// <summary>A human readable string which is rendered less prominent.</summary>
		[JsonProperty("detail")]
		public string Detail;

		/// <summary>
		/// Optional flag indicating if this item is picked initially.
		/// (Only honored when the picker allows multiple selections.)
		/// </summary>
		[JsonProperty("picked")]
		public bool Picked;

		/// <summary>Always show this item.</summary>
		[JsonProperty("alwaysShow")]
		public bool AlwaysShow;

		/// <summary>Free-form custom data, preserved across a roundtrip.</summary>
		[JsonProperty("my")]
		public dict My;
	}

	/// <summary>Options to configure the behaviour of a file save dialog.</summary>
	public partial class SaveDialogOptions {
		/// <summary>The resource the dialog shows when opened.</summary>
		[JsonProperty("defaultUri")]
		public string DefaultUri;

		/// <summary>A human-readable string for the save button.</summary>
		[JsonProperty("saveLabel")]
		public string SaveLabel;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// ```ts
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// ```
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>
	/// Options to configure the behaviour of a file open dialog.
	/// 
	/// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
	/// which enforces to open either files or folder, but *not both*.
	/// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
	/// and the editor then silently adjusts the options to select files.
	/// </summary>
	public partial class OpenDialogOptions {
		/// <summary>The resource the dialog shows when opened.</summary>
		[JsonProperty("defaultUri")]
		public string DefaultUri;

		/// <summary>A human-readable string for the open button.</summary>
		[JsonProperty("openLabel")]
		public string OpenLabel;

		/// <summary>Allow to select files, defaults to `true`.</summary>
		[JsonProperty("canSelectFiles")]
		public bool CanSelectFiles;

		/// <summary>Allow to select folders, defaults to `false`.</summary>
		[JsonProperty("canSelectFolders")]
		public bool CanSelectFolders;

		/// <summary>Allow to select many files or folders.</summary>
		[JsonProperty("canSelectMany")]
		public bool CanSelectMany;

		/// <summary>
		/// A set of file filters that are used by the dialog. Each entry is a human readable label,
		/// like "TypeScript", and an array of extensions, e.g.
		/// ```ts
		/// {
		///  	'Images': ['png', 'jpg']
		///  	'TypeScript': ['ts', 'tsx']
		/// }
		/// ```
		/// </summary>
		[JsonProperty("filters")]
		public Dictionary<string, string[]> Filters;
	}

	/// <summary>Options to configure the behaviour of the [workspace folder](#WorkspaceFolder) pick UI.</summary>
	public partial class WorkspaceFolderPickOptions {
		/// <summary>An optional string to show as place holder in the input box to guide the user what to pick on.</summary>
		[JsonProperty("placeHolder")]
		public string PlaceHolder;

		/// <summary>Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.</summary>
		[JsonProperty("ignoreFocusOut")]
		public bool IgnoreFocusOut;
	}

	/// <summary>
	/// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
	/// are equal which means there is no notion of an active or master workspace folder.
	/// </summary>
	public partial class WorkspaceFolder {
		/// <summary>
		/// The associated uri for this workspace folder.
		/// 
		/// *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
		/// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
		/// </summary>
		[JsonProperty("uri"), JsonRequired]
		public string Uri;

		/// <summary>
		/// The name of this workspace folder. Defaults to
		/// the basename of its [uri-path](#Uri.path)
		/// </summary>
		[JsonProperty("name"), JsonRequired]
		public string Name;

		/// <summary>The ordinal number of this workspace folder.</summary>
		[JsonProperty("index"), JsonRequired]
		public int Index;
	}

	/// <summary>Represents the state of a window.</summary>
	public partial class WindowState {
		/// <summary>Whether the current window is focused.</summary>
		[JsonProperty("focused"), JsonRequired]
		public bool Focused;
	}

	/// <summary>
	/// A status bar item is a status bar contribution that can
	/// show text and icons and run a command on click.
	/// </summary>
	public partial class StatusBarItem {
	}

	/// <summary>An event describing a change to the set of [workspace folders](#workspace.workspaceFolders).</summary>
	public partial class WorkspaceFoldersChangeEvent {
		/// <summary>Added workspace folders.</summary>
		[JsonProperty("added"), JsonRequired]
		public WorkspaceFolder[] Added;

		/// <summary>Removed workspace folders.</summary>
		[JsonProperty("removed"), JsonRequired]
		public WorkspaceFolder[] Removed;
	}

	/// <summary>The event that is fired when diagnostics change.</summary>
	public partial class DiagnosticChangeEvent {
		/// <summary>An array of resources for which diagnostics have changed.</summary>
		[JsonProperty("uris"), JsonRequired]
		public string[] Uris;
	}

	/// <summary>Namespace describing the environment the editor runs in.</summary>
	public partial class EnvProperties {
		/// <summary>The application name of the editor, like 'VS Code'.</summary>
		[JsonProperty("appName")]
		public string AppName;

		/// <summary>The application root folder from which the editor is running.</summary>
		[JsonProperty("appRoot")]
		public string AppRoot;

		/// <summary>Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.</summary>
		[JsonProperty("language")]
		public string Language;

		/// <summary>A unique identifier for the computer.</summary>
		[JsonProperty("machineId")]
		public string MachineId;

		/// <summary>
		/// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
		/// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
		/// 
		/// *Note* that the value is `undefined` when there is no remote extension host but that the
		/// value is defined in all extension hosts (local and remote) in case a remote extension host
		/// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
		/// a specific extension runs remote or not.
		/// </summary>
		[JsonProperty("remoteName")]
		public string RemoteName;

		/// <summary>
		/// A unique identifier for the current session.
		/// Changes each time the editor is started.
		/// </summary>
		[JsonProperty("sessionId")]
		public string SessionId;

		/// <summary>
		/// The detected default shell for the extension host, this is overridden by the
		/// `terminal.integrated.shell` setting for the extension host's platform.
		/// </summary>
		[JsonProperty("shell")]
		public string Shell;

		/// <summary>The custom uri scheme the editor registers to in the operating system.</summary>
		[JsonProperty("uriScheme")]
		public string UriScheme;
	}

	/// <summary>
	/// Namespace for dealing with the current workspace. A workspace is the representation
	/// of the folder that has been opened. There is no workspace when just a file but not a
	/// folder has been opened.
	/// 
	/// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
	/// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
	/// the editor-process so that they should be always used instead of nodejs-equivalents.
	/// </summary>
	public partial class WorkspaceProperties {
		/// <summary>
		/// The name of the workspace. `undefined` when no folder
		/// has been opened.
		/// </summary>
		[JsonProperty("name")]
		public string Name;

		/// <summary>
		/// The location of the workspace file, for example:
		/// 
		/// `file:///Users/name/Development/myProject.code-workspace`
		/// 
		/// or
		/// 
		/// `untitled:1555503116870`
		/// 
		/// for a workspace that is untitled and not yet saved.
		/// 
		/// Depending on the workspace that is opened, the value will be:
		///   * `undefined` when no workspace or  a single folder is opened
		///   * the path of the workspace file as `Uri` otherwise. if the workspace
		/// is untitled, the returned URI will use the `untitled:` scheme
		/// 
		/// The location can e.g. be used with the `vscode.openFolder` command to
		/// open the workspace again after it has been closed.
		/// 
		/// **Example:**
		/// ```typescript
		/// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
		/// ```
		/// 
		/// **Note:** it is not advised to use `workspace.workspaceFile` to write
		/// configuration data into the file. You can use `workspace.getConfiguration().update()`
		/// for that purpose which will work both when a single folder is opened as
		/// well as an untitled or saved workspace.
		/// </summary>
		[JsonProperty("workspaceFile")]
		public string WorkspaceFile;

		/// <summary>
		/// List of workspace folders or `undefined` when no folder is open.
		/// *Note* that the first entry corresponds to the value of `rootPath`.
		/// </summary>
		[JsonProperty("workspaceFolders")]
		public WorkspaceFolder[] WorkspaceFolders;
	}

	internal partial class impl : IVscode, IWindow, IEnv, IWorkspace, ILanguages, IExtensions, ICommands {

		IWindow IVscode.Window { get {
			return this;
		} }

		IEnv IVscode.Env { get {
			return this;
		} }

		IWorkspace IVscode.Workspace { get {
			return this;
		} }

		ILanguages IVscode.Languages { get {
			return this;
		} }

		IExtensions IVscode.Extensions { get {
			return this;
		} }

		ICommands IVscode.Commands { get {
			return this;
		} }

		void IWindow.ShowInformationMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowInformationMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInformationMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowWarningMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWarningMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage1";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageOptions options, string[] items, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage2";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage3";
			msg.Data = new dict(2);
			msg.Data["message"] = message;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowErrorMessage(string message, MessageOptions options, MessageItem[] items, Action<MessageItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showErrorMessage4";
			msg.Data = new dict(3);
			msg.Data["message"] = message;
			msg.Data["options"] = options;
			msg.Data["items"] = items;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					MessageItem result = default;
					if ((null != payload)) {
						result = new MessageItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowInputBox(InputBoxOptions options, Cancel token, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showInputBox";
			msg.Data = new dict(2);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.ValidateInput_AppzFuncId = "";
				Func<string, string> fn = default;
				fn = options.ValidateInput;
				if ((null != fn)) {
					lock (this) {
						options.ValidateInput_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.ValidateInput_AppzFuncId);
						this.Impl().cbOther[options.ValidateInput_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								string __0 = default;
								if ((null != args[0])) {
									(__0, ok) = (args[0] is string) ? (((string)(args[0])), true) : (default, false);
									if (!ok) {
										return (null, false);
									}
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == on) || on(payload);
			});
		}

		void IWindow.ShowQuickPick(string[] items, QuickPickOptions options, Cancel token, Action<string[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick1";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if (true) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			options.CanPickMany = true;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = new string[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							string __val__result = default;
							(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
							if (!ok) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = __idx__result + 1;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == on) || on(payload);
			});
		}

		void IWindow.ShowQuickPick(string[] items, QuickPickOptions options, Cancel token, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick2";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == on) || on(payload);
			});
		}

		void IWindow.ShowQuickPick(QuickPickItem[] items, QuickPickOptions options, Cancel token, Action<QuickPickItem[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick3";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if (true) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			options.CanPickMany = true;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					QuickPickItem[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = new QuickPickItem[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							QuickPickItem __val__result = default;
							__val__result = new QuickPickItem();
							ok = __val__result.populateFrom(__item__result);
							if (!ok) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = __idx__result + 1;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == on) || on(payload);
			});
		}

		void IWindow.ShowQuickPick(QuickPickItem[] items, QuickPickOptions options, Cancel token, Action<QuickPickItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showQuickPick4";
			msg.Data = new dict(3);
			List<string> fnids = default;
			fnids = new List<string>(1);
			if ((null != options)) {
				options.OnDidSelectItem_AppzFuncId = "";
				Func<QuickPickItem, any> fn = default;
				fn = options.OnDidSelectItem;
				if ((null != fn)) {
					lock (this) {
						options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
						fnids.Add(options.OnDidSelectItem_AppzFuncId);
						this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (any[] args) => {
							if (1 != args.Length) {
								return (null, false);
							} else {
								bool ok = default;
								QuickPickItem __0 = default;
								if ((null != args[0])) {
									__0 = new QuickPickItem();
									ok = __0.populateFrom(args[0]);
									if (!ok) {
										return (null, false);
									}
								} else {
									return (null, false);
								}
								return (fn(__0), true);
							}
						};
					}
				}
			}
			msg.Data["items"] = items;
			msg.Data["options"] = options;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					QuickPickItem result = default;
					if ((null != payload)) {
						result = new QuickPickItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, (any payload) => {
				if (fnids.Count != 0) {
					lock (this) {
						foreach (var fnid in fnids) {
							this.Impl().cbOther.Remove(fnid);
						}
					}
				}
				return (null == on) || on(payload);
			});
		}

		void IWindow.SetStatusBarMessage(string text, int hideAfterTimeout, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.setStatusBarMessage1";
			msg.Data = new dict(2);
			msg.Data["text"] = text;
			msg.Data["hideAfterTimeout"] = hideAfterTimeout;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result.bind(this.Impl()));
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.SetStatusBarMessage(string text, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.setStatusBarMessage2";
			msg.Data = new dict(1);
			msg.Data["text"] = text;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result.bind(this.Impl()));
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowSaveDialog(SaveDialogOptions options, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showSaveDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowOpenDialog(OpenDialogOptions options, Action<string[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showOpenDialog";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = new string[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							string __val__result = default;
							(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
							if (!ok) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = __idx__result + 1;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.ShowWorkspaceFolderPick(WorkspaceFolderPickOptions options, Action<WorkspaceFolder> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.showWorkspaceFolderPick";
			msg.Data = new dict(1);
			msg.Data["options"] = options;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					WorkspaceFolder result = default;
					if ((null != payload)) {
						result = new WorkspaceFolder();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.State(Action<WindowState> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.state";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					WindowState result = default;
					if ((null != payload)) {
						result = new WindowState();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.OnDidChangeWindowState(Action<WindowState> listener, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.onDidChangeWindowState";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IWindow.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return ;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				WindowState _a_0_ = default;
				_a_0_ = new WindowState();
				ok = _a_0_.populateFrom(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result.bind(this.Impl(), _fnid_listener));
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWindow.CreateStatusBarItem(StatusBarAlignment? alignment, int? priority, Action<StatusBarItem> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "window.createStatusBarItem";
			msg.Data = new dict(2);
			msg.Data["alignment"] = alignment;
			msg.Data["priority"] = priority;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					StatusBarItem result = default;
					if ((null != payload)) {
						result = new StatusBarItem();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.OpenExternal(string target, Action<bool> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.openExternal";
			msg.Data = new dict(1);
			msg.Data["target"] = target;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					bool result = default;
					if ((null != payload)) {
						(result, ok) = (payload is bool) ? (((bool)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.AppName(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.appName";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.AppRoot(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.appRoot";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.Language(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.language";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.MachineId(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.machineId";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.RemoteName(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.remoteName";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.SessionId(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.sessionId";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.Shell(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.shell";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.UriScheme(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.uriScheme";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						(result, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IEnv.Properties(Action<EnvProperties> then) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "env.Properties";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != then)) {
				on = (any payload) => {
					bool ok = default;
					EnvProperties result = default;
					if ((null != payload)) {
						result = new EnvProperties();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					then(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.Name(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.name";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.WorkspaceFile(Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.workspaceFile";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.SaveAll(bool includeUntitled, Action<bool> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.saveAll";
			msg.Data = new dict(1);
			msg.Data["includeUntitled"] = includeUntitled;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					bool result = default;
					if ((null != payload)) {
						(result, ok) = (payload is bool) ? (((bool)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.OnDidChangeWorkspaceFolders(Action<WorkspaceFoldersChangeEvent> listener, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.onDidChangeWorkspaceFolders";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IWorkspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return ;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				WorkspaceFoldersChangeEvent _a_0_ = default;
				_a_0_ = new WorkspaceFoldersChangeEvent();
				ok = _a_0_.populateFrom(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result.bind(this.Impl(), _fnid_listener));
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.GetWorkspaceFolder(string uri, Action<WorkspaceFolder> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.getWorkspaceFolder";
			msg.Data = new dict(1);
			msg.Data["uri"] = uri;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					WorkspaceFolder result = default;
					if ((null != payload)) {
						result = new WorkspaceFolder();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.WorkspaceFolders(Action<WorkspaceFolder[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.workspaceFolders";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					WorkspaceFolder[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = new WorkspaceFolder[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							WorkspaceFolder __val__result = default;
							__val__result = new WorkspaceFolder();
							ok = __val__result.populateFrom(__item__result);
							if (!ok) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = __idx__result + 1;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.FindFiles(string include, string exclude, int? maxResults, Cancel token, Action<string[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.findFiles";
			msg.Data = new dict(4);
			msg.Data["include"] = include;
			msg.Data["exclude"] = exclude;
			msg.Data["maxResults"] = maxResults;
			if ((null != token)) {
				token.impl = this.Impl();
				if ("" == token.fnId) {
					lock (this) {
						token.fnId = this.Impl().nextFuncId();
					}
				}
				msg.Data["token"] = token.fnId;
			}
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = new string[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							string __val__result = default;
							(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
							if (!ok) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = __idx__result + 1;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.AsRelativePath(string pathOrUri, bool includeWorkspaceFolder, Action<string> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.asRelativePath";
			msg.Data = new dict(2);
			msg.Data["pathOrUri"] = pathOrUri;
			msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string result = default;
					if ((null != payload)) {
						string _result_ = default;
						(_result_, ok) = (payload is string) ? (((string)(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = _result_;
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IWorkspace.Properties(Action<WorkspaceProperties> then) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "workspace.Properties";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != then)) {
				on = (any payload) => {
					bool ok = default;
					WorkspaceProperties result = default;
					if ((null != payload)) {
						result = new WorkspaceProperties();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					then(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void ILanguages.GetLanguages(Action<string[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "languages.getLanguages";
			msg.Data = new dict(0);
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = new string[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							string __val__result = default;
							(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
							if (!ok) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = __idx__result + 1;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void ILanguages.OnDidChangeDiagnostics(Action<DiagnosticChangeEvent> listener, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "languages.onDidChangeDiagnostics";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "ILanguages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return ;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return ok;
				}
				DiagnosticChangeEvent _a_0_ = default;
				_a_0_ = new DiagnosticChangeEvent();
				ok = _a_0_.populateFrom(args[0]);
				if (!ok) {
					return false;
				}
				listener(_a_0_);
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result.bind(this.Impl(), _fnid_listener));
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void IExtensions.OnDidChange(Action listener, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "extensions.onDidChange";
			msg.Data = new dict(1);
			string _fnid_listener = default;
			if ((null == listener)) {
				OnError(this.Impl(), "IExtensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
				return ;
			}
			_fnid_listener = this.Impl().nextSub((any[] args) => {
				bool ok = default;
				if (0 != args.Length) {
					return ok;
				}
				listener();
				return true;
			}, null);
			msg.Data["listener"] = _fnid_listener;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result.bind(this.Impl(), _fnid_listener));
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void ICommands.RegisterCommand(string command, Func<any[], any> callback, Action<Disposable> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.registerCommand";
			msg.Data = new dict(2);
			msg.Data["command"] = command;
			string _fnid_callback = default;
			if ((null == callback)) {
				OnError(this.Impl(), "ICommands.RegisterCommand: the 'callback' arg (which is not optional but required) was not passed by the caller", null);
				return ;
			}
			_fnid_callback = this.Impl().nextSub(null, (any[] args) => {
				bool ok = default;
				if (1 != args.Length) {
					return (null, ok);
				}
				any ret = default;
				any[] _a_0_ = default;
				(_a_0_, ok) = (args[0] is any[]) ? (((any[])(args[0])), true) : (default, false);
				if (!ok) {
					return (null, false);
				}
				ret = callback(_a_0_);
				return (ret, true);
			});
			msg.Data["callback"] = _fnid_callback;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					Disposable result = default;
					if ((null != payload)) {
						result = new Disposable();
						ok = result.populateFrom(payload);
						if (!ok) {
							return false;
						}
					} else {
						return false;
					}
					andThen(result.bind(this.Impl(), _fnid_callback));
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void ICommands.ExecuteCommand(string command, any[] rest, Action<any> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.executeCommand";
			msg.Data = new dict(2);
			msg.Data["command"] = command;
			msg.Data["rest"] = rest;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					any result = default;
					if ((null != payload)) {
						(result, ok) = (payload, true);
						if (ok) {
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

		void ICommands.GetCommands(bool filterInternal, Action<string[]> andThen) {
			ipcMsg msg = default;
			msg = new ipcMsg();
			msg.QName = "commands.getCommands";
			msg.Data = new dict(1);
			msg.Data["filterInternal"] = filterInternal;
			Func<any, bool> on = default;
			if ((null != andThen)) {
				on = (any payload) => {
					bool ok = default;
					string[] result = default;
					if ((null != payload)) {
						any[] __coll__result = default;
						(__coll__result, ok) = (payload is any[]) ? (((any[])(payload)), true) : (default, false);
						if (!ok) {
							return false;
						}
						result = new string[__coll__result.Length];
						int __idx__result = default;
						__idx__result = 0;
						foreach (var __item__result in __coll__result) {
							string __val__result = default;
							(__val__result, ok) = (__item__result is string) ? (((string)(__item__result)), true) : (default, false);
							if (!ok) {
								return false;
							}
							result[__idx__result] = __val__result;
							__idx__result = __idx__result + 1;
						}
					}
					andThen(result);
					return true;
				};
			}
			this.Impl().send(msg, on);
		}

	}

	public partial class MessageItem {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("title", out var __) ? (__, true) : (default, false));
			if (ok) {
				string title = default;
				if ((null != val)) {
					(title, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Title = title;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("isCloseAffordance", out var ___) ? (___, true) : (default, false));
			if (ok) {
				bool isCloseAffordance = default;
				if ((null != val)) {
					(isCloseAffordance, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.IsCloseAffordance = isCloseAffordance;
			}
			(val, ok) = (it.TryGetValue("my", out var ____) ? (____, true) : (default, false));
			if (ok) {
				dict my = default;
				if ((null != val)) {
					(my, ok) = (val is dict) ? (((dict)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.My = my;
			}
			return true;
		}
	}

	public partial class QuickPickItem {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("label", out var __) ? (__, true) : (default, false));
			if (ok) {
				string label = default;
				if ((null != val)) {
					(label, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Label = label;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("description", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string description = default;
				if ((null != val)) {
					string _description_ = default;
					(_description_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					description = _description_;
				}
				this.Description = description;
			}
			(val, ok) = (it.TryGetValue("detail", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string detail = default;
				if ((null != val)) {
					string _detail_ = default;
					(_detail_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					detail = _detail_;
				}
				this.Detail = detail;
			}
			(val, ok) = (it.TryGetValue("picked", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				bool picked = default;
				if ((null != val)) {
					(picked, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Picked = picked;
			}
			(val, ok) = (it.TryGetValue("alwaysShow", out var ______) ? (______, true) : (default, false));
			if (ok) {
				bool alwaysShow = default;
				if ((null != val)) {
					(alwaysShow, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.AlwaysShow = alwaysShow;
			}
			(val, ok) = (it.TryGetValue("my", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				dict my = default;
				if ((null != val)) {
					(my, ok) = (val is dict) ? (((dict)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.My = my;
			}
			return true;
		}
	}

	public partial class WorkspaceFolder {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("uri", out var __) ? (__, true) : (default, false));
			if (ok) {
				string uri = default;
				if ((null != val)) {
					(uri, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Uri = uri;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					(name, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Name = name;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("index", out var ____) ? (____, true) : (default, false));
			if (ok) {
				int index = default;
				if ((null != val)) {
					(index, ok) = (val is int) ? (((int)(val)), true) : (default, false);
					if (!ok) {
						double __index__ = default;
						(__index__, ok) = (val is double) ? (((double)(val)), true) : (default, false);
						if (!ok) {
							return false;
						}
						index = ((int)(__index__));
					}
				}
				this.Index = index;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class WindowState {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("focused", out var __) ? (__, true) : (default, false));
			if (ok) {
				bool focused = default;
				if ((null != val)) {
					(focused, ok) = (val is bool) ? (((bool)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
				}
				this.Focused = focused;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class StatusBarItem {
		internal bool populateFrom(any payload) {
			return true;
		}
	}

	public partial class EnvProperties {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("appName", out var __) ? (__, true) : (default, false));
			if (ok) {
				string appName = default;
				if ((null != val)) {
					string _appName_ = default;
					(_appName_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					appName = _appName_;
				}
				this.AppName = appName;
			}
			(val, ok) = (it.TryGetValue("appRoot", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string appRoot = default;
				if ((null != val)) {
					string _appRoot_ = default;
					(_appRoot_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					appRoot = _appRoot_;
				}
				this.AppRoot = appRoot;
			}
			(val, ok) = (it.TryGetValue("language", out var ____) ? (____, true) : (default, false));
			if (ok) {
				string language = default;
				if ((null != val)) {
					string _language_ = default;
					(_language_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					language = _language_;
				}
				this.Language = language;
			}
			(val, ok) = (it.TryGetValue("machineId", out var _____) ? (_____, true) : (default, false));
			if (ok) {
				string machineId = default;
				if ((null != val)) {
					string _machineId_ = default;
					(_machineId_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					machineId = _machineId_;
				}
				this.MachineId = machineId;
			}
			(val, ok) = (it.TryGetValue("remoteName", out var ______) ? (______, true) : (default, false));
			if (ok) {
				string remoteName = default;
				if ((null != val)) {
					string _remoteName_ = default;
					(_remoteName_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					remoteName = _remoteName_;
				}
				this.RemoteName = remoteName;
			}
			(val, ok) = (it.TryGetValue("sessionId", out var _______) ? (_______, true) : (default, false));
			if (ok) {
				string sessionId = default;
				if ((null != val)) {
					string _sessionId_ = default;
					(_sessionId_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					sessionId = _sessionId_;
				}
				this.SessionId = sessionId;
			}
			(val, ok) = (it.TryGetValue("shell", out var ________) ? (________, true) : (default, false));
			if (ok) {
				string shell = default;
				if ((null != val)) {
					string _shell_ = default;
					(_shell_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					shell = _shell_;
				}
				this.Shell = shell;
			}
			(val, ok) = (it.TryGetValue("uriScheme", out var _________) ? (_________, true) : (default, false));
			if (ok) {
				string uriScheme = default;
				if ((null != val)) {
					string _uriScheme_ = default;
					(_uriScheme_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					uriScheme = _uriScheme_;
				}
				this.UriScheme = uriScheme;
			}
			return true;
		}
	}

	public partial class WorkspaceFoldersChangeEvent {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("added", out var __) ? (__, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] added = default;
				if ((null != val)) {
					any[] __coll__added = default;
					(__coll__added, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					added = new WorkspaceFolder[__coll__added.Length];
					int __idx__added = default;
					__idx__added = 0;
					foreach (var __item__added in __coll__added) {
						WorkspaceFolder __val__added = default;
						__val__added = new WorkspaceFolder();
						ok = __val__added.populateFrom(__item__added);
						if (!ok) {
							return false;
						}
						added[__idx__added] = __val__added;
						__idx__added = __idx__added + 1;
					}
				}
				this.Added = added;
			} else {
				return false;
			}
			(val, ok) = (it.TryGetValue("removed", out var ___) ? (___, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] removed = default;
				if ((null != val)) {
					any[] __coll__removed = default;
					(__coll__removed, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					removed = new WorkspaceFolder[__coll__removed.Length];
					int __idx__removed = default;
					__idx__removed = 0;
					foreach (var __item__removed in __coll__removed) {
						WorkspaceFolder __val__removed = default;
						__val__removed = new WorkspaceFolder();
						ok = __val__removed.populateFrom(__item__removed);
						if (!ok) {
							return false;
						}
						removed[__idx__removed] = __val__removed;
						__idx__removed = __idx__removed + 1;
					}
				}
				this.Removed = removed;
			} else {
				return false;
			}
			return true;
		}
	}

	public partial class WorkspaceProperties {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("name", out var __) ? (__, true) : (default, false));
			if (ok) {
				string name = default;
				if ((null != val)) {
					string _name_ = default;
					(_name_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					name = _name_;
				}
				this.Name = name;
			}
			(val, ok) = (it.TryGetValue("workspaceFile", out var ___) ? (___, true) : (default, false));
			if (ok) {
				string workspaceFile = default;
				if ((null != val)) {
					string _workspaceFile_ = default;
					(_workspaceFile_, ok) = (val is string) ? (((string)(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					workspaceFile = _workspaceFile_;
				}
				this.WorkspaceFile = workspaceFile;
			}
			(val, ok) = (it.TryGetValue("workspaceFolders", out var ____) ? (____, true) : (default, false));
			if (ok) {
				WorkspaceFolder[] workspaceFolders = default;
				if ((null != val)) {
					any[] __coll__workspaceFolders = default;
					(__coll__workspaceFolders, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					workspaceFolders = new WorkspaceFolder[__coll__workspaceFolders.Length];
					int __idx__workspaceFolders = default;
					__idx__workspaceFolders = 0;
					foreach (var __item__workspaceFolders in __coll__workspaceFolders) {
						WorkspaceFolder __val__workspaceFolders = default;
						__val__workspaceFolders = new WorkspaceFolder();
						ok = __val__workspaceFolders.populateFrom(__item__workspaceFolders);
						if (!ok) {
							return false;
						}
						workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders;
						__idx__workspaceFolders = __idx__workspaceFolders + 1;
					}
				}
				this.WorkspaceFolders = workspaceFolders;
			}
			return true;
		}
	}

	public partial class DiagnosticChangeEvent {
		internal bool populateFrom(any payload) {
			dict it = default;
			bool ok = default;
			any val = default;
			(it, ok) = (payload is dict) ? (((dict)(payload)), true) : (default, false);
			if (!ok) {
				return false;
			}
			(val, ok) = (it.TryGetValue("uris", out var __) ? (__, true) : (default, false));
			if (ok) {
				string[] uris = default;
				if ((null != val)) {
					any[] __coll__uris = default;
					(__coll__uris, ok) = (val is any[]) ? (((any[])(val)), true) : (default, false);
					if (!ok) {
						return false;
					}
					uris = new string[__coll__uris.Length];
					int __idx__uris = default;
					__idx__uris = 0;
					foreach (var __item__uris in __coll__uris) {
						string __val__uris = default;
						(__val__uris, ok) = (__item__uris is string) ? (((string)(__item__uris)), true) : (default, false);
						if (!ok) {
							return false;
						}
						uris[__idx__uris] = __val__uris;
						__idx__uris = __idx__uris + 1;
					}
				}
				this.Uris = uris;
			} else {
				return false;
			}
			return true;
		}
	}

}
