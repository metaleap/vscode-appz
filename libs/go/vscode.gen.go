package vscAppz
// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-golang.ts via github.com/metaleap/vscode-appz/src/gen/main.ts

// Represents the alignment of status bar items.
type StatusBarAlignment int
const (
	// Aligned to the left side.
	StatusBarAlignmentLeft StatusBarAlignment = 1

	// Aligned to the right side.
	StatusBarAlignmentRight StatusBarAlignment = 2
)

// Type Definition for Visual Studio Code 1.38 Extension API
// See https://code.visualstudio.com/api for more information
type Vscode interface {
	// Namespace for dealing with the current window of the editor. That is visible
	// and active editors, as well as, UI elements to show messages, selections, and
	// asking for user input.
	Window() Window

	// Namespace describing the environment the editor runs in.
	Env() Env

	// Namespace for dealing with the current workspace. A workspace is the representation
	// of the folder that has been opened. There is no workspace when just a file but not a
	// folder has been opened.
	// 
	// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
	// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
	// the editor-process so that they should be always used instead of nodejs-equivalents.
	Workspace() Workspace

	// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
	// like IntelliSense, code actions, diagnostics etc.
	// 
	// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
	// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
	// programming languages.
	// 
	// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
	// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
	// that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
	// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
	// 
	// ```javascript
	// languages.registerHoverProvider('javascript', {
	//  	provideHover(document, position, token) {
	//  		return new Hover('I am a hover!');
	//  	}
	// });
	// ```
	// 
	// Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
	// a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
	// a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
	// scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
	// the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
	// score is used for determining the order in which providers are asked to participate.
	Languages() Languages

	// Namespace for dealing with installed extensions. Extensions are represented
	// by an [extension](#Extension)-interface which enables reflection on them.
	// 
	// Extension writers can provide APIs to other extensions by returning their API public
	// surface from the `activate`-call.
	// 
	// ```javascript
	// export function activate(context: vscode.ExtensionContext) {
	//  	let api = {
	//  		sum(a, b) {
	//  			return a + b;
	//  		},
	//  		mul(a, b) {
	//  			return a * b;
	//  		}
	//  	};
	//  	// 'export' public api-surface
	//  	return api;
	// }
	// ```
	// When depending on the API of another extension add an `extensionDependency`-entry
	// to `package.json`, and use the [getExtension](#extensions.getExtension)-function
	// and the [exports](#Extension.exports)-property, like below:
	// 
	// ```javascript
	// let mathExt = extensions.getExtension('genius.math');
	// let importedApi = mathExt.exports;
	// 
	// console.log(importedApi.mul(42, 1));
	// ```
	Extensions() Extensions

	// Namespace for dealing with commands. In short, a command is a function with a
	// unique identifier. The function is sometimes also called _command handler_.
	// 
	// Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
	// and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
	// can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
	// 
	// * palette - Use the `commands`-section in `package.json` to make a command show in
	// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
	// * keybinding - Use the `keybindings`-section in `package.json` to enable
	// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
	// for your extension.
	// 
	// Commands from other extensions and from the editor itself are accessible to an extension. However,
	// when invoking an editor command not all argument types are supported.
	// 
	// This is a sample that registers a command handler and adds an entry for that command to the palette. First
	// register a command handler with the identifier `extension.sayHello`.
	// ```javascript
	// commands.registerCommand('extension.sayHello', () => {
	//  	window.showInformationMessage('Hello World!');
	// });
	// ```
	// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
	// ```json
	// {
	//  	"contributes": {
	//  		"commands": [{
	//  			"command": "extension.sayHello",
	//  			"title": "Hello World"
	//  		}]
	//  	}
	// }
	// ```
	Commands() Commands
}

// Namespace for dealing with the current window of the editor. That is visible
// and active editors, as well as, UI elements to show messages, selections, and
// asking for user input.
type Window interface {
	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage1(message string, items []string, andThen func(*string)) 

	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage1(message string, items []string, andThen func(*string)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage1(message string, items []string, andThen func(*string)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Opens an input box to ask the user for input.
	// 
	// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
	// returned value will be the string typed by the user or an empty string if the user did not type
	// anything but dismissed the input box with OK.
	// 
	// `options` ── Configures the behavior of the input box.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
	ShowInputBox(options *InputBoxOptions, token *Cancel, andThen func(*string)) 

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel, andThen func([]string)) 

	// Shows a selection list.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selection or `undefined`.
	ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel, andThen func(*string)) 

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel, andThen func([]QuickPickItem)) 

	// Shows a selection list.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected item or `undefined`.
	ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel, andThen func(*QuickPickItem)) 

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](#window.createStatusBarItem).
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
	// 
	// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
	// 
	// `andThen` ── A disposable which hides the status bar message.
	SetStatusBarMessage1(text string, hideAfterTimeout int, andThen func(*Disposable)) 

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](#window.createStatusBarItem).
	// 
	// *Note* that status bar messages stack and that they must be disposed when no
	// longer used.
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
	// 
	// `andThen` ── A disposable which hides the status bar message.
	SetStatusBarMessage2(text string, andThen func(*Disposable)) 

	// Shows a file save dialog to the user which allows to select a file
	// for saving-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `andThen` ── A promise that resolves to the selected resource or `undefined`.
	ShowSaveDialog(options SaveDialogOptions, andThen func(*string)) 

	// Shows a file open dialog to the user which allows to select a file
	// for opening-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `andThen` ── A promise that resolves to the selected resources or `undefined`.
	ShowOpenDialog(options OpenDialogOptions, andThen func([]string)) 

	// Shows a selection list of [workspace folders](#workspace.workspaceFolders) to pick from.
	// Returns `undefined` if no folder is open.
	// 
	// `options` ── Configures the behavior of the workspace folder list.
	// 
	// `andThen` ── A promise that resolves to the workspace folder or `undefined`.
	ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions, andThen func(*WorkspaceFolder)) 

	// Represents the current window's state.
	State(andThen func(WindowState)) 

	// An [event](#Event) which fires when the focus state of the current window
	// changes. The value of the event represents whether the window is focused.
	OnDidChangeWindowState(listener func(WindowState), andThen func(*Disposable)) 

	// Creates a status bar [item](#StatusBarItem).
	// 
	// `alignment` ── The alignment of the item.
	// 
	// `priority` ── The priority of the item. Higher values mean the item should be shown more to the left.
	// 
	// `andThen` ── A new status bar item.
	CreateStatusBarItem(alignment StatusBarAlignment, priority *int, andThen func(*StatusBarItem)) 
}
type implWindow struct{ *impl }

// Namespace describing the environment the editor runs in.
type Env interface {
	// Opens an *external* item, e.g. a http(s) or mailto-link, using the
	// default application.
	// 
	// *Note* that [`showTextDocument`](#window.showTextDocument) is the right
	// way to open a text document inside the editor, not this function.
	// 
	// `target` ── The uri that should be opened.
	// 
	// `andThen` ── A promise indicating if open was successful.
	OpenExternal(target string, andThen func(bool)) 

	// The application name of the editor, like 'VS Code'.
	AppName(andThen func(string)) 

	// The application root folder from which the editor is running.
	AppRoot(andThen func(string)) 

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	Language(andThen func(string)) 

	// A unique identifier for the computer.
	MachineId(andThen func(string)) 

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	RemoteName(andThen func(*string)) 

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	SessionId(andThen func(string)) 

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	Shell(andThen func(string)) 

	// The custom uri scheme the editor registers to in the operating system.
	UriScheme(andThen func(string)) 

	// Provides single-call access to numerous individual `Env` properties at once.
	Properties(then func(EnvProperties)) 
}
type implEnv struct{ *impl }

// Namespace for dealing with the current workspace. A workspace is the representation
// of the folder that has been opened. There is no workspace when just a file but not a
// folder has been opened.
// 
// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
// the editor-process so that they should be always used instead of nodejs-equivalents.
type Workspace interface {
	// The name of the workspace. `undefined` when no folder
	// has been opened.
	Name(andThen func(*string)) 

	// The location of the workspace file, for example:
	// 
	// `file:///Users/name/Development/myProject.code-workspace`
	// 
	// or
	// 
	// `untitled:1555503116870`
	// 
	// for a workspace that is untitled and not yet saved.
	// 
	// Depending on the workspace that is opened, the value will be:
	//   * `undefined` when no workspace or  a single folder is opened
	//   * the path of the workspace file as `Uri` otherwise. if the workspace
	// is untitled, the returned URI will use the `untitled:` scheme
	// 
	// The location can e.g. be used with the `vscode.openFolder` command to
	// open the workspace again after it has been closed.
	// 
	// **Example:**
	// ```typescript
	// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
	// ```
	// 
	// **Note:** it is not advised to use `workspace.workspaceFile` to write
	// configuration data into the file. You can use `workspace.getConfiguration().update()`
	// for that purpose which will work both when a single folder is opened as
	// well as an untitled or saved workspace.
	WorkspaceFile(andThen func(*string)) 

	// Save all dirty files.
	// 
	// `includeUntitled` ── Also save files that have been created during this session.
	// 
	// `andThen` ── A thenable that resolves when the files have been saved.
	SaveAll(includeUntitled bool, andThen func(bool)) 

	// An event that is emitted when a workspace folder is added or removed.
	OnDidChangeWorkspaceFolders(listener func(WorkspaceFoldersChangeEvent), andThen func(*Disposable)) 

	// Returns the [workspace folder](#WorkspaceFolder) that contains a given uri.
	// * returns `undefined` when the given uri doesn't match any workspace folder
	// * returns the *input* when the given uri is a workspace folder itself
	// 
	// `uri` ── An uri.
	// 
	// `andThen` ── A workspace folder or `undefined`
	GetWorkspaceFolder(uri string, andThen func(*WorkspaceFolder)) 

	// List of workspace folders or `undefined` when no folder is open.
	// *Note* that the first entry corresponds to the value of `rootPath`.
	WorkspaceFolders(andThen func([]WorkspaceFolder)) 

	// Find files across all [workspace folders](#workspace.workspaceFolders) in the workspace.
	// `findFiles('**​/*.js', '**​/node_modules/**', 10)`
	// 
	// `include` ── A [glob pattern](#GlobPattern) that defines the files to search for. The glob pattern
	// will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](#RelativePattern)
	// to restrict the search results to a [workspace folder](#WorkspaceFolder).
	// 
	// `exclude` ── A [glob pattern](#GlobPattern) that defines files and folders to exclude. The glob pattern
	// will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will
	// apply, when `null` no excludes will apply.
	// 
	// `maxResults` ── An upper-bound for the result.
	// 
	// `token` ── A token that can be used to signal cancellation to the underlying search engine.
	// 
	// `andThen` ── A thenable that resolves to an array of resource identifiers. Will return no results if no
	// [workspace folders](#workspace.workspaceFolders) are opened.
	FindFiles(include string, exclude *string, maxResults *int, token *Cancel, andThen func([]string)) 

	// Returns a path that is relative to the workspace folder or folders.
	// 
	// When there are no [workspace folders](#workspace.workspaceFolders) or when the path
	// is not contained in them, the input is returned.
	// 
	// `pathOrUri` ── A path or uri. When a uri is given its [fsPath](#Uri.fsPath) is used.
	// 
	// `includeWorkspaceFolder` ── When `true` and when the given path is contained inside a
	// workspace folder the name of the workspace is prepended. Defaults to `true` when there are
	// multiple workspace folders and `false` otherwise.
	// 
	// `andThen` ── A path relative to the root or the input.
	AsRelativePath(pathOrUri string, includeWorkspaceFolder bool, andThen func(*string)) 

	// Provides single-call access to numerous individual `Workspace` properties at once.
	Properties(then func(WorkspaceProperties)) 
}
type implWorkspace struct{ *impl }

// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
// like IntelliSense, code actions, diagnostics etc.
// 
// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
// programming languages.
// 
// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
// that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
// 
// ```javascript
// languages.registerHoverProvider('javascript', {
//  	provideHover(document, position, token) {
//  		return new Hover('I am a hover!');
//  	}
// });
// ```
// 
// Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
// a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
// a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
// scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
// the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
// score is used for determining the order in which providers are asked to participate.
type Languages interface {
	// Return the identifiers of all known languages.
	// 
	// `andThen` ── Promise resolving to an array of identifier strings.
	GetLanguages(andThen func([]string)) 

	// An [event](#Event) which fires when the global set of diagnostics changes. This is
	// newly added and removed diagnostics.
	OnDidChangeDiagnostics(listener func(DiagnosticChangeEvent), andThen func(*Disposable)) 
}
type implLanguages struct{ *impl }

// Namespace for dealing with installed extensions. Extensions are represented
// by an [extension](#Extension)-interface which enables reflection on them.
// 
// Extension writers can provide APIs to other extensions by returning their API public
// surface from the `activate`-call.
// 
// ```javascript
// export function activate(context: vscode.ExtensionContext) {
//  	let api = {
//  		sum(a, b) {
//  			return a + b;
//  		},
//  		mul(a, b) {
//  			return a * b;
//  		}
//  	};
//  	// 'export' public api-surface
//  	return api;
// }
// ```
// When depending on the API of another extension add an `extensionDependency`-entry
// to `package.json`, and use the [getExtension](#extensions.getExtension)-function
// and the [exports](#Extension.exports)-property, like below:
// 
// ```javascript
// let mathExt = extensions.getExtension('genius.math');
// let importedApi = mathExt.exports;
// 
// console.log(importedApi.mul(42, 1));
// ```
type Extensions interface {
	// An event which fires when `extensions.all` changes. This can happen when extensions are
	// installed, uninstalled, enabled or disabled.
	OnDidChange(listener func(), andThen func(*Disposable)) 
}
type implExtensions struct{ *impl }

// Namespace for dealing with commands. In short, a command is a function with a
// unique identifier. The function is sometimes also called _command handler_.
// 
// Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
// and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
// can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
// 
// * palette - Use the `commands`-section in `package.json` to make a command show in
// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
// * keybinding - Use the `keybindings`-section in `package.json` to enable
// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
// for your extension.
// 
// Commands from other extensions and from the editor itself are accessible to an extension. However,
// when invoking an editor command not all argument types are supported.
// 
// This is a sample that registers a command handler and adds an entry for that command to the palette. First
// register a command handler with the identifier `extension.sayHello`.
// ```javascript
// commands.registerCommand('extension.sayHello', () => {
//  	window.showInformationMessage('Hello World!');
// });
// ```
// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
// ```json
// {
//  	"contributes": {
//  		"commands": [{
//  			"command": "extension.sayHello",
//  			"title": "Hello World"
//  		}]
//  	}
// }
// ```
type Commands interface {
	// Registers a command that can be invoked via a keyboard shortcut,
	// a menu item, an action, or directly.
	// 
	// Registering a command with an existing command identifier twice
	// will cause an error.
	// 
	// `command` ── A unique identifier for the command.
	// 
	// `callback` ── A command handler function.
	// 
	// `andThen` ── Disposable which unregisters this command on disposal.
	RegisterCommand(command string, callback func([]any) any, andThen func(*Disposable)) 

	// Executes the command denoted by the given command identifier.
	// 
	// * *Note 1:* When executing an editor command not all types are allowed to
	// be passed as arguments. Allowed are the primitive types `string`, `boolean`,
	// `number`, `undefined`, and `null`, as well as [`Position`](#Position), [`Range`](#Range), [`Uri`](#Uri) and [`Location`](#Location).
	// * *Note 2:* There are no restrictions when executing commands that have been contributed
	// by extensions.
	// 
	// `command` ── Identifier of the command to execute.
	// 
	// `rest` ── Parameters passed to the command function.
	// 
	// `andThen` ── A thenable that resolves to the returned value of the given command. `undefined` when
	// the command handler function doesn't return anything.
	ExecuteCommand(command string, rest []any, andThen func(any)) 

	// Retrieve the list of all available commands. Commands starting an underscore are
	// treated as internal commands.
	// 
	// `filterInternal` ── Set `true` to not see internal commands (starting with an underscore)
	// 
	// `andThen` ── Thenable that resolves to a list of command ids.
	GetCommands(filterInternal bool, andThen func([]string)) 
}
type implCommands struct{ *impl }

// Options to configure the behavior of the message.
type MessageOptions struct {
	// Indicates that this message should be modal.
	Modal bool `json:"modal,omitempty"`
}

// Represents an action that is shown with an information, warning, or
// error message.
type MessageItem struct {
	// A short title like 'Retry', 'Open Log' etc.
	Title string `json:"title"`

	// A hint for modal dialogs that the item should be triggered
	// when the user cancels the dialog (e.g. by pressing the ESC
	// key).
	// 
	// Note: this option is ignored for non-modal messages.
	IsCloseAffordance bool `json:"isCloseAffordance,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behavior of the input box UI.
type InputBoxOptions struct {
	// The value to prefill in the input box.
	Value string `json:"value,omitempty"`

	// Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
	// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
	// word will be selected, when empty (start equals end) only the cursor will be set,
	// otherwise the defined range will be selected.
	ValueSelection []int `json:"valueSelection,omitempty"`

	// The text to display underneath the input box.
	Prompt string `json:"prompt,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to type.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to show a password prompt that will not show the typed value.
	Password bool `json:"password,omitempty"`

	// Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional function that will be called to validate input and to give a hint
	// to the user.
	// 
	// `value` ── The current value of the input box.
	// 
	// `return` ── A human readable string which is presented as diagnostic message.
	// Return `undefined`, `null`, or the empty string when 'value' is valid.
	ValidateInput func(string) string `json:"-"`
}

type _InputBoxOptions struct {
	*InputBoxOptions
	ValidateInput_AppzFuncId string `json:"validateInput_AppzFuncId,omitempty"`
}

// Options to configure the behavior of the quick pick UI.
type QuickPickOptions struct {
	// An optional flag to include the description when filtering the picks.
	MatchOnDescription bool `json:"matchOnDescription,omitempty"`

	// An optional flag to include the detail when filtering the picks.
	MatchOnDetail bool `json:"matchOnDetail,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional flag to make the picker accept multiple selections, if true the result is an array of picks.
	CanPickMany bool `json:"canPickMany,omitempty"`

	// An optional function that is invoked whenever an item is selected.
	OnDidSelectItem func(QuickPickItem) any `json:"-"`
}

type _QuickPickOptions struct {
	*QuickPickOptions
	OnDidSelectItem_AppzFuncId string `json:"onDidSelectItem_AppzFuncId,omitempty"`
}

// Represents an item that can be selected from
// a list of items.
type QuickPickItem struct {
	// A human readable string which is rendered prominent.
	Label string `json:"label"`

	// A human readable string which is rendered less prominent.
	Description string `json:"description,omitempty"`

	// A human readable string which is rendered less prominent.
	Detail string `json:"detail,omitempty"`

	// Optional flag indicating if this item is picked initially.
	// (Only honored when the picker allows multiple selections.)
	Picked bool `json:"picked,omitempty"`

	// Always show this item.
	AlwaysShow bool `json:"alwaysShow,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behaviour of a file save dialog.
type SaveDialogOptions struct {
	// The resource the dialog shows when opened.
	DefaultUri string `json:"defaultUri,omitempty"`

	// A human-readable string for the save button.
	SaveLabel string `json:"saveLabel,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// ```ts
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// ```
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of a file open dialog.
// 
// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
// which enforces to open either files or folder, but *not both*.
// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
// and the editor then silently adjusts the options to select files.
type OpenDialogOptions struct {
	// The resource the dialog shows when opened.
	DefaultUri string `json:"defaultUri,omitempty"`

	// A human-readable string for the open button.
	OpenLabel string `json:"openLabel,omitempty"`

	// Allow to select files, defaults to `true`.
	CanSelectFiles bool `json:"canSelectFiles,omitempty"`

	// Allow to select folders, defaults to `false`.
	CanSelectFolders bool `json:"canSelectFolders,omitempty"`

	// Allow to select many files or folders.
	CanSelectMany bool `json:"canSelectMany,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// ```ts
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// ```
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of the [workspace folder](#WorkspaceFolder) pick UI.
type WorkspaceFolderPickOptions struct {
	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`
}

// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
// are equal which means there is no notion of an active or master workspace folder.
type WorkspaceFolder struct {
	// The associated uri for this workspace folder.
	// 
	// *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
	// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
	Uri string `json:"uri"`

	// The name of this workspace folder. Defaults to
	// the basename of its [uri-path](#Uri.path)
	Name string `json:"name"`

	// The ordinal number of this workspace folder.
	Index int `json:"index"`
}

// Represents the state of a window.
type WindowState struct {
	// Whether the current window is focused.
	Focused bool `json:"focused"`
}

// A status bar item is a status bar contribution that can
// show text and icons and run a command on click.
type StatusBarItem struct {
}

// An event describing a change to the set of [workspace folders](#workspace.workspaceFolders).
type WorkspaceFoldersChangeEvent struct {
	// Added workspace folders.
	Added []WorkspaceFolder `json:"added"`

	// Removed workspace folders.
	Removed []WorkspaceFolder `json:"removed"`
}

// The event that is fired when diagnostics change.
type DiagnosticChangeEvent struct {
	// An array of resources for which diagnostics have changed.
	Uris []string `json:"uris"`
}

// Namespace describing the environment the editor runs in.
type EnvProperties struct {
	// The application name of the editor, like 'VS Code'.
	AppName string `json:"appName,omitempty"`

	// The application root folder from which the editor is running.
	AppRoot string `json:"appRoot,omitempty"`

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	Language string `json:"language,omitempty"`

	// A unique identifier for the computer.
	MachineId string `json:"machineId,omitempty"`

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	RemoteName string `json:"remoteName,omitempty"`

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	SessionId string `json:"sessionId,omitempty"`

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	Shell string `json:"shell,omitempty"`

	// The custom uri scheme the editor registers to in the operating system.
	UriScheme string `json:"uriScheme,omitempty"`
}

// Namespace for dealing with the current workspace. A workspace is the representation
// of the folder that has been opened. There is no workspace when just a file but not a
// folder has been opened.
// 
// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
// the editor-process so that they should be always used instead of nodejs-equivalents.
type WorkspaceProperties struct {
	// The name of the workspace. `undefined` when no folder
	// has been opened.
	Name string `json:"name,omitempty"`

	// The location of the workspace file, for example:
	// 
	// `file:///Users/name/Development/myProject.code-workspace`
	// 
	// or
	// 
	// `untitled:1555503116870`
	// 
	// for a workspace that is untitled and not yet saved.
	// 
	// Depending on the workspace that is opened, the value will be:
	//   * `undefined` when no workspace or  a single folder is opened
	//   * the path of the workspace file as `Uri` otherwise. if the workspace
	// is untitled, the returned URI will use the `untitled:` scheme
	// 
	// The location can e.g. be used with the `vscode.openFolder` command to
	// open the workspace again after it has been closed.
	// 
	// **Example:**
	// ```typescript
	// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
	// ```
	// 
	// **Note:** it is not advised to use `workspace.workspaceFile` to write
	// configuration data into the file. You can use `workspace.getConfiguration().update()`
	// for that purpose which will work both when a single folder is opened as
	// well as an untitled or saved workspace.
	WorkspaceFile string `json:"workspaceFile,omitempty"`

	// List of workspace folders or `undefined` when no folder is open.
	// *Note* that the first entry corresponds to the value of `rootPath`.
	WorkspaceFolders []WorkspaceFolder `json:"workspaceFolders,omitempty"`
}

func (me *impl) Window() Window {
	return implWindow{me}
}

func (me *impl) Env() Env {
	return implEnv{me}
}

func (me *impl) Workspace() Workspace {
	return implWorkspace{me}
}

func (me *impl) Languages() Languages {
	return implLanguages{me}
}

func (me *impl) Extensions() Extensions {
	return implExtensions{me}
}

func (me *impl) Commands() Commands {
	return implCommands{me}
}

func (me implWindow) ShowInformationMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowInformationMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowInformationMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowInformationMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowWarningMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowWarningMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowWarningMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowWarningMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowErrorMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowErrorMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowErrorMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowErrorMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowInputBox(options *InputBoxOptions, token *Cancel, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInputBox"
	msg.Data = make(dict, 2)
	var __options__ *_InputBoxOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_InputBoxOptions)
		__options__.InputBoxOptions = options
		__options__.ValidateInput_AppzFuncId = ""
		var fn func(string) string
		fn = __options__.ValidateInput
		if (nil != fn) {
			me.Lock()
			{
				__options__.ValidateInput_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.ValidateInput_AppzFuncId)
				me.Impl().cbOther[__options__.ValidateInput_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 string
						if (nil != args[0]) {
							__0, ok = args[0].(string)
							if !ok {
								return nil, false
							}
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	if (nil != options) {
		msg.Data["options"] = __options__
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == on) || on(payload)
	})
}

func (me implWindow) ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick1"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = &options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if !ok {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if !ok {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = __idx__result + 1
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == on) || on(payload)
	})
}

func (me implWindow) ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick2"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	if (nil != options) {
		msg.Data["options"] = __options__
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == on) || on(payload)
	})
}

func (me implWindow) ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel, andThen func([]QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick3"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = &options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []QuickPickItem
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if !ok {
					return false
				}
				result = make([]QuickPickItem, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result QuickPickItem
					__val__result = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
					ok = __val__result.populateFrom(__item__result)
					if !ok {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = __idx__result + 1
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == on) || on(payload)
	})
}

func (me implWindow) ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel, andThen func(*QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick4"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	if (nil != options) {
		msg.Data["options"] = __options__
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *QuickPickItem
			if (nil != payload) {
				result = new(QuickPickItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == on) || on(payload)
	})
}

func (me implWindow) SetStatusBarMessage1(text string, hideAfterTimeout int, andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage1"
	msg.Data = make(dict, 2)
	msg.Data["text"] = text
	msg.Data["hideAfterTimeout"] = hideAfterTimeout
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl()))
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) SetStatusBarMessage2(text string, andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage2"
	msg.Data = make(dict, 1)
	msg.Data["text"] = text
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl()))
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowSaveDialog(options SaveDialogOptions, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showSaveDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowOpenDialog(options OpenDialogOptions, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showOpenDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if !ok {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if !ok {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = __idx__result + 1
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions, andThen func(*WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWorkspaceFolderPick"
	msg.Data = make(dict, 1)
	if (nil != options) {
		msg.Data["options"] = options
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *WorkspaceFolder
			if (nil != payload) {
				result = new(WorkspaceFolder)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) State(andThen func(WindowState)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.state"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result WindowState
			if (nil != payload) {
				result = */*sorryButSuchIsCodeGenSometimes...*/new(WindowState)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) OnDidChangeWindowState(listener func(WindowState), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.onDidChangeWindowState"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me.Impl(), "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ WindowState
		_a_0_ = */*sorryButSuchIsCodeGenSometimes...*/new(WindowState)
		ok = _a_0_.populateFrom(args[0])
		if !ok {
			return false
		}
		listener(_a_0_)
		return true
	}, nil)
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWindow) CreateStatusBarItem(alignment StatusBarAlignment, priority *int, andThen func(*StatusBarItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.createStatusBarItem"
	msg.Data = make(dict, 2)
	if 0 != alignment {
		msg.Data["alignment"] = alignment
	}
	if (nil != priority) {
		msg.Data["priority"] = priority
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *StatusBarItem
			if (nil != payload) {
				result = new(StatusBarItem)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) OpenExternal(target string, andThen func(bool)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.openExternal"
	msg.Data = make(dict, 1)
	msg.Data["target"] = target
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result bool
			if (nil != payload) {
				result, ok = payload.(bool)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) AppName(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appName"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) AppRoot(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appRoot"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) Language(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.language"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) MachineId(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.machineId"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) RemoteName(andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.remoteName"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) SessionId(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.sessionId"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) Shell(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.shell"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) UriScheme(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.uriScheme"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implEnv) Properties(then func(EnvProperties)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.Properties"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != then) {
		on = func(payload any) bool {
			var ok bool
			var result EnvProperties
			if (nil != payload) {
				result = */*sorryButSuchIsCodeGenSometimes...*/new(EnvProperties)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			then(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) Name(andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.name"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) WorkspaceFile(andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.workspaceFile"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) SaveAll(includeUntitled bool, andThen func(bool)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.saveAll"
	msg.Data = make(dict, 1)
	msg.Data["includeUntitled"] = includeUntitled
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result bool
			if (nil != payload) {
				result, ok = payload.(bool)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) OnDidChangeWorkspaceFolders(listener func(WorkspaceFoldersChangeEvent), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.onDidChangeWorkspaceFolders"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me.Impl(), "Workspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ WorkspaceFoldersChangeEvent
		_a_0_ = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFoldersChangeEvent)
		ok = _a_0_.populateFrom(args[0])
		if !ok {
			return false
		}
		listener(_a_0_)
		return true
	}, nil)
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) GetWorkspaceFolder(uri string, andThen func(*WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.getWorkspaceFolder"
	msg.Data = make(dict, 1)
	msg.Data["uri"] = uri
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *WorkspaceFolder
			if (nil != payload) {
				result = new(WorkspaceFolder)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) WorkspaceFolders(andThen func([]WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.workspaceFolders"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []WorkspaceFolder
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if !ok {
					return false
				}
				result = make([]WorkspaceFolder, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result WorkspaceFolder
					__val__result = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFolder)
					ok = __val__result.populateFrom(__item__result)
					if !ok {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = __idx__result + 1
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) FindFiles(include string, exclude *string, maxResults *int, token *Cancel, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.findFiles"
	msg.Data = make(dict, 4)
	msg.Data["include"] = include
	if (nil != exclude) {
		msg.Data["exclude"] = exclude
	}
	if (nil != maxResults) {
		msg.Data["maxResults"] = maxResults
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if !ok {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if !ok {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = __idx__result + 1
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) AsRelativePath(pathOrUri string, includeWorkspaceFolder bool, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.asRelativePath"
	msg.Data = make(dict, 2)
	msg.Data["pathOrUri"] = pathOrUri
	msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if !ok {
					return false
				}
				result = &_result_
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implWorkspace) Properties(then func(WorkspaceProperties)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.Properties"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != then) {
		on = func(payload any) bool {
			var ok bool
			var result WorkspaceProperties
			if (nil != payload) {
				result = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceProperties)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			then(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implLanguages) GetLanguages(andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "languages.getLanguages"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if !ok {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if !ok {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = __idx__result + 1
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implLanguages) OnDidChangeDiagnostics(listener func(DiagnosticChangeEvent), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "languages.onDidChangeDiagnostics"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me.Impl(), "Languages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ DiagnosticChangeEvent
		_a_0_ = */*sorryButSuchIsCodeGenSometimes...*/new(DiagnosticChangeEvent)
		ok = _a_0_.populateFrom(args[0])
		if !ok {
			return false
		}
		listener(_a_0_)
		return true
	}, nil)
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implExtensions) OnDidChange(listener func(), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "extensions.onDidChange"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me.Impl(), "Extensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 0 != len(args) {
			return ok
		}
		listener()
		return true
	}, nil)
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implCommands) RegisterCommand(command string, callback func([]any) any, andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "commands.registerCommand"
	msg.Data = make(dict, 2)
	msg.Data["command"] = command
	var _fnid_callback string
	if (nil == callback) {
		OnError(me.Impl(), "Commands.RegisterCommand: the 'callback' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_callback = me.Impl().nextSub(nil, func(args []any) (any, bool) {
		var ok bool
		if 1 != len(args) {
			return nil, ok
		}
		var ret any
		var _a_0_ []any
		_a_0_, ok = args[0].([]any)
		if !ok {
			return nil, false
		}
		ret = callback(_a_0_)
		return ret, true
	})
	msg.Data["callback"] = _fnid_callback
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if !ok {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_callback))
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implCommands) ExecuteCommand(command string, rest []any, andThen func(any)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "commands.executeCommand"
	msg.Data = make(dict, 2)
	msg.Data["command"] = command
	msg.Data["rest"] = rest
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result any
			if (nil != payload) {
				result, ok = payload, true
				if ok {
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me implCommands) GetCommands(filterInternal bool, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "commands.getCommands"
	msg.Data = make(dict, 1)
	msg.Data["filterInternal"] = filterInternal
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if !ok {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if !ok {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = __idx__result + 1
				}
			}
			andThen(result)
			return true
		}
	}
	me.Impl().send(msg, on)
}

func (me *MessageItem) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["title"]
	if ok {
		var title string
		if (nil != val) {
			title, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Title = title
	} else {
		return false
	}
	val, ok = it["isCloseAffordance"]
	if ok {
		var isCloseAffordance bool
		if (nil != val) {
			isCloseAffordance, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.IsCloseAffordance = isCloseAffordance
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if !ok {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *QuickPickItem) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["label"]
	if ok {
		var label string
		if (nil != val) {
			label, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Label = label
	} else {
		return false
	}
	val, ok = it["description"]
	if ok {
		var description string
		if (nil != val) {
			description, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Description = description
	}
	val, ok = it["detail"]
	if ok {
		var detail string
		if (nil != val) {
			detail, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Detail = detail
	}
	val, ok = it["picked"]
	if ok {
		var picked bool
		if (nil != val) {
			picked, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Picked = picked
	}
	val, ok = it["alwaysShow"]
	if ok {
		var alwaysShow bool
		if (nil != val) {
			alwaysShow, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.AlwaysShow = alwaysShow
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if !ok {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *WorkspaceFolder) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["uri"]
	if ok {
		var uri string
		if (nil != val) {
			uri, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Uri = uri
	} else {
		return false
	}
	val, ok = it["name"]
	if ok {
		var name string
		if (nil != val) {
			name, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Name = name
	} else {
		return false
	}
	val, ok = it["index"]
	if ok {
		var index int
		if (nil != val) {
			index, ok = val.(int)
			if !ok {
				var __index__ float64
				__index__, ok = val.(float64)
				if !ok {
					return false
				}
				index = int(__index__)
			}
		}
		me.Index = index
	} else {
		return false
	}
	return true
}

func (me *WindowState) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["focused"]
	if ok {
		var focused bool
		if (nil != val) {
			focused, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Focused = focused
	} else {
		return false
	}
	return true
}

func (me *StatusBarItem) populateFrom(payload any) bool {
	return true
}

func (me *EnvProperties) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["appName"]
	if ok {
		var appName string
		if (nil != val) {
			appName, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.AppName = appName
	}
	val, ok = it["appRoot"]
	if ok {
		var appRoot string
		if (nil != val) {
			appRoot, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.AppRoot = appRoot
	}
	val, ok = it["language"]
	if ok {
		var language string
		if (nil != val) {
			language, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Language = language
	}
	val, ok = it["machineId"]
	if ok {
		var machineId string
		if (nil != val) {
			machineId, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.MachineId = machineId
	}
	val, ok = it["remoteName"]
	if ok {
		var remoteName string
		if (nil != val) {
			remoteName, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.RemoteName = remoteName
	}
	val, ok = it["sessionId"]
	if ok {
		var sessionId string
		if (nil != val) {
			sessionId, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.SessionId = sessionId
	}
	val, ok = it["shell"]
	if ok {
		var shell string
		if (nil != val) {
			shell, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Shell = shell
	}
	val, ok = it["uriScheme"]
	if ok {
		var uriScheme string
		if (nil != val) {
			uriScheme, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.UriScheme = uriScheme
	}
	return true
}

func (me *WorkspaceFoldersChangeEvent) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["added"]
	if ok {
		var added []WorkspaceFolder
		if (nil != val) {
			var __coll__added []any
			__coll__added, ok = val.([]any)
			if !ok {
				return false
			}
			added = make([]WorkspaceFolder, len(__coll__added))
			var __idx__added int
			__idx__added = 0
			for _, __item__added := range __coll__added {
				var __val__added WorkspaceFolder
				__val__added = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFolder)
				ok = __val__added.populateFrom(__item__added)
				if !ok {
					return false
				}
				added[__idx__added] = __val__added
				__idx__added = __idx__added + 1
			}
		}
		me.Added = added
	} else {
		return false
	}
	val, ok = it["removed"]
	if ok {
		var removed []WorkspaceFolder
		if (nil != val) {
			var __coll__removed []any
			__coll__removed, ok = val.([]any)
			if !ok {
				return false
			}
			removed = make([]WorkspaceFolder, len(__coll__removed))
			var __idx__removed int
			__idx__removed = 0
			for _, __item__removed := range __coll__removed {
				var __val__removed WorkspaceFolder
				__val__removed = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFolder)
				ok = __val__removed.populateFrom(__item__removed)
				if !ok {
					return false
				}
				removed[__idx__removed] = __val__removed
				__idx__removed = __idx__removed + 1
			}
		}
		me.Removed = removed
	} else {
		return false
	}
	return true
}

func (me *WorkspaceProperties) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["name"]
	if ok {
		var name string
		if (nil != val) {
			name, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Name = name
	}
	val, ok = it["workspaceFile"]
	if ok {
		var workspaceFile string
		if (nil != val) {
			workspaceFile, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.WorkspaceFile = workspaceFile
	}
	val, ok = it["workspaceFolders"]
	if ok {
		var workspaceFolders []WorkspaceFolder
		if (nil != val) {
			var __coll__workspaceFolders []any
			__coll__workspaceFolders, ok = val.([]any)
			if !ok {
				return false
			}
			workspaceFolders = make([]WorkspaceFolder, len(__coll__workspaceFolders))
			var __idx__workspaceFolders int
			__idx__workspaceFolders = 0
			for _, __item__workspaceFolders := range __coll__workspaceFolders {
				var __val__workspaceFolders WorkspaceFolder
				__val__workspaceFolders = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFolder)
				ok = __val__workspaceFolders.populateFrom(__item__workspaceFolders)
				if !ok {
					return false
				}
				workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders
				__idx__workspaceFolders = __idx__workspaceFolders + 1
			}
		}
		me.WorkspaceFolders = workspaceFolders
	}
	return true
}

func (me *DiagnosticChangeEvent) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["uris"]
	if ok {
		var uris []string
		if (nil != val) {
			var __coll__uris []any
			__coll__uris, ok = val.([]any)
			if !ok {
				return false
			}
			uris = make([]string, len(__coll__uris))
			var __idx__uris int
			__idx__uris = 0
			for _, __item__uris := range __coll__uris {
				var __val__uris string
				__val__uris, ok = __item__uris.(string)
				if !ok {
					return false
				}
				uris[__idx__uris] = __val__uris
				__idx__uris = __idx__uris + 1
			}
		}
		me.Uris = uris
	} else {
		return false
	}
	return true
}

