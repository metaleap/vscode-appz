package vscAppz
// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-golang.ts via github.com/metaleap/vscode-appz/src/gen/main.ts

// Type Definition for Visual Studio Code 1.38 Extension API
// See https://code.visualstudio.com/api for more information
type Vscode interface {
	// Namespace for dealing with the current window of the editor. That is visible
	// and active editors, as well as, UI elements to show messages, selections, and
	// asking for user input.
	Window() Window

	// Namespace describing the environment the editor runs in.
	Env() Env
}

// Namespace for dealing with the current window of the editor. That is visible
// and active editors, as well as, UI elements to show messages, selections, and
// asking for user input.
type Window interface {
	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage1(message string, items []string, andThen func(*string)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage1(message string, items []string, andThen func(*string)) 

	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage1(message string, items []string, andThen func(*string)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Opens an input box to ask the user for input.
	// 
	// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
	// returned value will be the string typed by the user or an empty string if the user did not type
	// anything but dismissed the input box with OK.
	// 
	// `options` ── Configures the behavior of the input box.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
	ShowInputBox(options *InputBoxOptions, token *Cancel, andThen func(*string)) 

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel, andThen func([]string)) 

	// Shows a selection list.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selection or `undefined`.
	ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel, andThen func(*string)) 

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel, andThen func([]QuickPickItem)) 

	// Shows a selection list.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected item or `undefined`.
	ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel, andThen func(*QuickPickItem)) 

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](#window.createStatusBarItem).
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
	// 
	// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
	// 
	// `andThen` ── A disposable which hides the status bar message.
	SetStatusBarMessage1(text string, hideAfterTimeout int, andThen func(*Disposable)) 

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](#window.createStatusBarItem).
	// 
	// *Note* that status bar messages stack and that they must be disposed when no
	// longer used.
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
	// 
	// `andThen` ── A disposable which hides the status bar message.
	SetStatusBarMessage2(text string, andThen func(*Disposable)) 

	// Shows a file save dialog to the user which allows to select a file
	// for saving-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `andThen` ── A promise that resolves to the selected resource or `undefined`.
	ShowSaveDialog(options SaveDialogOptions, andThen func(*string)) 

	// Shows a file open dialog to the user which allows to select a file
	// for opening-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `andThen` ── A promise that resolves to the selected resources or `undefined`.
	ShowOpenDialog(options OpenDialogOptions, andThen func([]string)) 

	// Shows a selection list of [workspace folders](#workspace.workspaceFolders) to pick from.
	// Returns `undefined` if no folder is open.
	// 
	// `options` ── Configures the behavior of the workspace folder list.
	// 
	// `andThen` ── A promise that resolves to the workspace folder or `undefined`.
	ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions, andThen func(*WorkspaceFolder)) 

	// Represents the current window's state.
	State(andThen func(WindowState)) 

	// An [event](#Event) which fires when the focus state of the current window
	// changes. The value of the event represents whether the window is focused.
	OnDidChangeWindowState(listener func(WindowState), andThen func(*Disposable)) 
}

// Namespace describing the environment the editor runs in.
type Env interface {
	// Opens an *external* item, e.g. a http(s) or mailto-link, using the
	// default application.
	// 
	// *Note* that [`showTextDocument`](#window.showTextDocument) is the right
	// way to open a text document inside the editor, not this function.
	// 
	// `target` ── The uri that should be opened.
	// 
	// `andThen` ── A promise indicating if open was successful.
	OpenExternal(target string, andThen func(bool)) 

	// The application name of the editor, like 'VS Code'.
	AppName(andThen func(string)) 

	// The application root folder from which the editor is running.
	AppRoot(andThen func(string)) 

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	Language(andThen func(string)) 

	// A unique identifier for the computer.
	MachineId(andThen func(string)) 

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	RemoteName(andThen func(*string)) 

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	SessionId(andThen func(string)) 

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	Shell(andThen func(string)) 

	// The custom uri scheme the editor registers to in the operating system.
	UriScheme(andThen func(string)) 

	// Provides single-call access to numerous individual `Env` properties at once.
	Properties(andThen func(EnvProperties)) 
}

// Options to configure the behavior of the message.
type MessageOptions struct {
	// Indicates that this message should be modal.
	Modal bool `json:"modal,omitempty"`
}

// Represents an action that is shown with an information, warning, or
// error message.
type MessageItem struct {
	// A short title like 'Retry', 'Open Log' etc.
	Title string `json:"title"`

	// A hint for modal dialogs that the item should be triggered
	// when the user cancels the dialog (e.g. by pressing the ESC
	// key).
	// 
	// Note: this option is ignored for non-modal messages.
	IsCloseAffordance bool `json:"isCloseAffordance,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behavior of the input box UI.
type InputBoxOptions struct {
	// The value to prefill in the input box.
	Value string `json:"value,omitempty"`

	// Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
	// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
	// word will be selected, when empty (start equals end) only the cursor will be set,
	// otherwise the defined range will be selected.
	ValueSelection []int `json:"valueSelection,omitempty"`

	// The text to display underneath the input box.
	Prompt string `json:"prompt,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to type.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to show a password prompt that will not show the typed value.
	Password bool `json:"password,omitempty"`

	// Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional function that will be called to validate input and to give a hint
	// to the user.
	// 
	// `value` ── The current value of the input box.
	// 
	// `return` ── A human readable string which is presented as diagnostic message.
	// Return `undefined`, `null`, or the empty string when 'value' is valid.
	ValidateInput func(string) string `json:"-"`
}

type _InputBoxOptions struct {
	*InputBoxOptions
	ValidateInput_AppzFuncId string `json:"validateInput_AppzFuncId,omitempty"`
}

// Options to configure the behavior of the quick pick UI.
type QuickPickOptions struct {
	// An optional flag to include the description when filtering the picks.
	MatchOnDescription bool `json:"matchOnDescription,omitempty"`

	// An optional flag to include the detail when filtering the picks.
	MatchOnDetail bool `json:"matchOnDetail,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional flag to make the picker accept multiple selections, if true the result is an array of picks.
	CanPickMany bool `json:"canPickMany,omitempty"`

	// An optional function that is invoked whenever an item is selected.
	OnDidSelectItem func(QuickPickItem) any `json:"-"`
}

type _QuickPickOptions struct {
	*QuickPickOptions
	OnDidSelectItem_AppzFuncId string `json:"onDidSelectItem_AppzFuncId,omitempty"`
}

// Represents an item that can be selected from
// a list of items.
type QuickPickItem struct {
	// A human readable string which is rendered prominent.
	Label string `json:"label"`

	// A human readable string which is rendered less prominent.
	Description string `json:"description,omitempty"`

	// A human readable string which is rendered less prominent.
	Detail string `json:"detail,omitempty"`

	// Optional flag indicating if this item is picked initially.
	// (Only honored when the picker allows multiple selections.)
	Picked bool `json:"picked,omitempty"`

	// Always show this item.
	AlwaysShow bool `json:"alwaysShow,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behaviour of a file save dialog.
type SaveDialogOptions struct {
	// A human-readable string for the save button.
	SaveLabel string `json:"saveLabel,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// ```ts
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// ```
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of a file open dialog.
// 
// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
// which enforces to open either files or folder, but *not both*.
// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
// and the editor then silently adjusts the options to select files.
type OpenDialogOptions struct {
	// A human-readable string for the open button.
	OpenLabel string `json:"openLabel,omitempty"`

	// Allow to select files, defaults to `true`.
	CanSelectFiles bool `json:"canSelectFiles,omitempty"`

	// Allow to select folders, defaults to `false`.
	CanSelectFolders bool `json:"canSelectFolders,omitempty"`

	// Allow to select many files or folders.
	CanSelectMany bool `json:"canSelectMany,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// ```ts
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// ```
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of the [workspace folder](#WorkspaceFolder) pick UI.
type WorkspaceFolderPickOptions struct {
	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`
}

// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
// are equal which means there is no notion of an active or master workspace folder.
type WorkspaceFolder struct {
	// The associated uri for this workspace folder.
	// 
	// *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
	// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
	Uri string `json:"uri"`

	// The name of this workspace folder. Defaults to
	// the basename of its [uri-path](#Uri.path)
	Name string `json:"name"`

	// The ordinal number of this workspace folder.
	Index int `json:"index"`
}

// Represents the state of a window.
type WindowState struct {
	// Whether the current window is focused.
	Focused bool `json:"focused"`
}

// Namespace describing the environment the editor runs in.
type EnvProperties struct {
	// The application name of the editor, like 'VS Code'.
	AppName string `json:"appName,omitempty"`

	// The application root folder from which the editor is running.
	AppRoot string `json:"appRoot,omitempty"`

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	Language string `json:"language,omitempty"`

	// A unique identifier for the computer.
	MachineId string `json:"machineId,omitempty"`

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	RemoteName string `json:"remoteName,omitempty"`

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	SessionId string `json:"sessionId,omitempty"`

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	Shell string `json:"shell,omitempty"`

	// The custom uri scheme the editor registers to in the operating system.
	UriScheme string `json:"uriScheme,omitempty"`
}

func (me *impl) Window() Window {
	return me
}

func (me *impl) Env() Env {
	return me
}

func (me *impl) ShowErrorMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowErrorMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowErrorMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowErrorMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowInformationMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowInformationMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowInformationMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowInformationMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowWarningMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowWarningMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowWarningMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowWarningMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowInputBox(options *InputBoxOptions, token *Cancel, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInputBox"
	msg.Data = make(dict, 2)
	var __options__ *_InputBoxOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_InputBoxOptions)
		__options__.InputBoxOptions = options
		__options__.ValidateInput_AppzFuncId = ""
		var fn func(string) string
		fn = __options__.ValidateInput
		if (nil != fn) {
			me.Lock()
			{
				__options__.ValidateInput_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.ValidateInput_AppzFuncId)
				me.cbOther[__options__.ValidateInput_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 string
						if (nil != args[0]) {
							__0, ok = args[0].(string)
							if (!ok) {
								return nil, false
							}
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me *impl) ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick1"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = (&options)
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me *impl) ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick2"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me *impl) ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel, andThen func([]QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick3"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = (&options)
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []QuickPickItem
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]QuickPickItem, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result QuickPickItem
					__val__result = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
					ok = __val__result.populateFrom(__item__result)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me *impl) ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel, andThen func(*QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick4"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *QuickPickItem
			if (nil != payload) {
				result = new(QuickPickItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me *impl) SetStatusBarMessage1(text string, hideAfterTimeout int, andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage1"
	msg.Data = make(dict, 2)
	msg.Data["text"] = text
	msg.Data["hideAfterTimeout"] = hideAfterTimeout
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me, ""))
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) SetStatusBarMessage2(text string, andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage2"
	msg.Data = make(dict, 1)
	msg.Data["text"] = text
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me, ""))
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowSaveDialog(options SaveDialogOptions, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showSaveDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowOpenDialog(options OpenDialogOptions, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showOpenDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions, andThen func(*WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWorkspaceFolderPick"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *WorkspaceFolder
			if (nil != payload) {
				result = new(WorkspaceFolder)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) State(andThen func(WindowState)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.state"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result WindowState
			if (nil != payload) {
				result = */*sorryButSuchIsCodeGenSometimes...*/new(WindowState)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) OnDidChangeWindowState(listener func(WindowState), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.onDidChangeWindowState"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me, "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.nextSub(func(args []any) bool {
		var ok bool
		if (1 != len(args)) {
			return false
		}
		var _a_0_ WindowState
		_a_0_ = */*sorryButSuchIsCodeGenSometimes...*/new(WindowState)
		ok = _a_0_.populateFrom(args[0])
		if (!ok) {
			return false
		}
		listener(_a_0_)
		return true
	})
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me, _fnid_listener))
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) OpenExternal(target string, andThen func(bool)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.openExternal"
	msg.Data = make(dict, 1)
	msg.Data["target"] = target
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result bool
			if (nil != payload) {
				result, ok = payload.(bool)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) AppName(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appName"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) AppRoot(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appRoot"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) Language(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.language"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) MachineId(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.machineId"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) RemoteName(andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.remoteName"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) SessionId(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.sessionId"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) Shell(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.shell"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) UriScheme(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.uriScheme"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *impl) Properties(andThen func(EnvProperties)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.Properties"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result EnvProperties
			if (nil != payload) {
				result = */*sorryButSuchIsCodeGenSometimes...*/new(EnvProperties)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *MessageItem) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["title"]
	if ok {
		var title string
		if (nil != val) {
			title, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Title = title
	} else {
		return false
	}
	val, ok = it["isCloseAffordance"]
	if ok {
		var isCloseAffordance bool
		if (nil != val) {
			isCloseAffordance, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.IsCloseAffordance = isCloseAffordance
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if (!ok) {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *QuickPickItem) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["label"]
	if ok {
		var label string
		if (nil != val) {
			label, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Label = label
	} else {
		return false
	}
	val, ok = it["description"]
	if ok {
		var description string
		if (nil != val) {
			description, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Description = description
	}
	val, ok = it["detail"]
	if ok {
		var detail string
		if (nil != val) {
			detail, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Detail = detail
	}
	val, ok = it["picked"]
	if ok {
		var picked bool
		if (nil != val) {
			picked, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.Picked = picked
	}
	val, ok = it["alwaysShow"]
	if ok {
		var alwaysShow bool
		if (nil != val) {
			alwaysShow, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.AlwaysShow = alwaysShow
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if (!ok) {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *WorkspaceFolder) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["uri"]
	if ok {
		var uri string
		if (nil != val) {
			uri, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Uri = uri
	} else {
		return false
	}
	val, ok = it["name"]
	if ok {
		var name string
		if (nil != val) {
			name, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Name = name
	} else {
		return false
	}
	val, ok = it["index"]
	if ok {
		var index int
		if (nil != val) {
			index, ok = val.(int)
			if (!ok) {
				var __index__ float64
				__index__, ok = val.(float64)
				if (!ok) {
					return false
				}
				index = int(__index__)
			}
		}
		me.Index = index
	} else {
		return false
	}
	return true
}

func (me *WindowState) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["focused"]
	if ok {
		var focused bool
		if (nil != val) {
			focused, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.Focused = focused
	} else {
		return false
	}
	return true
}

func (me *EnvProperties) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["appName"]
	if ok {
		var appName string
		if (nil != val) {
			appName, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.AppName = appName
	}
	val, ok = it["appRoot"]
	if ok {
		var appRoot string
		if (nil != val) {
			appRoot, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.AppRoot = appRoot
	}
	val, ok = it["language"]
	if ok {
		var language string
		if (nil != val) {
			language, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Language = language
	}
	val, ok = it["machineId"]
	if ok {
		var machineId string
		if (nil != val) {
			machineId, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.MachineId = machineId
	}
	val, ok = it["remoteName"]
	if ok {
		var remoteName string
		if (nil != val) {
			remoteName, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.RemoteName = remoteName
	}
	val, ok = it["sessionId"]
	if ok {
		var sessionId string
		if (nil != val) {
			sessionId, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.SessionId = sessionId
	}
	val, ok = it["shell"]
	if ok {
		var shell string
		if (nil != val) {
			shell, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Shell = shell
	}
	val, ok = it["uriScheme"]
	if ok {
		var uriScheme string
		if (nil != val) {
			uriScheme, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.UriScheme = uriScheme
	}
	return true
}

