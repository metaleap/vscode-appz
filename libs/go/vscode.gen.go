package vscAppz
// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-golang.ts via github.com/metaleap/vscode-appz/src/gen/main.ts

// Type Definition for Visual Studio Code 1.38 Extension API
// See https://code.visualstudio.com/api for more information
type Vscode interface {
	// Namespace for dealing with the current window of the editor. That is visible
	// and active editors, as well as, UI elements to show messages, selections, and
	// asking for user input.
	Window() Window

	// Namespace describing the environment the editor runs in.
	Env() Env

	// Namespace for dealing with the current workspace. A workspace is the representation
	// of the folder that has been opened. There is no workspace when just a file but not a
	// folder has been opened.
	// 
	// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
	// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
	// the editor-process so that they should be always used instead of nodejs-equivalents.
	Workspace() Workspace

	// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
	// like IntelliSense, code actions, diagnostics etc.
	// 
	// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
	// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
	// programming languages.
	// 
	// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
	// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
	// that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
	// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
	// 
	// ```javascript
	// languages.registerHoverProvider('javascript', {
	//  	provideHover(document, position, token) {
	//  		return new Hover('I am a hover!');
	//  	}
	// });
	// ```
	// 
	// Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
	// a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
	// a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
	// scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
	// the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
	// score is used for determining the order in which providers are asked to participate.
	Languages() Languages

	// Namespace for dealing with installed extensions. Extensions are represented
	// by an [extension](#Extension)-interface which enables reflection on them.
	// 
	// Extension writers can provide APIs to other extensions by returning their API public
	// surface from the `activate`-call.
	// 
	// ```javascript
	// export function activate(context: vscode.ExtensionContext) {
	//  	let api = {
	//  		sum(a, b) {
	//  			return a + b;
	//  		},
	//  		mul(a, b) {
	//  			return a * b;
	//  		}
	//  	};
	//  	// 'export' public api-surface
	//  	return api;
	// }
	// ```
	// When depending on the API of another extension add an `extensionDependency`-entry
	// to `package.json`, and use the [getExtension](#extensions.getExtension)-function
	// and the [exports](#Extension.exports)-property, like below:
	// 
	// ```javascript
	// let mathExt = extensions.getExtension('genius.math');
	// let importedApi = mathExt.exports;
	// 
	// console.log(importedApi.mul(42, 1));
	// ```
	Extensions() Extensions

	// Namespace for dealing with commands. In short, a command is a function with a
	// unique identifier. The function is sometimes also called _command handler_.
	// 
	// Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
	// and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
	// can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
	// 
	// * palette - Use the `commands`-section in `package.json` to make a command show in
	// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
	// * keybinding - Use the `keybindings`-section in `package.json` to enable
	// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
	// for your extension.
	// 
	// Commands from other extensions and from the editor itself are accessible to an extension. However,
	// when invoking an editor command not all argument types are supported.
	// 
	// This is a sample that registers a command handler and adds an entry for that command to the palette. First
	// register a command handler with the identifier `extension.sayHello`.
	// ```javascript
	// commands.registerCommand('extension.sayHello', () => {
	//  	window.showInformationMessage('Hello World!');
	// });
	// ```
	// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
	// ```json
	// {
	//  	"contributes": {
	//  		"commands": [{
	//  			"command": "extension.sayHello",
	//  			"title": "Hello World"
	//  		}]
	//  	}
	// }
	// ```
	Commands() Commands
}

// Namespace for dealing with the current window of the editor. That is visible
// and active editors, as well as, UI elements to show messages, selections, and
// asking for user input.
type Window interface {
	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage1(message string, items []string, andThen func(*string)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage1(message string, items []string, andThen func(*string)) 

	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage1(message string, items []string, andThen func(*string)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage2(message string, options MessageOptions, items []string, andThen func(*string)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage3(message string, items []MessageItem, andThen func(*MessageItem)) 

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `andThen` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) 

	// Opens an input box to ask the user for input.
	// 
	// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
	// returned value will be the string typed by the user or an empty string if the user did not type
	// anything but dismissed the input box with OK.
	// 
	// `options` ── Configures the behavior of the input box.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
	ShowInputBox(options *InputBoxOptions, token *Cancel, andThen func(*string)) 

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel, andThen func([]string)) 

	// Shows a selection list.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selection or `undefined`.
	ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel, andThen func(*string)) 

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel, andThen func([]QuickPickItem)) 

	// Shows a selection list.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `andThen` ── A promise that resolves to the selected item or `undefined`.
	ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel, andThen func(*QuickPickItem)) 

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](#window.createStatusBarItem).
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
	// 
	// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
	// 
	// `andThen` ── A disposable which hides the status bar message.
	SetStatusBarMessage1(text string, hideAfterTimeout int, andThen func(*Disposable)) 

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](#window.createStatusBarItem).
	// 
	// *Note* that status bar messages stack and that they must be disposed when no
	// longer used.
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
	// 
	// `andThen` ── A disposable which hides the status bar message.
	SetStatusBarMessage2(text string, andThen func(*Disposable)) 

	// Shows a file save dialog to the user which allows to select a file
	// for saving-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `andThen` ── A promise that resolves to the selected resource or `undefined`.
	ShowSaveDialog(options SaveDialogOptions, andThen func(*string)) 

	// Shows a file open dialog to the user which allows to select a file
	// for opening-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `andThen` ── A promise that resolves to the selected resources or `undefined`.
	ShowOpenDialog(options OpenDialogOptions, andThen func([]string)) 

	// Shows a selection list of [workspace folders](#workspace.workspaceFolders) to pick from.
	// Returns `undefined` if no folder is open.
	// 
	// `options` ── Configures the behavior of the workspace folder list.
	// 
	// `andThen` ── A promise that resolves to the workspace folder or `undefined`.
	ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions, andThen func(*WorkspaceFolder)) 

	// Represents the current window's state.
	State(andThen func(WindowState)) 

	// An [event](#Event) which fires when the focus state of the current window
	// changes. The value of the event represents whether the window is focused.
	OnDidChangeWindowState(listener func(WindowState), andThen func(*Disposable)) 
}
type implWindow struct{ *impl }

// Namespace describing the environment the editor runs in.
type Env interface {
	// Opens an *external* item, e.g. a http(s) or mailto-link, using the
	// default application.
	// 
	// *Note* that [`showTextDocument`](#window.showTextDocument) is the right
	// way to open a text document inside the editor, not this function.
	// 
	// `target` ── The uri that should be opened.
	// 
	// `andThen` ── A promise indicating if open was successful.
	OpenExternal(target string, andThen func(bool)) 

	// The application name of the editor, like 'VS Code'.
	AppName(andThen func(string)) 

	// The application root folder from which the editor is running.
	AppRoot(andThen func(string)) 

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	Language(andThen func(string)) 

	// A unique identifier for the computer.
	MachineId(andThen func(string)) 

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	RemoteName(andThen func(*string)) 

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	SessionId(andThen func(string)) 

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	Shell(andThen func(string)) 

	// The custom uri scheme the editor registers to in the operating system.
	UriScheme(andThen func(string)) 

	// Provides single-call access to numerous individual `Env` properties at once.
	Properties(andThen func(EnvProperties)) 
}
type implEnv struct{ *impl }

// Namespace for dealing with the current workspace. A workspace is the representation
// of the folder that has been opened. There is no workspace when just a file but not a
// folder has been opened.
// 
// The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
// events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
// the editor-process so that they should be always used instead of nodejs-equivalents.
type Workspace interface {
	// The name of the workspace. `undefined` when no folder
	// has been opened.
	Name(andThen func(*string)) 

	// Save all dirty files.
	// 
	// `includeUntitled` ── Also save files that have been created during this session.
	// 
	// `andThen` ── A thenable that resolves when the files have been saved.
	SaveAll(includeUntitled bool, andThen func(bool)) 

	// An event that is emitted when a workspace folder is added or removed.
	OnDidChangeWorkspaceFolders(listener func(WorkspaceFoldersChangeEvent), andThen func(*Disposable)) 
}
type implWorkspace struct{ *impl }

// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
// like IntelliSense, code actions, diagnostics etc.
// 
// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
// programming languages.
// 
// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
// that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
// 
// ```javascript
// languages.registerHoverProvider('javascript', {
//  	provideHover(document, position, token) {
//  		return new Hover('I am a hover!');
//  	}
// });
// ```
// 
// Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
// a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
// a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
// scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
// the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
// score is used for determining the order in which providers are asked to participate.
type Languages interface {
	// Return the identifiers of all known languages.
	// 
	// `andThen` ── Promise resolving to an array of identifier strings.
	GetLanguages(andThen func([]string)) 

	// An [event](#Event) which fires when the global set of diagnostics changes. This is
	// newly added and removed diagnostics.
	OnDidChangeDiagnostics(listener func(DiagnosticChangeEvent), andThen func(*Disposable)) 
}
type implLanguages struct{ *impl }

// Namespace for dealing with installed extensions. Extensions are represented
// by an [extension](#Extension)-interface which enables reflection on them.
// 
// Extension writers can provide APIs to other extensions by returning their API public
// surface from the `activate`-call.
// 
// ```javascript
// export function activate(context: vscode.ExtensionContext) {
//  	let api = {
//  		sum(a, b) {
//  			return a + b;
//  		},
//  		mul(a, b) {
//  			return a * b;
//  		}
//  	};
//  	// 'export' public api-surface
//  	return api;
// }
// ```
// When depending on the API of another extension add an `extensionDependency`-entry
// to `package.json`, and use the [getExtension](#extensions.getExtension)-function
// and the [exports](#Extension.exports)-property, like below:
// 
// ```javascript
// let mathExt = extensions.getExtension('genius.math');
// let importedApi = mathExt.exports;
// 
// console.log(importedApi.mul(42, 1));
// ```
type Extensions interface {
	// An event which fires when `extensions.all` changes. This can happen when extensions are
	// installed, uninstalled, enabled or disabled.
	OnDidChange(listener func(), andThen func(*Disposable)) 
}
type implExtensions struct{ *impl }

// Namespace for dealing with commands. In short, a command is a function with a
// unique identifier. The function is sometimes also called _command handler_.
// 
// Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
// and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
// can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
// 
// * palette - Use the `commands`-section in `package.json` to make a command show in
// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
// * keybinding - Use the `keybindings`-section in `package.json` to enable
// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
// for your extension.
// 
// Commands from other extensions and from the editor itself are accessible to an extension. However,
// when invoking an editor command not all argument types are supported.
// 
// This is a sample that registers a command handler and adds an entry for that command to the palette. First
// register a command handler with the identifier `extension.sayHello`.
// ```javascript
// commands.registerCommand('extension.sayHello', () => {
//  	window.showInformationMessage('Hello World!');
// });
// ```
// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
// ```json
// {
//  	"contributes": {
//  		"commands": [{
//  			"command": "extension.sayHello",
//  			"title": "Hello World"
//  		}]
//  	}
// }
// ```
type Commands interface {
	// Retrieve the list of all available commands. Commands starting an underscore are
	// treated as internal commands.
	// 
	// `filterInternal` ── Set `true` to not see internal commands (starting with an underscore)
	// 
	// `andThen` ── Thenable that resolves to a list of command ids.
	GetCommands(filterInternal bool, andThen func([]string)) 
}
type implCommands struct{ *impl }

// Options to configure the behavior of the message.
type MessageOptions struct {
	// Indicates that this message should be modal.
	Modal bool `json:"modal,omitempty"`
}

// Represents an action that is shown with an information, warning, or
// error message.
type MessageItem struct {
	// A short title like 'Retry', 'Open Log' etc.
	Title string `json:"title"`

	// A hint for modal dialogs that the item should be triggered
	// when the user cancels the dialog (e.g. by pressing the ESC
	// key).
	// 
	// Note: this option is ignored for non-modal messages.
	IsCloseAffordance bool `json:"isCloseAffordance,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behavior of the input box UI.
type InputBoxOptions struct {
	// The value to prefill in the input box.
	Value string `json:"value,omitempty"`

	// Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
	// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
	// word will be selected, when empty (start equals end) only the cursor will be set,
	// otherwise the defined range will be selected.
	ValueSelection []int `json:"valueSelection,omitempty"`

	// The text to display underneath the input box.
	Prompt string `json:"prompt,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to type.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to show a password prompt that will not show the typed value.
	Password bool `json:"password,omitempty"`

	// Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional function that will be called to validate input and to give a hint
	// to the user.
	// 
	// `value` ── The current value of the input box.
	// 
	// `return` ── A human readable string which is presented as diagnostic message.
	// Return `undefined`, `null`, or the empty string when 'value' is valid.
	ValidateInput func(string) string `json:"-"`
}

type _InputBoxOptions struct {
	*InputBoxOptions
	ValidateInput_AppzFuncId string `json:"validateInput_AppzFuncId,omitempty"`
}

// Options to configure the behavior of the quick pick UI.
type QuickPickOptions struct {
	// An optional flag to include the description when filtering the picks.
	MatchOnDescription bool `json:"matchOnDescription,omitempty"`

	// An optional flag to include the detail when filtering the picks.
	MatchOnDetail bool `json:"matchOnDetail,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional flag to make the picker accept multiple selections, if true the result is an array of picks.
	CanPickMany bool `json:"canPickMany,omitempty"`

	// An optional function that is invoked whenever an item is selected.
	OnDidSelectItem func(QuickPickItem) any `json:"-"`
}

type _QuickPickOptions struct {
	*QuickPickOptions
	OnDidSelectItem_AppzFuncId string `json:"onDidSelectItem_AppzFuncId,omitempty"`
}

// Represents an item that can be selected from
// a list of items.
type QuickPickItem struct {
	// A human readable string which is rendered prominent.
	Label string `json:"label"`

	// A human readable string which is rendered less prominent.
	Description string `json:"description,omitempty"`

	// A human readable string which is rendered less prominent.
	Detail string `json:"detail,omitempty"`

	// Optional flag indicating if this item is picked initially.
	// (Only honored when the picker allows multiple selections.)
	Picked bool `json:"picked,omitempty"`

	// Always show this item.
	AlwaysShow bool `json:"alwaysShow,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behaviour of a file save dialog.
type SaveDialogOptions struct {
	// A human-readable string for the save button.
	SaveLabel string `json:"saveLabel,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// ```ts
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// ```
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of a file open dialog.
// 
// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
// which enforces to open either files or folder, but *not both*.
// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
// and the editor then silently adjusts the options to select files.
type OpenDialogOptions struct {
	// A human-readable string for the open button.
	OpenLabel string `json:"openLabel,omitempty"`

	// Allow to select files, defaults to `true`.
	CanSelectFiles bool `json:"canSelectFiles,omitempty"`

	// Allow to select folders, defaults to `false`.
	CanSelectFolders bool `json:"canSelectFolders,omitempty"`

	// Allow to select many files or folders.
	CanSelectMany bool `json:"canSelectMany,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// ```ts
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// ```
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of the [workspace folder](#WorkspaceFolder) pick UI.
type WorkspaceFolderPickOptions struct {
	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`
}

// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
// are equal which means there is no notion of an active or master workspace folder.
type WorkspaceFolder struct {
	// The associated uri for this workspace folder.
	// 
	// *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
	// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
	Uri string `json:"uri"`

	// The name of this workspace folder. Defaults to
	// the basename of its [uri-path](#Uri.path)
	Name string `json:"name"`

	// The ordinal number of this workspace folder.
	Index int `json:"index"`
}

// Represents the state of a window.
type WindowState struct {
	// Whether the current window is focused.
	Focused bool `json:"focused"`
}

// An event describing a change to the set of [workspace folders](#workspace.workspaceFolders).
type WorkspaceFoldersChangeEvent struct {
	// Added workspace folders.
	Added []WorkspaceFolder `json:"added"`

	// Removed workspace folders.
	Removed []WorkspaceFolder `json:"removed"`
}

// The event that is fired when diagnostics change.
type DiagnosticChangeEvent struct {
	// An array of resources for which diagnostics have changed.
	Uris []string `json:"uris"`
}

// Namespace describing the environment the editor runs in.
type EnvProperties struct {
	// The application name of the editor, like 'VS Code'.
	AppName string `json:"appName,omitempty"`

	// The application root folder from which the editor is running.
	AppRoot string `json:"appRoot,omitempty"`

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	Language string `json:"language,omitempty"`

	// A unique identifier for the computer.
	MachineId string `json:"machineId,omitempty"`

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	RemoteName string `json:"remoteName,omitempty"`

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	SessionId string `json:"sessionId,omitempty"`

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	Shell string `json:"shell,omitempty"`

	// The custom uri scheme the editor registers to in the operating system.
	UriScheme string `json:"uriScheme,omitempty"`
}

func (me *impl) Window() Window {
	return implWindow{me}
}

func (me *impl) Env() Env {
	return implEnv{me}
}

func (me *impl) Workspace() Workspace {
	return implWorkspace{me}
}

func (me *impl) Languages() Languages {
	return implLanguages{me}
}

func (me *impl) Extensions() Extensions {
	return implExtensions{me}
}

func (me *impl) Commands() Commands {
	return implCommands{me}
}

func (me implWindow) ShowErrorMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowErrorMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowErrorMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowErrorMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowInformationMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowInformationMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowInformationMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowInformationMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowWarningMessage1(message string, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowWarningMessage2(message string, options MessageOptions, items []string, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowWarningMessage3(message string, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowWarningMessage4(message string, options MessageOptions, items []MessageItem, andThen func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *MessageItem
			if (nil != payload) {
				result = new(MessageItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowInputBox(options *InputBoxOptions, token *Cancel, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInputBox"
	msg.Data = make(dict, 2)
	var __options__ *_InputBoxOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_InputBoxOptions)
		__options__.InputBoxOptions = options
		__options__.ValidateInput_AppzFuncId = ""
		var fn func(string) string
		fn = __options__.ValidateInput
		if (nil != fn) {
			me.Lock()
			{
				__options__.ValidateInput_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.ValidateInput_AppzFuncId)
				me.cbOther[__options__.ValidateInput_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 string
						if (nil != args[0]) {
							__0, ok = args[0].(string)
							if (!ok) {
								return nil, false
							}
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me implWindow) ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick1"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = (&options)
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me implWindow) ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick2"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me implWindow) ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel, andThen func([]QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick3"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = (&options)
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []QuickPickItem
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]QuickPickItem, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result QuickPickItem
					__val__result = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
					ok = __val__result.populateFrom(__item__result)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me implWindow) ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel, andThen func(*QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick4"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if (1 != len(args)) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							__0 = */*sorryButSuchIsCodeGenSometimes...*/new(QuickPickItem)
							ok = __0.populateFrom(args[0])
							if (!ok) {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if ("" == token.fnId) {
			me.Lock()
			{
				token.fnId = me.nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *QuickPickItem
			if (nil != payload) {
				result = new(QuickPickItem)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, func(payload any) bool {
		if (len(fnids) != 0) {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return ((nil == on) || on(payload))
	})
}

func (me implWindow) SetStatusBarMessage1(text string, hideAfterTimeout int, andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage1"
	msg.Data = make(dict, 2)
	msg.Data["text"] = text
	msg.Data["hideAfterTimeout"] = hideAfterTimeout
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), ""))
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) SetStatusBarMessage2(text string, andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage2"
	msg.Data = make(dict, 1)
	msg.Data["text"] = text
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), ""))
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowSaveDialog(options SaveDialogOptions, andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showSaveDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowOpenDialog(options OpenDialogOptions, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showOpenDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions, andThen func(*WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWorkspaceFolderPick"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *WorkspaceFolder
			if (nil != payload) {
				result = new(WorkspaceFolder)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) State(andThen func(WindowState)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.state"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result WindowState
			if (nil != payload) {
				result = */*sorryButSuchIsCodeGenSometimes...*/new(WindowState)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWindow) OnDidChangeWindowState(listener func(WindowState), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.onDidChangeWindowState"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me, "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.nextSub(func(args []any) bool {
		var ok bool
		if (1 != len(args)) {
			return ok
		}
		var _a_0_ WindowState
		_a_0_ = */*sorryButSuchIsCodeGenSometimes...*/new(WindowState)
		ok = _a_0_.populateFrom(args[0])
		if (!ok) {
			return false
		}
		listener(_a_0_)
		return true
	})
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) OpenExternal(target string, andThen func(bool)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.openExternal"
	msg.Data = make(dict, 1)
	msg.Data["target"] = target
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result bool
			if (nil != payload) {
				result, ok = payload.(bool)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) AppName(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appName"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) AppRoot(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appRoot"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) Language(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.language"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) MachineId(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.machineId"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) RemoteName(andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.remoteName"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) SessionId(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.sessionId"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) Shell(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.shell"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) UriScheme(andThen func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.uriScheme"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result string
			if (nil != payload) {
				result, ok = payload.(string)
				if (!ok) {
					return false
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implEnv) Properties(andThen func(EnvProperties)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.Properties"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result EnvProperties
			if (nil != payload) {
				result = */*sorryButSuchIsCodeGenSometimes...*/new(EnvProperties)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWorkspace) Name(andThen func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.name"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *string
			if (nil != payload) {
				var _result_ string
				_result_, ok = payload.(string)
				if (!ok) {
					return false
				}
				result = (&_result_)
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWorkspace) SaveAll(includeUntitled bool, andThen func(bool)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.saveAll"
	msg.Data = make(dict, 1)
	msg.Data["includeUntitled"] = includeUntitled
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result bool
			if (nil != payload) {
				result, ok = payload.(bool)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implWorkspace) OnDidChangeWorkspaceFolders(listener func(WorkspaceFoldersChangeEvent), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.onDidChangeWorkspaceFolders"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me, "Workspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.nextSub(func(args []any) bool {
		var ok bool
		if (1 != len(args)) {
			return ok
		}
		var _a_0_ WorkspaceFoldersChangeEvent
		_a_0_ = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFoldersChangeEvent)
		ok = _a_0_.populateFrom(args[0])
		if (!ok) {
			return false
		}
		listener(_a_0_)
		return true
	})
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.send(msg, on)
}

func (me implLanguages) GetLanguages(andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "languages.getLanguages"
	msg.Data = make(dict, 0)
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me implLanguages) OnDidChangeDiagnostics(listener func(DiagnosticChangeEvent), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "languages.onDidChangeDiagnostics"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me, "Languages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.nextSub(func(args []any) bool {
		var ok bool
		if (1 != len(args)) {
			return ok
		}
		var _a_0_ DiagnosticChangeEvent
		_a_0_ = */*sorryButSuchIsCodeGenSometimes...*/new(DiagnosticChangeEvent)
		ok = _a_0_.populateFrom(args[0])
		if (!ok) {
			return false
		}
		listener(_a_0_)
		return true
	})
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.send(msg, on)
}

func (me implExtensions) OnDidChange(listener func(), andThen func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "extensions.onDidChange"
	msg.Data = make(dict, 1)
	var _fnid_listener string
	if (nil == listener) {
		OnError(me, "Extensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return 
	}
	_fnid_listener = me.nextSub(func(args []any) bool {
		var ok bool
		if (0 != len(args)) {
			return ok
		}
		listener()
		return true
	})
	msg.Data["listener"] = _fnid_listener
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result *Disposable
			if (nil != payload) {
				result = new(Disposable)
				ok = result.populateFrom(payload)
				if (!ok) {
					return false
				}
			} else {
				return false
			}
			andThen(result.bind(me.Impl(), _fnid_listener))
			return true
		}
	}
	me.send(msg, on)
}

func (me implCommands) GetCommands(filterInternal bool, andThen func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "commands.getCommands"
	msg.Data = make(dict, 1)
	msg.Data["filterInternal"] = filterInternal
	var on func(any) bool
	if (nil != andThen) {
		on = func(payload any) bool {
			var ok bool
			var result []string
			if (nil != payload) {
				var __coll__result []any
				__coll__result, ok = payload.([]any)
				if (!ok) {
					return false
				}
				result = make([]string, len(__coll__result))
				var __idx__result int
				__idx__result = 0
				for _, __item__result := range __coll__result {
					var __val__result string
					__val__result, ok = __item__result.(string)
					if (!ok) {
						return false
					}
					result[__idx__result] = __val__result
					__idx__result = (__idx__result + 1)
				}
			}
			andThen(result)
			return true
		}
	}
	me.send(msg, on)
}

func (me *MessageItem) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["title"]
	if ok {
		var title string
		if (nil != val) {
			title, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Title = title
	} else {
		return false
	}
	val, ok = it["isCloseAffordance"]
	if ok {
		var isCloseAffordance bool
		if (nil != val) {
			isCloseAffordance, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.IsCloseAffordance = isCloseAffordance
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if (!ok) {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *QuickPickItem) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["label"]
	if ok {
		var label string
		if (nil != val) {
			label, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Label = label
	} else {
		return false
	}
	val, ok = it["description"]
	if ok {
		var description string
		if (nil != val) {
			description, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Description = description
	}
	val, ok = it["detail"]
	if ok {
		var detail string
		if (nil != val) {
			detail, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Detail = detail
	}
	val, ok = it["picked"]
	if ok {
		var picked bool
		if (nil != val) {
			picked, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.Picked = picked
	}
	val, ok = it["alwaysShow"]
	if ok {
		var alwaysShow bool
		if (nil != val) {
			alwaysShow, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.AlwaysShow = alwaysShow
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if (!ok) {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *WorkspaceFolder) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["uri"]
	if ok {
		var uri string
		if (nil != val) {
			uri, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Uri = uri
	} else {
		return false
	}
	val, ok = it["name"]
	if ok {
		var name string
		if (nil != val) {
			name, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Name = name
	} else {
		return false
	}
	val, ok = it["index"]
	if ok {
		var index int
		if (nil != val) {
			index, ok = val.(int)
			if (!ok) {
				var __index__ float64
				__index__, ok = val.(float64)
				if (!ok) {
					return false
				}
				index = int(__index__)
			}
		}
		me.Index = index
	} else {
		return false
	}
	return true
}

func (me *WindowState) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["focused"]
	if ok {
		var focused bool
		if (nil != val) {
			focused, ok = val.(bool)
			if (!ok) {
				return false
			}
		}
		me.Focused = focused
	} else {
		return false
	}
	return true
}

func (me *EnvProperties) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["appName"]
	if ok {
		var appName string
		if (nil != val) {
			appName, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.AppName = appName
	}
	val, ok = it["appRoot"]
	if ok {
		var appRoot string
		if (nil != val) {
			appRoot, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.AppRoot = appRoot
	}
	val, ok = it["language"]
	if ok {
		var language string
		if (nil != val) {
			language, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Language = language
	}
	val, ok = it["machineId"]
	if ok {
		var machineId string
		if (nil != val) {
			machineId, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.MachineId = machineId
	}
	val, ok = it["remoteName"]
	if ok {
		var remoteName string
		if (nil != val) {
			remoteName, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.RemoteName = remoteName
	}
	val, ok = it["sessionId"]
	if ok {
		var sessionId string
		if (nil != val) {
			sessionId, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.SessionId = sessionId
	}
	val, ok = it["shell"]
	if ok {
		var shell string
		if (nil != val) {
			shell, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.Shell = shell
	}
	val, ok = it["uriScheme"]
	if ok {
		var uriScheme string
		if (nil != val) {
			uriScheme, ok = val.(string)
			if (!ok) {
				return false
			}
		}
		me.UriScheme = uriScheme
	}
	return true
}

func (me *WorkspaceFoldersChangeEvent) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["added"]
	if ok {
		var added []WorkspaceFolder
		if (nil != val) {
			var __coll__added []any
			__coll__added, ok = val.([]any)
			if (!ok) {
				return false
			}
			added = make([]WorkspaceFolder, len(__coll__added))
			var __idx__added int
			__idx__added = 0
			for _, __item__added := range __coll__added {
				var __val__added WorkspaceFolder
				__val__added = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFolder)
				ok = __val__added.populateFrom(__item__added)
				if (!ok) {
					return false
				}
				added[__idx__added] = __val__added
				__idx__added = (__idx__added + 1)
			}
		}
		me.Added = added
	} else {
		return false
	}
	val, ok = it["removed"]
	if ok {
		var removed []WorkspaceFolder
		if (nil != val) {
			var __coll__removed []any
			__coll__removed, ok = val.([]any)
			if (!ok) {
				return false
			}
			removed = make([]WorkspaceFolder, len(__coll__removed))
			var __idx__removed int
			__idx__removed = 0
			for _, __item__removed := range __coll__removed {
				var __val__removed WorkspaceFolder
				__val__removed = */*sorryButSuchIsCodeGenSometimes...*/new(WorkspaceFolder)
				ok = __val__removed.populateFrom(__item__removed)
				if (!ok) {
					return false
				}
				removed[__idx__removed] = __val__removed
				__idx__removed = (__idx__removed + 1)
			}
		}
		me.Removed = removed
	} else {
		return false
	}
	return true
}

func (me *DiagnosticChangeEvent) populateFrom(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if (!ok) {
		return false
	}
	val, ok = it["uris"]
	if ok {
		var uris []string
		if (nil != val) {
			var __coll__uris []any
			__coll__uris, ok = val.([]any)
			if (!ok) {
				return false
			}
			uris = make([]string, len(__coll__uris))
			var __idx__uris int
			__idx__uris = 0
			for _, __item__uris := range __coll__uris {
				var __val__uris string
				__val__uris, ok = __item__uris.(string)
				if (!ok) {
					return false
				}
				uris[__idx__uris] = __val__uris
				__idx__uris = (__idx__uris + 1)
			}
		}
		me.Uris = uris
	} else {
		return false
	}
	return true
}

