package vscAppz

// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-golang.ts via github.com/metaleap/vscode-appz/src/gen/main.ts

// Represents the alignment of status bar items.
type StatusBarAlignment int
const (
	// Aligned to the left side.
	StatusBarAlignmentLeft StatusBarAlignment = 1

	// Aligned to the right side.
	StatusBarAlignmentRight StatusBarAlignment = 2
)

// Describes the behavior of decorations when typing/editing at their edges.
type DecorationRangeBehavior int
const (
	// The decoration's range will widen when edits occur at the start or end.
	DecorationRangeBehaviorOpenOpen DecorationRangeBehavior = 0

	// The decoration's range will not widen when edits occur at the start of end.
	DecorationRangeBehaviorClosedClosed DecorationRangeBehavior = 1

	// The decoration's range will widen when edits occur at the start, but not at the end.
	DecorationRangeBehaviorOpenClosed DecorationRangeBehavior = 2

	// The decoration's range will widen when edits occur at the end, but not at the start.
	DecorationRangeBehaviorClosedOpen DecorationRangeBehavior = 3
)

// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
// The overview ruler supports three lanes.
type OverviewRulerLane int
const (
	// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
	// The overview ruler supports three lanes.
	OverviewRulerLaneLeft OverviewRulerLane = 1

	// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
	// The overview ruler supports three lanes.
	OverviewRulerLaneCenter OverviewRulerLane = 2

	// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
	// The overview ruler supports three lanes.
	OverviewRulerLaneRight OverviewRulerLane = 4

	// Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
	// The overview ruler supports three lanes.
	OverviewRulerLaneFull OverviewRulerLane = 7
)

// Type Definition for Visual Studio Code 1.39 Extension API
// See https://code.visualstudio.com/api for more information
type Vscode interface {
	// Namespace for dealing with the current window of the editor. That is visible
	// and active editors, as well as, UI elements to show messages, selections, and
	// asking for user input.
	Window() Window

	// Namespace describing the environment the editor runs in.
	Env() Env

	// Namespace for dealing with the current workspace. A workspace is the representation
	// of the folder that has been opened. There is no workspace when just a file but not a
	// folder has been opened.
	// 
	// The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
	// events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
	// the editor-process so that they should be always used instead of nodejs-equivalents.
	Workspace() Workspace

	// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
	// like IntelliSense, code actions, diagnostics etc.
	// 
	// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
	// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
	// programming languages.
	// 
	// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
	// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
	// that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
	// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
	// 
	// 
	// ```javascript
	// 
	// languages.registerHoverProvider('javascript', {
	//  	provideHover(document, position, token) {
	//  		return new Hover('I am a hover!');
	//  	}
	// });
	// 
	// ```
	// 
	// 
	// Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
	// a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
	// a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
	// scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
	// the score is only checked to be `>0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
	// score is used for determining the order in which providers are asked to participate.
	Languages() Languages

	// Namespace for dealing with installed extensions. Extensions are represented
	// by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
	// 
	// Extension writers can provide APIs to other extensions by returning their API public
	// surface from the `activate`-call.
	// 
	// 
	// ```javascript
	// 
	// export function activate(context: vscode.ExtensionContext) {
	//  	let api = {
	//  		sum(a, b) {
	//  			return a + b;
	//  		},
	//  		mul(a, b) {
	//  			return a * b;
	//  		}
	//  	};
	//  	// 'export' public api-surface
	//  	return api;
	// }
	// 
	// ```
	// 
	// When depending on the API of another extension add an `extensionDependency`-entry
	// to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
	// and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
	// 
	// 
	// ```javascript
	// 
	// let mathExt = extensions.getExtension('genius.math');
	// let importedApi = mathExt.exports;
	// 
	// console.log(importedApi.mul(42, 1));
	// 
	// ```
	// 
	Extensions() Extensions

	// Namespace for dealing with commands. In short, a command is a function with a
	// unique identifier. The function is sometimes also called _command handler_.
	// 
	// Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
	// and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
	// can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
	// 
	// * palette - Use the `commands`-section in `package.json` to make a command show in
	// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
	// * keybinding - Use the `keybindings`-section in `package.json` to enable
	// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
	// for your extension.
	// 
	// Commands from other extensions and from the editor itself are accessible to an extension. However,
	// when invoking an editor command not all argument types are supported.
	// 
	// This is a sample that registers a command handler and adds an entry for that command to the palette. First
	// register a command handler with the identifier `extension.sayHello`.
	// 
	// ```javascript
	// 
	// commands.registerCommand('extension.sayHello', () => {
	//  	window.showInformationMessage('Hello World!');
	// });
	// 
	// ```
	// 
	// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
	// 
	// ```json
	// 
	// {
	//  	"contributes": {
	//  		"commands": [{
	//  			"command": "extension.sayHello",
	//  			"title": "Hello World"
	//  		}]
	//  	}
	// }
	// 
	// ```
	// 
	Commands() Commands
}

// Namespace for dealing with the current window of the editor. That is visible
// and active editors, as well as, UI elements to show messages, selections, and
// asking for user input.
type Window interface {
	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage1(message string, items []string) func(func(*string))

	// Show an information message to users. Optionally provide an array of items which will be presented as
	// clickable buttons.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage2(message string, options MessageOptions, items []string) func(func(*string))

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage3(message string, items []MessageItem) func(func(*MessageItem))

	// Show an information message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowInformationMessage4(message string, options MessageOptions, items []MessageItem) func(func(*MessageItem))

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage1(message string, items []string) func(func(*string))

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage2(message string, options MessageOptions, items []string) func(func(*string))

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage3(message string, items []MessageItem) func(func(*MessageItem))

	// Show a warning message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowWarningMessage4(message string, options MessageOptions, items []MessageItem) func(func(*MessageItem))

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage1(message string, items []string) func(func(*string))

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage2(message string, options MessageOptions, items []string) func(func(*string))

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage3(message string, items []MessageItem) func(func(*MessageItem))

	// Show an error message.
	// 
	// `message` ── The message to show.
	// 
	// `options` ── Configures the behaviour of the message.
	// 
	// `items` ── A set of items that will be rendered as actions in the message.
	// 
	// `return` ── A thenable that resolves to the selected item or `undefined` when being dismissed.
	ShowErrorMessage4(message string, options MessageOptions, items []MessageItem) func(func(*MessageItem))

	// Opens an input box to ask the user for input.
	// 
	// The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
	// returned value will be the string typed by the user or an empty string if the user did not type
	// anything but dismissed the input box with OK.
	// 
	// `options` ── Configures the behavior of the input box.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `return` ── A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
	ShowInputBox(options *InputBoxOptions, token *Cancel) func(func(*string))

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `return` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel) func(func([]string))

	// Shows a selection list.
	// 
	// `items` ── An array of strings, or a promise that resolves to an array of strings.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `return` ── A promise that resolves to the selection or `undefined`.
	ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel) func(func(*string))

	// Shows a selection list allowing multiple selections.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `return` ── A promise that resolves to the selected items or `undefined`.
	ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel) func(func([]QuickPickItem))

	// Shows a selection list.
	// 
	// `items` ── An array of items, or a promise that resolves to an array of items.
	// 
	// `options` ── Configures the behavior of the selection list.
	// 
	// `token` ── A token that can be used to signal cancellation.
	// 
	// `return` ── A promise that resolves to the selected item or `undefined`.
	ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel) func(func(*QuickPickItem))

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem).
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).
	// 
	// `hideAfterTimeout` ── Timeout in milliseconds after which the message will be disposed.
	// 
	// `return` ── A disposable which hides the status bar message.
	SetStatusBarMessage1(text string, hideAfterTimeout int) func(func(*Disposable))

	// Set a message to the status bar. This is a short hand for the more powerful
	// status bar [items](https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem).
	// 
	// *Note* that status bar messages stack and that they must be disposed when no
	// longer used.
	// 
	// `text` ── The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).
	// 
	// `return` ── A disposable which hides the status bar message.
	SetStatusBarMessage2(text string) func(func(*Disposable))

	// Shows a file save dialog to the user which allows to select a file
	// for saving-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `return` ── A promise that resolves to the selected resource or `undefined`.
	ShowSaveDialog(options SaveDialogOptions) func(func(*string))

	// Shows a file open dialog to the user which allows to select a file
	// for opening-purposes.
	// 
	// `options` ── Options that control the dialog.
	// 
	// `return` ── A promise that resolves to the selected resources or `undefined`.
	ShowOpenDialog(options OpenDialogOptions) func(func([]string))

	// Shows a selection list of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) to pick from.
	// Returns `undefined` if no folder is open.
	// 
	// `options` ── Configures the behavior of the workspace folder list.
	// 
	// `return` ── A promise that resolves to the workspace folder or `undefined`.
	ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions) func(func(*WorkspaceFolder))

	// Represents the current window's state.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its `WindowState` result obtained.
	State() func(func(WindowState))

	// An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the focus state of the current window
	// changes. The value of the event represents whether the window is focused.
	// 
	// `listener` ── will be invoked whenever this event fires; mandatory, not optional.
	// 
	// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWindowState` event on `Dispose`.
	OnDidChangeWindowState(listener func(WindowState)) func(func(*Disposable))

	// Creates a status bar [item](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem).
	// 
	// `alignment` ── The alignment of the item.
	// 
	// `priority` ── The priority of the item. Higher values mean the item should be shown more to the left.
	// 
	// `return` ── A new status bar item.
	CreateStatusBarItem(alignment StatusBarAlignment, priority *int) func(func(*StatusBarItem))

	// Creates a new [output channel](https://code.visualstudio.com/api/references/vscode-api#OutputChannel) with the given name.
	// 
	// `name` ── Human-readable string which will be used to represent the channel in the UI.
	// 
	// `return` ── a thenable that resolves to the newly created `OutputChannel`.
	CreateOutputChannel(name string) func(func(*OutputChannel))

	// Create a TextEditorDecorationType that can be used to add decorations to text editors.
	// 
	// `options` ── Rendering options for the decoration type.
	// 
	// `return` ── A new decoration type instance.
	CreateTextEditorDecorationType(options DecorationRenderOptions) func(func(*TextEditorDecorationType))

	// Creates a [InputBox](https://code.visualstudio.com/api/references/vscode-api#InputBox) to let the user enter some text input.
	// 
	// Note that in many cases the more convenient [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox)
	// is easier to use. [window.createInputBox](https://code.visualstudio.com/api/references/vscode-api#window.createInputBox) should be used
	// when [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox) does not offer the required flexibility.
	// 
	// `return` ── A new [InputBox](https://code.visualstudio.com/api/references/vscode-api#InputBox).
	CreateInputBox() func(func(*InputBox))

	// Creates a [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick) to let the user pick an item from a list
	// of items of type T.
	// 
	// Note that in many cases the more convenient [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick)
	// is easier to use. [window.createQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.createQuickPick) should be used
	// when [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick) does not offer the required flexibility.
	// 
	// `return` ── A new [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick).
	CreateQuickPick() func(func(*QuickPick))
}
type implWindow struct{ *impl }

// Namespace describing the environment the editor runs in.
type Env interface {
	// Opens an *external* item, e.g. a http(s) or mailto-link, using the
	// default application.
	// 
	// *Note* that [`showTextDocument`](https://code.visualstudio.com/api/references/vscode-api#window.showTextDocument) is the right
	// way to open a text document inside the editor, not this function.
	// 
	// `target` ── The uri that should be opened.
	// 
	// `return` ── A promise indicating if open was successful.
	OpenExternal(target string) func(func(bool))

	// The application name of the editor, like 'VS Code'.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	AppName() func(func(string))

	// The application root folder from which the editor is running.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	AppRoot() func(func(string))

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	Language() func(func(string))

	// A unique identifier for the computer.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	MachineId() func(func(string))

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	RemoteName() func(func(*string))

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	SessionId() func(func(string))

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	Shell() func(func(string))

	// The custom uri scheme the editor registers to in the operating system.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	UriScheme() func(func(string))

	// Provides single-call access to numerous individual `Env` properties at once.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its `EnvBag` result obtained.
	AllProperties() func(func(EnvBag))

	// The clipboard provides read and write access to the system's clipboard.
	Clipboard() Clipboard
}
type implEnv struct{ *impl }

// The clipboard provides read and write access to the system's clipboard.
type Clipboard interface {
	// Read the current clipboard contents as text.
	// 
	// `return` ── A thenable that resolves to a string.
	ReadText() func(func(*string))

	// Writes text into the clipboard.
	// 
	// `value` ── 
	// 
	// `return` ── A thenable that resolves when writing happened.
	WriteText(value string) func(func())
}
type implClipboard struct{ *impl }

// Namespace for dealing with the current workspace. A workspace is the representation
// of the folder that has been opened. There is no workspace when just a file but not a
// folder has been opened.
// 
// The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
// events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
// the editor-process so that they should be always used instead of nodejs-equivalents.
type Workspace interface {
	// The name of the workspace. `undefined` when no folder
	// has been opened.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	Name() func(func(*string))

	// The location of the workspace file, for example:
	// 
	// `file:///Users/name/Development/myProject.code-workspace`
	// 
	// or
	// 
	// `untitled:1555503116870`
	// 
	// for a workspace that is untitled and not yet saved.
	// 
	// Depending on the workspace that is opened, the value will be:
	//   * `undefined` when no workspace or  a single folder is opened
	//   * the path of the workspace file as `Uri` otherwise. if the workspace
	// is untitled, the returned URI will use the `untitled:` scheme
	// 
	// The location can e.g. be used with the `vscode.openFolder` command to
	// open the workspace again after it has been closed.
	// 
	// **Example:**
	// 
	// ```typescript
	// 
	// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
	// 
	// ```
	// 
	// 
	// **Note:** it is not advised to use `workspace.workspaceFile` to write
	// configuration data into the file. You can use `workspace.getConfiguration().update()`
	// for that purpose which will work both when a single folder is opened as
	// well as an untitled or saved workspace.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	WorkspaceFile() func(func(*string))

	// Save all dirty files.
	// 
	// `includeUntitled` ── Also save files that have been created during this session.
	// 
	// `return` ── A thenable that resolves when the files have been saved.
	SaveAll(includeUntitled bool) func(func(bool))

	// An event that is emitted when a workspace folder is added or removed.
	// 
	// `listener` ── will be invoked whenever this event fires; mandatory, not optional.
	// 
	// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWorkspaceFolders` event on `Dispose`.
	OnDidChangeWorkspaceFolders(listener func(WorkspaceFoldersChangeEvent)) func(func(*Disposable))

	// Returns the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) that contains a given uri.
	// * returns `undefined` when the given uri doesn't match any workspace folder
	// * returns the *input* when the given uri is a workspace folder itself
	// 
	// `uri` ── An uri.
	// 
	// `return` ── A workspace folder or `undefined`
	GetWorkspaceFolder(uri string) func(func(*WorkspaceFolder))

	// List of workspace folders or `undefined` when no folder is open.
	// *Note* that the first entry corresponds to the value of `rootPath`.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its result obtained.
	WorkspaceFolders() func(func([]WorkspaceFolder))

	// Find files across all [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) in the workspace.
	// `findFiles('**​/*.js', '**​/node_modules/**', 10)`
	// 
	// `include` ── A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines the files to search for. The glob pattern
	// will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern)
	// to restrict the search results to a [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder).
	// 
	// `exclude` ── A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines files and folders to exclude. The glob pattern
	// will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will
	// apply, when `null` no excludes will apply.
	// 
	// `maxResults` ── An upper-bound for the result.
	// 
	// `token` ── A token that can be used to signal cancellation to the underlying search engine.
	// 
	// `return` ── A thenable that resolves to an array of resource identifiers. Will return no results if no
	// [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) are opened.
	FindFiles(include string, exclude *string, maxResults *int, token *Cancel) func(func([]string))

	// Returns a path that is relative to the workspace folder or folders.
	// 
	// When there are no [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) or when the path
	// is not contained in them, the input is returned.
	// 
	// `pathOrUri` ── A path or uri. When a uri is given its [fsPath](https://code.visualstudio.com/api/references/vscode-api#Uri.fsPath) is used.
	// 
	// `includeWorkspaceFolder` ── When `true` and when the given path is contained inside a
	// workspace folder the name of the workspace is prepended. Defaults to `true` when there are
	// multiple workspace folders and `false` otherwise.
	// 
	// `return` ── A path relative to the root or the input.
	AsRelativePath(pathOrUri string, includeWorkspaceFolder bool) func(func(*string))

	// Provides single-call access to numerous individual `Workspace` properties at once.
	// 
	// `return` ── A thenable that resolves when this call has completed at the counterparty and its `WorkspaceBag` result obtained.
	AllProperties() func(func(WorkspaceBag))
}
type implWorkspace struct{ *impl }

// Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
// like IntelliSense, code actions, diagnostics etc.
// 
// Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
// like automatic word-completion, code navigation, or code checking have become popular across different tools for different
// programming languages.
// 
// The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
// by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
// that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
// mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
// 
// 
// ```javascript
// 
// languages.registerHoverProvider('javascript', {
//  	provideHover(document, position, token) {
//  		return new Hover('I am a hover!');
//  	}
// });
// 
// ```
// 
// 
// Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
// a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
// a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
// scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
// the score is only checked to be `>0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
// score is used for determining the order in which providers are asked to participate.
type Languages interface {
	// Return the identifiers of all known languages.
	// 
	// `return` ── Promise resolving to an array of identifier strings.
	GetLanguages() func(func([]string))

	// An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the global set of diagnostics changes. This is
	// newly added and removed diagnostics.
	// 
	// `listener` ── will be invoked whenever this event fires; mandatory, not optional.
	// 
	// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChangeDiagnostics` event on `Dispose`.
	OnDidChangeDiagnostics(listener func(DiagnosticChangeEvent)) func(func(*Disposable))
}
type implLanguages struct{ *impl }

// Namespace for dealing with installed extensions. Extensions are represented
// by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
// 
// Extension writers can provide APIs to other extensions by returning their API public
// surface from the `activate`-call.
// 
// 
// ```javascript
// 
// export function activate(context: vscode.ExtensionContext) {
//  	let api = {
//  		sum(a, b) {
//  			return a + b;
//  		},
//  		mul(a, b) {
//  			return a * b;
//  		}
//  	};
//  	// 'export' public api-surface
//  	return api;
// }
// 
// ```
// 
// When depending on the API of another extension add an `extensionDependency`-entry
// to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
// and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
// 
// 
// ```javascript
// 
// let mathExt = extensions.getExtension('genius.math');
// let importedApi = mathExt.exports;
// 
// console.log(importedApi.mul(42, 1));
// 
// ```
// 
type Extensions interface {
	// An event which fires when `extensions.all` changes. This can happen when extensions are
	// installed, uninstalled, enabled or disabled.
	// 
	// `listener` ── will be invoked whenever this event fires; mandatory, not optional.
	// 
	// `return` ── A `Disposable` that will unsubscribe `listener` from the `OnDidChange` event on `Dispose`.
	OnDidChange(listener func()) func(func(*Disposable))
}
type implExtensions struct{ *impl }

// Namespace for dealing with commands. In short, a command is a function with a
// unique identifier. The function is sometimes also called _command handler_.
// 
// Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
// and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
// can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
// 
// * palette - Use the `commands`-section in `package.json` to make a command show in
// the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
// * keybinding - Use the `keybindings`-section in `package.json` to enable
// [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
// for your extension.
// 
// Commands from other extensions and from the editor itself are accessible to an extension. However,
// when invoking an editor command not all argument types are supported.
// 
// This is a sample that registers a command handler and adds an entry for that command to the palette. First
// register a command handler with the identifier `extension.sayHello`.
// 
// ```javascript
// 
// commands.registerCommand('extension.sayHello', () => {
//  	window.showInformationMessage('Hello World!');
// });
// 
// ```
// 
// Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
// 
// ```json
// 
// {
//  	"contributes": {
//  		"commands": [{
//  			"command": "extension.sayHello",
//  			"title": "Hello World"
//  		}]
//  	}
// }
// 
// ```
// 
type Commands interface {
	// Registers a command that can be invoked via a keyboard shortcut,
	// a menu item, an action, or directly.
	// 
	// Registering a command with an existing command identifier twice
	// will cause an error.
	// 
	// `command` ── A unique identifier for the command.
	// 
	// `callback` ── A command handler function.
	// 
	// `return` ── Disposable which unregisters this command on disposal.
	RegisterCommand(command string, callback func([]any) any) func(func(*Disposable))

	// Executes the command denoted by the given command identifier.
	// 
	// * *Note 1:* When executing an editor command not all types are allowed to
	// be passed as arguments. Allowed are the primitive types `string`, `boolean`,
	// `number`, `undefined`, and `null`, as well as [`Position`](https://code.visualstudio.com/api/references/vscode-api#Position), [`Range`](#Range), [`Uri`](#Uri) and [`Location`](#Location).
	// * *Note 2:* There are no restrictions when executing commands that have been contributed
	// by extensions.
	// 
	// `command` ── Identifier of the command to execute.
	// 
	// `rest` ── Parameters passed to the command function.
	// 
	// `return` ── A thenable that resolves to the returned value of the given command. `undefined` when
	// the command handler function doesn't return anything.
	ExecuteCommand(command string, rest []any) func(func(any))

	// Retrieve the list of all available commands. Commands starting an underscore are
	// treated as internal commands.
	// 
	// `filterInternal` ── Set `true` to not see internal commands (starting with an underscore)
	// 
	// `return` ── Thenable that resolves to a list of command ids.
	GetCommands(filterInternal bool) func(func([]string))
}
type implCommands struct{ *impl }

// Represents theme specific rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).
type ThemableDecorationRenderOptions struct {
	// Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
	// Alternatively a color from the color registry can be [referenced](https://code.visualstudio.com/api/references/vscode-api#ThemeColor).
	BackgroundColor string `json:"backgroundColor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Outline string `json:"outline,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'outline' for setting one or more of the individual outline properties.
	OutlineColor string `json:"outlineColor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'outline' for setting one or more of the individual outline properties.
	OutlineStyle string `json:"outlineStyle,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'outline' for setting one or more of the individual outline properties.
	OutlineWidth string `json:"outlineWidth,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Border string `json:"border,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderColor string `json:"borderColor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderRadius string `json:"borderRadius,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderSpacing string `json:"borderSpacing,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderStyle string `json:"borderStyle,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderWidth string `json:"borderWidth,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	FontStyle string `json:"fontStyle,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	FontWeight string `json:"fontWeight,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	TextDecoration string `json:"textDecoration,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Cursor string `json:"cursor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Color string `json:"color,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Opacity string `json:"opacity,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	LetterSpacing string `json:"letterSpacing,omitempty"`

	// An **absolute path** or an URI to an image to be rendered in the gutter.
	GutterIconPath string `json:"gutterIconPath,omitempty"`

	// Specifies the size of the gutter icon.
	// Available values are 'auto', 'contain', 'cover' and any percentage value.
	// For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
	GutterIconSize string `json:"gutterIconSize,omitempty"`

	// The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.
	OverviewRulerColor string `json:"overviewRulerColor,omitempty"`

	// Defines the rendering options of the attachment that is inserted before the decorated text.
	Before ThemableDecorationAttachmentRenderOptions `json:"before,omitempty"`

	// Defines the rendering options of the attachment that is inserted after the decorated text.
	After ThemableDecorationAttachmentRenderOptions `json:"after,omitempty"`
}

// Options to configure the behavior of the message.
type MessageOptions struct {
	// Indicates that this message should be modal.
	Modal bool `json:"modal,omitempty"`
}

// Represents an action that is shown with an information, warning, or
// error message.
type MessageItem struct {
	// A short title like 'Retry', 'Open Log' etc.
	Title string `json:"title"`

	// A hint for modal dialogs that the item should be triggered
	// when the user cancels the dialog (e.g. by pressing the ESC
	// key).
	// 
	// Note: this option is ignored for non-modal messages.
	IsCloseAffordance bool `json:"isCloseAffordance,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behavior of the input box UI.
type InputBoxOptions struct {
	// The value to prefill in the input box.
	Value string `json:"value,omitempty"`

	// Selection of the prefilled [`value`](https://code.visualstudio.com/api/references/vscode-api#InputBoxOptions.value). Defined as tuple of two number where the
	// first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
	// word will be selected, when empty (start equals end) only the cursor will be set,
	// otherwise the defined range will be selected.
	ValueSelection []int `json:"valueSelection,omitempty"`

	// The text to display underneath the input box.
	Prompt string `json:"prompt,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to type.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to show a password prompt that will not show the typed value.
	Password bool `json:"password,omitempty"`

	// Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional function that will be called to validate input and to give a hint
	// to the user.
	// 
	// `value` ── The current value of the input box.
	// 
	// `return` ── A human readable string which is presented as diagnostic message.
	// Return `undefined`, `null`, or the empty string when 'value' is valid.
	ValidateInput func(string) string `json:"-"`
}

type _InputBoxOptions struct {
	*InputBoxOptions
	ValidateInput_AppzFuncId string `json:"validateInput_AppzFuncId,omitempty"`
}

// Options to configure the behavior of the quick pick UI.
type QuickPickOptions struct {
	// An optional flag to include the description when filtering the picks.
	MatchOnDescription bool `json:"matchOnDescription,omitempty"`

	// An optional flag to include the detail when filtering the picks.
	MatchOnDetail bool `json:"matchOnDetail,omitempty"`

	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`

	// An optional flag to make the picker accept multiple selections, if true the result is an array of picks.
	CanPickMany bool `json:"canPickMany,omitempty"`

	// An optional function that is invoked whenever an item is selected.
	OnDidSelectItem func(QuickPickItem) any `json:"-"`
}

type _QuickPickOptions struct {
	*QuickPickOptions
	OnDidSelectItem_AppzFuncId string `json:"onDidSelectItem_AppzFuncId,omitempty"`
}

// Represents an item that can be selected from
// a list of items.
type QuickPickItem struct {
	// A human readable string which is rendered prominent.
	Label string `json:"label"`

	// A human readable string which is rendered less prominent.
	Description string `json:"description,omitempty"`

	// A human readable string which is rendered less prominent.
	Detail string `json:"detail,omitempty"`

	// Optional flag indicating if this item is picked initially.
	// (Only honored when the picker allows multiple selections.)
	Picked bool `json:"picked,omitempty"`

	// Always show this item.
	AlwaysShow bool `json:"alwaysShow,omitempty"`

	// Free-form custom data, preserved across a roundtrip.
	My dict `json:"my,omitempty"`
}

// Options to configure the behaviour of a file save dialog.
type SaveDialogOptions struct {
	// The resource the dialog shows when opened.
	DefaultUri string `json:"defaultUri,omitempty"`

	// A human-readable string for the save button.
	SaveLabel string `json:"saveLabel,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// 
	// ```ts
	// 
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// 
	// ```
	// 
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of a file open dialog.
// 
// * Note 1: A dialog can select files, folders, or both. This is not true for Windows
// which enforces to open either files or folder, but *not both*.
// * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
// and the editor then silently adjusts the options to select files.
type OpenDialogOptions struct {
	// The resource the dialog shows when opened.
	DefaultUri string `json:"defaultUri,omitempty"`

	// A human-readable string for the open button.
	OpenLabel string `json:"openLabel,omitempty"`

	// Allow to select files, defaults to `true`.
	CanSelectFiles bool `json:"canSelectFiles,omitempty"`

	// Allow to select folders, defaults to `false`.
	CanSelectFolders bool `json:"canSelectFolders,omitempty"`

	// Allow to select many files or folders.
	CanSelectMany bool `json:"canSelectMany,omitempty"`

	// A set of file filters that are used by the dialog. Each entry is a human readable label,
	// like "TypeScript", and an array of extensions, e.g.
	// 
	// ```ts
	// 
	// {
	//  	'Images': ['png', 'jpg']
	//  	'TypeScript': ['ts', 'tsx']
	// }
	// 
	// ```
	// 
	Filters map[string][]string `json:"filters,omitempty"`
}

// Options to configure the behaviour of the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) pick UI.
type WorkspaceFolderPickOptions struct {
	// An optional string to show as place holder in the input box to guide the user what to pick on.
	PlaceHolder string `json:"placeHolder,omitempty"`

	// Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`
}

// A workspace folder is one of potentially many roots opened by the editor. All workspace folders
// are equal which means there is no notion of an active or master workspace folder.
type WorkspaceFolder struct {
	// The associated uri for this workspace folder.
	// 
	// *Note:* The [Uri](https://code.visualstudio.com/api/references/vscode-api#Uri)-type was intentionally chosen such that future releases of the editor can support
	// workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.
	Uri string `json:"uri"`

	// The name of this workspace folder. Defaults to
	// the basename of its [uri-path](https://code.visualstudio.com/api/references/vscode-api#Uri.path)
	Name string `json:"name"`

	// The ordinal number of this workspace folder.
	Index int `json:"index"`
}

// Represents the state of a window.
type WindowState struct {
	// Whether the current window is focused.
	Focused bool `json:"focused"`
}

// A status bar item is a status bar contribution that can
// show text and icons and run a command on click.
type StatusBarItem struct {
	__disp__ *Disposable

	// CfgBag represents this `StatusBarItem`'s current state. All its members get auto-refreshed every time any `StatusBarItem` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method. Your local modifications to its members will **not** be auto-propagated to VSC, this must be done explicitly via its `ApplyChanges` method.
	CfgBag *StatusBarItemBag
}

// An output channel is a container for readonly textual information.
// 
// To get an instance of an `OutputChannel` use
// [createOutputChannel](https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel).
type OutputChannel struct {
	__disp__ *Disposable

	// CfgBag represents this `OutputChannel`'s current state. All its members get auto-refreshed every time any `OutputChannel` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method.
	CfgBag *OutputChannelBag
}

// Type Definition for Visual Studio Code 1.39 Extension API
// See https://code.visualstudio.com/api for more information
type ThemableDecorationAttachmentRenderOptions struct {
	// Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.
	ContentText string `json:"contentText,omitempty"`

	// An **absolute path** or an URI to an image to be rendered in the attachment. Either an icon
	// or a text can be shown, but not both.
	ContentIconPath string `json:"contentIconPath,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	Border string `json:"border,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	BorderColor string `json:"borderColor,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	FontStyle string `json:"fontStyle,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	FontWeight string `json:"fontWeight,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	TextDecoration string `json:"textDecoration,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	Color string `json:"color,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	BackgroundColor string `json:"backgroundColor,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	Margin string `json:"margin,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	Width string `json:"width,omitempty"`

	// CSS styling property that will be applied to the decoration attachment.
	Height string `json:"height,omitempty"`
}

// Represents rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).
type DecorationRenderOptions struct {
	// Should the decoration be rendered also on the whitespace after the line text.
	// Defaults to `false`.
	IsWholeLine bool `json:"isWholeLine,omitempty"`

	// Customize the growing behavior of the decoration when edits occur at the edges of the decoration's range.
	// Defaults to `DecorationRangeBehavior.OpenOpen`.
	RangeBehavior DecorationRangeBehavior `json:"rangeBehavior,omitempty"`

	// The position in the overview ruler where the decoration should be rendered.
	OverviewRulerLane OverviewRulerLane `json:"overviewRulerLane,omitempty"`

	// Overwrite options for light themes.
	Light ThemableDecorationRenderOptions `json:"light,omitempty"`

	// Overwrite options for dark themes.
	Dark ThemableDecorationRenderOptions `json:"dark,omitempty"`

	// Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
	// Alternatively a color from the color registry can be [referenced](https://code.visualstudio.com/api/references/vscode-api#ThemeColor).
	BackgroundColor string `json:"backgroundColor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Outline string `json:"outline,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'outline' for setting one or more of the individual outline properties.
	OutlineColor string `json:"outlineColor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'outline' for setting one or more of the individual outline properties.
	OutlineStyle string `json:"outlineStyle,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'outline' for setting one or more of the individual outline properties.
	OutlineWidth string `json:"outlineWidth,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Border string `json:"border,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderColor string `json:"borderColor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderRadius string `json:"borderRadius,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderSpacing string `json:"borderSpacing,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderStyle string `json:"borderStyle,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	// Better use 'border' for setting one or more of the individual border properties.
	BorderWidth string `json:"borderWidth,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	FontStyle string `json:"fontStyle,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	FontWeight string `json:"fontWeight,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	TextDecoration string `json:"textDecoration,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Cursor string `json:"cursor,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Color string `json:"color,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	Opacity string `json:"opacity,omitempty"`

	// CSS styling property that will be applied to text enclosed by a decoration.
	LetterSpacing string `json:"letterSpacing,omitempty"`

	// An **absolute path** or an URI to an image to be rendered in the gutter.
	GutterIconPath string `json:"gutterIconPath,omitempty"`

	// Specifies the size of the gutter icon.
	// Available values are 'auto', 'contain', 'cover' and any percentage value.
	// For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
	GutterIconSize string `json:"gutterIconSize,omitempty"`

	// The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.
	OverviewRulerColor string `json:"overviewRulerColor,omitempty"`

	// Defines the rendering options of the attachment that is inserted before the decorated text.
	Before ThemableDecorationAttachmentRenderOptions `json:"before,omitempty"`

	// Defines the rendering options of the attachment that is inserted after the decorated text.
	After ThemableDecorationAttachmentRenderOptions `json:"after,omitempty"`
}

// Represents a handle to a set of decorations
// sharing the same [styling options](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions) in a [text editor](#TextEditor).
// 
// To get an instance of a `TextEditorDecorationType` use
// [createTextEditorDecorationType](https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType).
type TextEditorDecorationType struct {
	__disp__ *Disposable

	// CfgBag represents this `TextEditorDecorationType`'s current state. All its members get auto-refreshed every time any `TextEditorDecorationType` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method.
	CfgBag *TextEditorDecorationTypeBag
}

// A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user input a text value.
// 
// Note that in many cases the more convenient [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox)
// is easier to use. [window.createInputBox](https://code.visualstudio.com/api/references/vscode-api#window.createInputBox) should be used
// when [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox) does not offer the required flexibility.
type InputBox struct {
	__disp__ *Disposable

	// CfgBag represents this `InputBox`'s current state. All its members get auto-refreshed every time a (subscribed) `InputBox` event fires or any `InputBox` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method. Your local modifications to its members will **not** be auto-propagated to VSC, this must be done explicitly via its `ApplyChanges` method.
	CfgBag *InputBoxBag
}

// Button for an action in a [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick) or [InputBox](#InputBox).
type QuickInputButton struct {
	// Icon for the button.
	IconPath string `json:"iconPath"`

	// An optional tooltip.
	Tooltip string `json:"tooltip,omitempty"`
}

// A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user pick an item from a
// list of items of type T. The items can be filtered through a filter text field and
// there is an option [canSelectMany](https://code.visualstudio.com/api/references/vscode-api#QuickPick.canSelectMany) to allow for
// selecting multiple items.
// 
// Note that in many cases the more convenient [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick)
// is easier to use. [window.createQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.createQuickPick) should be used
// when [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick) does not offer the required flexibility.
type QuickPick struct {
	__disp__ *Disposable

	// CfgBag represents this `QuickPick`'s current state. All its members get auto-refreshed every time a (subscribed) `QuickPick` event fires or any `QuickPick` method call (other than `Dispose`) resolves, but can also be manually refreshed via its `ReFetch` method. Your local modifications to its members will **not** be auto-propagated to VSC, this must be done explicitly via its `ApplyChanges` method.
	CfgBag *QuickPickBag
}

// An event describing a change to the set of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders).
type WorkspaceFoldersChangeEvent struct {
	// Added workspace folders.
	Added []WorkspaceFolder `json:"added"`

	// Removed workspace folders.
	Removed []WorkspaceFolder `json:"removed"`
}

// The event that is fired when diagnostics change.
type DiagnosticChangeEvent struct {
	// An array of resources for which diagnostics have changed.
	Uris []string `json:"uris"`
}

// EnvBag gathers various properties of `Env`, obtainable via its `AllProperties` method.
type EnvBag struct {
	// The application name of the editor, like 'VS Code'.
	AppName string `json:"appName,omitempty"`

	// The application root folder from which the editor is running.
	AppRoot string `json:"appRoot,omitempty"`

	// Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	Language string `json:"language,omitempty"`

	// A unique identifier for the computer.
	MachineId string `json:"machineId,omitempty"`

	// The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
	// Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
	// 
	// *Note* that the value is `undefined` when there is no remote extension host but that the
	// value is defined in all extension hosts (local and remote) in case a remote extension host
	// exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
	// a specific extension runs remote or not.
	RemoteName string `json:"remoteName,omitempty"`

	// A unique identifier for the current session.
	// Changes each time the editor is started.
	SessionId string `json:"sessionId,omitempty"`

	// The detected default shell for the extension host, this is overridden by the
	// `terminal.integrated.shell` setting for the extension host's platform.
	Shell string `json:"shell,omitempty"`

	// The custom uri scheme the editor registers to in the operating system.
	UriScheme string `json:"uriScheme,omitempty"`
}

// WorkspaceBag gathers various properties of `Workspace`, obtainable via its `AllProperties` method.
type WorkspaceBag struct {
	// The name of the workspace. `undefined` when no folder
	// has been opened.
	Name string `json:"name,omitempty"`

	// The location of the workspace file, for example:
	// 
	// `file:///Users/name/Development/myProject.code-workspace`
	// 
	// or
	// 
	// `untitled:1555503116870`
	// 
	// for a workspace that is untitled and not yet saved.
	// 
	// Depending on the workspace that is opened, the value will be:
	//   * `undefined` when no workspace or  a single folder is opened
	//   * the path of the workspace file as `Uri` otherwise. if the workspace
	// is untitled, the returned URI will use the `untitled:` scheme
	// 
	// The location can e.g. be used with the `vscode.openFolder` command to
	// open the workspace again after it has been closed.
	// 
	// **Example:**
	// 
	// ```typescript
	// 
	// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
	// 
	// ```
	// 
	// 
	// **Note:** it is not advised to use `workspace.workspaceFile` to write
	// configuration data into the file. You can use `workspace.getConfiguration().update()`
	// for that purpose which will work both when a single folder is opened as
	// well as an untitled or saved workspace.
	WorkspaceFile string `json:"workspaceFile,omitempty"`

	// List of workspace folders or `undefined` when no folder is open.
	// *Note* that the first entry corresponds to the value of `rootPath`.
	WorkspaceFolders []WorkspaceFolder `json:"workspaceFolders,omitempty"`
}

// StatusBarItemBag is a snapshot of `StatusBarItem` state at the VSC counterparty. It is obtained whenever `StatusBarItem` creations and method calls (incl. the dedicated `Get`) resolve or its event subscribers are invoked, and therefore (to help always retain a factual view of the real full-picture) should not be constructed manually. All read-only properties are exposed as function-valued fields. Changes to any non-function-valued fields must be propagated to the counterparty via the `Set` method.
type StatusBarItemBag struct {
	__holder__ *StatusBarItem

	// The alignment of this item.
	Alignment func() StatusBarAlignment `json:"-"`

	// The priority of this item. Higher value means the item should
	// be shown more to the left.
	Priority func() int `json:"-"`

	// The text to show for the entry. You can embed icons in the text by leveraging the syntax:
	// 
	// `My text $(icon-name) contains icons like $(icon-name) this one.`
	// 
	// Where the icon-name is taken from the [octicon](https://octicons.github.com) icon set, e.g.
	// `light-bulb`, `thumbsup`, `zap` etc.
	Text string `json:"text,omitempty"`

	// The tooltip text when you hover over this entry.
	Tooltip string `json:"tooltip,omitempty"`

	// The foreground color for this entry.
	Color string `json:"color,omitempty"`

	// The identifier of a command to run on click. The command must be
	// [known](https://code.visualstudio.com/api/references/vscode-api#commands.getCommands).
	Command string `json:"command,omitempty"`
}

// OutputChannelBag is a snapshot of `OutputChannel` state at the VSC counterparty. It is obtained whenever `OutputChannel` creations and method calls (incl. the dedicated `Get`) resolve or its event subscribers are invoked, and therefore (to help always retain a factual view of the real full-picture) should not be constructed manually. All read-only properties are exposed as function-valued fields.
type OutputChannelBag struct {
	__holder__ *OutputChannel

	// The human-readable name of this output channel.
	Name func() string `json:"-"`
}

// TextEditorDecorationTypeBag is a snapshot of `TextEditorDecorationType` state at the VSC counterparty. It is obtained whenever `TextEditorDecorationType` creations and method calls (incl. the dedicated `Get`) resolve or its event subscribers are invoked, and therefore (to help always retain a factual view of the real full-picture) should not be constructed manually. All read-only properties are exposed as function-valued fields.
type TextEditorDecorationTypeBag struct {
	__holder__ *TextEditorDecorationType

	// Internal representation of the handle.
	Key func() string `json:"-"`
}

// InputBoxBag is a snapshot of `InputBox` state at the VSC counterparty. It is obtained whenever `InputBox` creations and method calls (incl. the dedicated `Get`) resolve or its event subscribers are invoked, and therefore (to help always retain a factual view of the real full-picture) should not be constructed manually. Changes to any non-function-valued fields must be propagated to the counterparty via the `Set` method.
type InputBoxBag struct {
	__holder__ *InputBox

	// Current input value.
	Value string `json:"value,omitempty"`

	// Optional placeholder in the filter text.
	Placeholder string `json:"placeholder,omitempty"`

	// If the input value should be hidden. Defaults to false.
	Password bool `json:"password,omitempty"`

	// An optional prompt text providing some ask or explanation to the user.
	Prompt string `json:"prompt,omitempty"`

	// An optional validation message indicating a problem with the current input value.
	ValidationMessage string `json:"validationMessage,omitempty"`

	// An optional title.
	Title string `json:"title,omitempty"`

	// An optional current step count.
	Step int `json:"step,omitempty"`

	// An optional total step count.
	TotalSteps int `json:"totalSteps,omitempty"`

	// If the UI should allow for user input. Defaults to true.
	// 
	// Change this to false, e.g., while validating user input or
	// loading data for the next step in user input.
	Enabled bool `json:"enabled,omitempty"`

	// If the UI should show a progress indicator. Defaults to false.
	// 
	// Change this to true, e.g., while loading more data or validating
	// user input.
	Busy bool `json:"busy,omitempty"`

	// If the UI should stay open even when loosing UI focus. Defaults to false.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`
}

// QuickPickBag is a snapshot of `QuickPick` state at the VSC counterparty. It is obtained whenever `QuickPick` creations and method calls (incl. the dedicated `Get`) resolve or its event subscribers are invoked, and therefore (to help always retain a factual view of the real full-picture) should not be constructed manually. Changes to any non-function-valued fields must be propagated to the counterparty via the `Set` method.
type QuickPickBag struct {
	__holder__ *QuickPick

	// Current value of the filter text.
	Value string `json:"value,omitempty"`

	// Optional placeholder in the filter text.
	Placeholder string `json:"placeholder,omitempty"`

	// Items to pick from.
	Items []QuickPickItem `json:"items,omitempty"`

	// If multiple items can be selected at the same time. Defaults to false.
	CanSelectMany bool `json:"canSelectMany,omitempty"`

	// If the filter text should also be matched against the description of the items. Defaults to false.
	MatchOnDescription bool `json:"matchOnDescription,omitempty"`

	// If the filter text should also be matched against the detail of the items. Defaults to false.
	MatchOnDetail bool `json:"matchOnDetail,omitempty"`

	// Active items. This can be read and updated by the extension.
	ActiveItems []QuickPickItem `json:"activeItems,omitempty"`

	// Selected items. This can be read and updated by the extension.
	SelectedItems []QuickPickItem `json:"selectedItems,omitempty"`

	// An optional title.
	Title string `json:"title,omitempty"`

	// An optional current step count.
	Step int `json:"step,omitempty"`

	// An optional total step count.
	TotalSteps int `json:"totalSteps,omitempty"`

	// If the UI should allow for user input. Defaults to true.
	// 
	// Change this to false, e.g., while validating user input or
	// loading data for the next step in user input.
	Enabled bool `json:"enabled,omitempty"`

	// If the UI should show a progress indicator. Defaults to false.
	// 
	// Change this to true, e.g., while loading more data or validating
	// user input.
	Busy bool `json:"busy,omitempty"`

	// If the UI should stay open even when loosing UI focus. Defaults to false.
	IgnoreFocusOut bool `json:"ignoreFocusOut,omitempty"`
}

func (me *impl) Window() Window {
	return implWindow{me}
}

func (me *impl) Env() Env {
	return implEnv{me}
}

func (me *impl) Workspace() Workspace {
	return implWorkspace{me}
}

func (me *impl) Languages() Languages {
	return implLanguages{me}
}

func (me *impl) Extensions() Extensions {
	return implExtensions{me}
}

func (me *impl) Commands() Commands {
	return implCommands{me}
}

func (me implWindow) ShowInformationMessage1(message string, items []string) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowInformationMessage2(message string, options MessageOptions, items []string) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowInformationMessage3(message string, items []MessageItem) func(func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*MessageItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *MessageItem
		if (nil != payload) {
			result = new(MessageItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*MessageItem)) {
		onret = a0
	}
}

func (me implWindow) ShowInformationMessage4(message string, options MessageOptions, items []MessageItem) func(func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInformationMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*MessageItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *MessageItem
		if (nil != payload) {
			result = new(MessageItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*MessageItem)) {
		onret = a0
	}
}

func (me implWindow) ShowWarningMessage1(message string, items []string) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowWarningMessage2(message string, options MessageOptions, items []string) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowWarningMessage3(message string, items []MessageItem) func(func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*MessageItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *MessageItem
		if (nil != payload) {
			result = new(MessageItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*MessageItem)) {
		onret = a0
	}
}

func (me implWindow) ShowWarningMessage4(message string, options MessageOptions, items []MessageItem) func(func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWarningMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*MessageItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *MessageItem
		if (nil != payload) {
			result = new(MessageItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*MessageItem)) {
		onret = a0
	}
}

func (me implWindow) ShowErrorMessage1(message string, items []string) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage1"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowErrorMessage2(message string, options MessageOptions, items []string) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage2"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowErrorMessage3(message string, items []MessageItem) func(func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage3"
	msg.Data = make(dict, 2)
	msg.Data["message"] = message
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*MessageItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *MessageItem
		if (nil != payload) {
			result = new(MessageItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*MessageItem)) {
		onret = a0
	}
}

func (me implWindow) ShowErrorMessage4(message string, options MessageOptions, items []MessageItem) func(func(*MessageItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showErrorMessage4"
	msg.Data = make(dict, 3)
	msg.Data["message"] = message
	msg.Data["options"] = options
	msg.Data["items"] = items
	var onresp func(any) bool
	var onret func(*MessageItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *MessageItem
		if (nil != payload) {
			result = new(MessageItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*MessageItem)) {
		onret = a0
	}
}

func (me implWindow) ShowInputBox(options *InputBoxOptions, token *Cancel) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showInputBox"
	msg.Data = make(dict, 2)
	var __options__ *_InputBoxOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_InputBoxOptions)
		__options__.InputBoxOptions = options
		__options__.ValidateInput_AppzFuncId = ""
		var fn func(string) string
		fn = __options__.ValidateInput
		if (nil != fn) {
			me.Lock()
			{
				__options__.ValidateInput_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.ValidateInput_AppzFuncId)
				me.Impl().cbOther[__options__.ValidateInput_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 string
						if (nil != args[0]) {
							__0, ok = args[0].(string)
							if !ok {
								return nil, false
							}
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	if (nil != options) {
		msg.Data["options"] = __options__
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == onresp) || onresp(payload)
	})
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowQuickPick1(items []string, options QuickPickOptions, token *Cancel) func(func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick1"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = &options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							ok = __0.loadFromJsonish(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var onresp func(any) bool
	var onret func([]string)
	onresp = func(payload any) bool {
		var ok bool
		var result []string
		if (nil != payload) {
			var __coll__result []any
			__coll__result, ok = payload.([]any)
			if !ok {
				return false
			}
			result = make([]string, len(__coll__result))
			var __idx__result int
			__idx__result = 0
			for _, __item__result := range __coll__result {
				var __val__result string
				__val__result, ok = __item__result.(string)
				if !ok {
					return false
				}
				result[__idx__result] = __val__result
				__idx__result = __idx__result + 1
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == onresp) || onresp(payload)
	})
	return func(a0 func([]string)) {
		onret = a0
	}
}

func (me implWindow) ShowQuickPick2(items []string, options *QuickPickOptions, token *Cancel) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick2"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							ok = __0.loadFromJsonish(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	if (nil != options) {
		msg.Data["options"] = __options__
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == onresp) || onresp(payload)
	})
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowQuickPick3(items []QuickPickItem, options QuickPickOptions, token *Cancel) func(func([]QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick3"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if true {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = &options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							ok = __0.loadFromJsonish(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	options.CanPickMany = true
	msg.Data["options"] = __options__
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var onresp func(any) bool
	var onret func([]QuickPickItem)
	onresp = func(payload any) bool {
		var ok bool
		var result []QuickPickItem
		if (nil != payload) {
			var __coll__result []any
			__coll__result, ok = payload.([]any)
			if !ok {
				return false
			}
			result = make([]QuickPickItem, len(__coll__result))
			var __idx__result int
			__idx__result = 0
			for _, __item__result := range __coll__result {
				var __val__result QuickPickItem
				ok = __val__result.loadFromJsonish(__item__result)
				if !ok {
					return false
				}
				result[__idx__result] = __val__result
				__idx__result = __idx__result + 1
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == onresp) || onresp(payload)
	})
	return func(a0 func([]QuickPickItem)) {
		onret = a0
	}
}

func (me implWindow) ShowQuickPick4(items []QuickPickItem, options *QuickPickOptions, token *Cancel) func(func(*QuickPickItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showQuickPick4"
	msg.Data = make(dict, 3)
	var __options__ *_QuickPickOptions
	var fnids []string
	fnids = make([]string, 0, 1)
	if (nil != options) {
		__options__ = new(_QuickPickOptions)
		__options__.QuickPickOptions = options
		__options__.OnDidSelectItem_AppzFuncId = ""
		var fn func(QuickPickItem) any
		fn = __options__.OnDidSelectItem
		if (nil != fn) {
			me.Lock()
			{
				__options__.OnDidSelectItem_AppzFuncId = me.Impl().nextFuncId()
				fnids = append(fnids, __options__.OnDidSelectItem_AppzFuncId)
				me.Impl().cbOther[__options__.OnDidSelectItem_AppzFuncId] = func(args []any) (any, bool) {
					if 1 != len(args) {
						return nil, false
					} else {
						var ok bool
						var __0 QuickPickItem
						if (nil != args[0]) {
							ok = __0.loadFromJsonish(args[0])
							if !ok {
								return nil, false
							}
						} else {
							return nil, false
						}
						return fn(__0), true
					}
				}
			}
			me.Unlock()
		}
	}
	msg.Data["items"] = items
	if (nil != options) {
		msg.Data["options"] = __options__
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var onresp func(any) bool
	var onret func(*QuickPickItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *QuickPickItem
		if (nil != payload) {
			result = new(QuickPickItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, func(payload any) bool {
		if len(fnids) != 0 {
			me.Lock()
			{
				for _, fnid := range fnids {
					delete(me.Impl().cbOther, fnid)
				}
			}
			me.Unlock()
		}
		return (nil == onresp) || onresp(payload)
	})
	return func(a0 func(*QuickPickItem)) {
		onret = a0
	}
}

func (me implWindow) SetStatusBarMessage1(text string, hideAfterTimeout int) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage1"
	msg.Data = make(dict, 2)
	msg.Data["text"] = text
	msg.Data["hideAfterTimeout"] = hideAfterTimeout
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.Impl()))
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

func (me implWindow) SetStatusBarMessage2(text string) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.setStatusBarMessage2"
	msg.Data = make(dict, 1)
	msg.Data["text"] = text
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.Impl()))
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

func (me implWindow) ShowSaveDialog(options SaveDialogOptions) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showSaveDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWindow) ShowOpenDialog(options OpenDialogOptions) func(func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showOpenDialog"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var onresp func(any) bool
	var onret func([]string)
	onresp = func(payload any) bool {
		var ok bool
		var result []string
		if (nil != payload) {
			var __coll__result []any
			__coll__result, ok = payload.([]any)
			if !ok {
				return false
			}
			result = make([]string, len(__coll__result))
			var __idx__result int
			__idx__result = 0
			for _, __item__result := range __coll__result {
				var __val__result string
				__val__result, ok = __item__result.(string)
				if !ok {
					return false
				}
				result[__idx__result] = __val__result
				__idx__result = __idx__result + 1
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func([]string)) {
		onret = a0
	}
}

func (me implWindow) ShowWorkspaceFolderPick(options *WorkspaceFolderPickOptions) func(func(*WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.showWorkspaceFolderPick"
	msg.Data = make(dict, 1)
	if (nil != options) {
		msg.Data["options"] = options
	}
	var onresp func(any) bool
	var onret func(*WorkspaceFolder)
	onresp = func(payload any) bool {
		var ok bool
		var result *WorkspaceFolder
		if (nil != payload) {
			result = new(WorkspaceFolder)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*WorkspaceFolder)) {
		onret = a0
	}
}

func (me implWindow) State() func(func(WindowState)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.state"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(WindowState)
	onresp = func(payload any) bool {
		var ok bool
		var result WindowState
		if (nil != payload) {
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(WindowState)) {
		onret = a0
	}
}

func (me implWindow) OnDidChangeWindowState(listener func(WindowState)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.onDidChangeWindowState"
	msg.Data = make(dict, 1)
	var listenerFnId string
	if (nil == listener) {
		OnError(me.Impl(), "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	listenerFnId = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ WindowState
		ok = _a_0_.loadFromJsonish(args[0])
		if !ok {
			return false
		}
		listener(_a_0_)
		return true
	}, nil)
	msg.Data["listener"] = listenerFnId
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.Impl(), listenerFnId))
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

func (me implWindow) CreateStatusBarItem(alignment StatusBarAlignment, priority *int) func(func(*StatusBarItem)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.createStatusBarItem"
	msg.Data = make(dict, 2)
	if 0 != alignment {
		msg.Data["alignment"] = alignment
	}
	if (nil != priority) {
		msg.Data["priority"] = priority
	}
	var onresp func(any) bool
	var onret func(*StatusBarItem)
	onresp = func(payload any) bool {
		var ok bool
		var result *StatusBarItem
		if (nil != payload) {
			result = new(StatusBarItem)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
			result.__disp__.impl = me.Impl()
		} else {
			return false
		}
		result.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret(result)
			}
		})
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*StatusBarItem)) {
		onret = a0
	}
}

func (me implWindow) CreateOutputChannel(name string) func(func(*OutputChannel)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.createOutputChannel"
	msg.Data = make(dict, 1)
	msg.Data["name"] = name
	var onresp func(any) bool
	var onret func(*OutputChannel)
	onresp = func(payload any) bool {
		var ok bool
		var result *OutputChannel
		if (nil != payload) {
			result = new(OutputChannel)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
			result.__disp__.impl = me.Impl()
		} else {
			return false
		}
		result.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret(result)
			}
		})
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*OutputChannel)) {
		onret = a0
	}
}

func (me implWindow) CreateTextEditorDecorationType(options DecorationRenderOptions) func(func(*TextEditorDecorationType)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.createTextEditorDecorationType"
	msg.Data = make(dict, 1)
	msg.Data["options"] = options
	var onresp func(any) bool
	var onret func(*TextEditorDecorationType)
	onresp = func(payload any) bool {
		var ok bool
		var result *TextEditorDecorationType
		if (nil != payload) {
			result = new(TextEditorDecorationType)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
			result.__disp__.impl = me.Impl()
		} else {
			return false
		}
		result.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret(result)
			}
		})
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*TextEditorDecorationType)) {
		onret = a0
	}
}

func (me implWindow) CreateInputBox() func(func(*InputBox)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.createInputBox"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(*InputBox)
	onresp = func(payload any) bool {
		var ok bool
		var result *InputBox
		if (nil != payload) {
			result = new(InputBox)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
			result.__disp__.impl = me.Impl()
		} else {
			return false
		}
		result.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret(result)
			}
		})
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*InputBox)) {
		onret = a0
	}
}

func (me implWindow) CreateQuickPick() func(func(*QuickPick)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "window.createQuickPick"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(*QuickPick)
	onresp = func(payload any) bool {
		var ok bool
		var result *QuickPick
		if (nil != payload) {
			result = new(QuickPick)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
			result.__disp__.impl = me.Impl()
		} else {
			return false
		}
		result.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret(result)
			}
		})
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*QuickPick)) {
		onret = a0
	}
}

func (me implEnv) OpenExternal(target string) func(func(bool)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.openExternal"
	msg.Data = make(dict, 1)
	msg.Data["target"] = target
	var onresp func(any) bool
	var onret func(bool)
	onresp = func(payload any) bool {
		var ok bool
		var result bool
		if (nil != payload) {
			result, ok = payload.(bool)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(bool)) {
		onret = a0
	}
}

func (me implEnv) AppName() func(func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appName"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(string)
	onresp = func(payload any) bool {
		var ok bool
		var result string
		if (nil != payload) {
			result, ok = payload.(string)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(string)) {
		onret = a0
	}
}

func (me implEnv) AppRoot() func(func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.appRoot"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(string)
	onresp = func(payload any) bool {
		var ok bool
		var result string
		if (nil != payload) {
			result, ok = payload.(string)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(string)) {
		onret = a0
	}
}

func (me implEnv) Language() func(func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.language"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(string)
	onresp = func(payload any) bool {
		var ok bool
		var result string
		if (nil != payload) {
			result, ok = payload.(string)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(string)) {
		onret = a0
	}
}

func (me implEnv) MachineId() func(func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.machineId"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(string)
	onresp = func(payload any) bool {
		var ok bool
		var result string
		if (nil != payload) {
			result, ok = payload.(string)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(string)) {
		onret = a0
	}
}

func (me implEnv) RemoteName() func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.remoteName"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implEnv) SessionId() func(func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.sessionId"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(string)
	onresp = func(payload any) bool {
		var ok bool
		var result string
		if (nil != payload) {
			result, ok = payload.(string)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(string)) {
		onret = a0
	}
}

func (me implEnv) Shell() func(func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.shell"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(string)
	onresp = func(payload any) bool {
		var ok bool
		var result string
		if (nil != payload) {
			result, ok = payload.(string)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(string)) {
		onret = a0
	}
}

func (me implEnv) UriScheme() func(func(string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.uriScheme"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(string)
	onresp = func(payload any) bool {
		var ok bool
		var result string
		if (nil != payload) {
			result, ok = payload.(string)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(string)) {
		onret = a0
	}
}

func (me implEnv) AllProperties() func(func(EnvBag)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "env.AllProperties"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(EnvBag)
	onresp = func(payload any) bool {
		var ok bool
		var result EnvBag
		if (nil != payload) {
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(EnvBag)) {
		onret = a0
	}
}

func (me implEnv) Clipboard() Clipboard {
	return implClipboard{me.Impl()}
}

func (me implClipboard) ReadText() func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "clipboard.readText"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implClipboard) WriteText(value string) func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "clipboard.writeText"
	msg.Data = make(dict, 1)
	msg.Data["value"] = value
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

func (me implWorkspace) Name() func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.name"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWorkspace) WorkspaceFile() func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.workspaceFile"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWorkspace) SaveAll(includeUntitled bool) func(func(bool)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.saveAll"
	msg.Data = make(dict, 1)
	msg.Data["includeUntitled"] = includeUntitled
	var onresp func(any) bool
	var onret func(bool)
	onresp = func(payload any) bool {
		var ok bool
		var result bool
		if (nil != payload) {
			result, ok = payload.(bool)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(bool)) {
		onret = a0
	}
}

func (me implWorkspace) OnDidChangeWorkspaceFolders(listener func(WorkspaceFoldersChangeEvent)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.onDidChangeWorkspaceFolders"
	msg.Data = make(dict, 1)
	var listenerFnId string
	if (nil == listener) {
		OnError(me.Impl(), "Workspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	listenerFnId = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ WorkspaceFoldersChangeEvent
		ok = _a_0_.loadFromJsonish(args[0])
		if !ok {
			return false
		}
		listener(_a_0_)
		return true
	}, nil)
	msg.Data["listener"] = listenerFnId
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.Impl(), listenerFnId))
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

func (me implWorkspace) GetWorkspaceFolder(uri string) func(func(*WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.getWorkspaceFolder"
	msg.Data = make(dict, 1)
	msg.Data["uri"] = uri
	var onresp func(any) bool
	var onret func(*WorkspaceFolder)
	onresp = func(payload any) bool {
		var ok bool
		var result *WorkspaceFolder
		if (nil != payload) {
			result = new(WorkspaceFolder)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*WorkspaceFolder)) {
		onret = a0
	}
}

func (me implWorkspace) WorkspaceFolders() func(func([]WorkspaceFolder)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.workspaceFolders"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func([]WorkspaceFolder)
	onresp = func(payload any) bool {
		var ok bool
		var result []WorkspaceFolder
		if (nil != payload) {
			var __coll__result []any
			__coll__result, ok = payload.([]any)
			if !ok {
				return false
			}
			result = make([]WorkspaceFolder, len(__coll__result))
			var __idx__result int
			__idx__result = 0
			for _, __item__result := range __coll__result {
				var __val__result WorkspaceFolder
				ok = __val__result.loadFromJsonish(__item__result)
				if !ok {
					return false
				}
				result[__idx__result] = __val__result
				__idx__result = __idx__result + 1
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func([]WorkspaceFolder)) {
		onret = a0
	}
}

func (me implWorkspace) FindFiles(include string, exclude *string, maxResults *int, token *Cancel) func(func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.findFiles"
	msg.Data = make(dict, 4)
	msg.Data["include"] = include
	if (nil != exclude) {
		msg.Data["exclude"] = exclude
	}
	if (nil != maxResults) {
		msg.Data["maxResults"] = maxResults
	}
	if (nil != token) {
		token.impl = me.Impl()
		if "" == token.fnId {
			me.Lock()
			{
				token.fnId = me.Impl().nextFuncId()
			}
			me.Unlock()
		}
		msg.Data["token"] = token.fnId
	}
	var onresp func(any) bool
	var onret func([]string)
	onresp = func(payload any) bool {
		var ok bool
		var result []string
		if (nil != payload) {
			var __coll__result []any
			__coll__result, ok = payload.([]any)
			if !ok {
				return false
			}
			result = make([]string, len(__coll__result))
			var __idx__result int
			__idx__result = 0
			for _, __item__result := range __coll__result {
				var __val__result string
				__val__result, ok = __item__result.(string)
				if !ok {
					return false
				}
				result[__idx__result] = __val__result
				__idx__result = __idx__result + 1
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func([]string)) {
		onret = a0
	}
}

func (me implWorkspace) AsRelativePath(pathOrUri string, includeWorkspaceFolder bool) func(func(*string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.asRelativePath"
	msg.Data = make(dict, 2)
	msg.Data["pathOrUri"] = pathOrUri
	msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder
	var onresp func(any) bool
	var onret func(*string)
	onresp = func(payload any) bool {
		var ok bool
		var result *string
		if (nil != payload) {
			var _result_ string
			_result_, ok = payload.(string)
			if !ok {
				return false
			}
			result = &_result_
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*string)) {
		onret = a0
	}
}

func (me implWorkspace) AllProperties() func(func(WorkspaceBag)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "workspace.AllProperties"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func(WorkspaceBag)
	onresp = func(payload any) bool {
		var ok bool
		var result WorkspaceBag
		if (nil != payload) {
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(WorkspaceBag)) {
		onret = a0
	}
}

func (me implLanguages) GetLanguages() func(func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "languages.getLanguages"
	msg.Data = make(dict, 0)
	var onresp func(any) bool
	var onret func([]string)
	onresp = func(payload any) bool {
		var ok bool
		var result []string
		if (nil != payload) {
			var __coll__result []any
			__coll__result, ok = payload.([]any)
			if !ok {
				return false
			}
			result = make([]string, len(__coll__result))
			var __idx__result int
			__idx__result = 0
			for _, __item__result := range __coll__result {
				var __val__result string
				__val__result, ok = __item__result.(string)
				if !ok {
					return false
				}
				result[__idx__result] = __val__result
				__idx__result = __idx__result + 1
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func([]string)) {
		onret = a0
	}
}

func (me implLanguages) OnDidChangeDiagnostics(listener func(DiagnosticChangeEvent)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "languages.onDidChangeDiagnostics"
	msg.Data = make(dict, 1)
	var listenerFnId string
	if (nil == listener) {
		OnError(me.Impl(), "Languages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	listenerFnId = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ DiagnosticChangeEvent
		ok = _a_0_.loadFromJsonish(args[0])
		if !ok {
			return false
		}
		listener(_a_0_)
		return true
	}, nil)
	msg.Data["listener"] = listenerFnId
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.Impl(), listenerFnId))
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

func (me implExtensions) OnDidChange(listener func()) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "extensions.onDidChange"
	msg.Data = make(dict, 1)
	var listenerFnId string
	if (nil == listener) {
		OnError(me.Impl(), "Extensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	listenerFnId = me.Impl().nextSub(func(args []any) bool {
		var ok bool
		if 0 != len(args) {
			return ok
		}
		listener()
		return true
	}, nil)
	msg.Data["listener"] = listenerFnId
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.Impl(), listenerFnId))
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

func (me implCommands) RegisterCommand(command string, callback func([]any) any) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "commands.registerCommand"
	msg.Data = make(dict, 2)
	msg.Data["command"] = command
	var callbackFnId string
	if (nil == callback) {
		OnError(me.Impl(), "Commands.RegisterCommand: the 'callback' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	callbackFnId = me.Impl().nextSub(nil, func(args []any) (any, bool) {
		var ok bool
		if 1 != len(args) {
			return nil, ok
		}
		var ret any
		var _a_0_ []any
		_a_0_, ok = args[0].([]any)
		if !ok {
			return nil, false
		}
		ret = callback(_a_0_)
		return ret, true
	})
	msg.Data["callback"] = callbackFnId
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.Impl(), callbackFnId))
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

func (me implCommands) ExecuteCommand(command string, rest []any) func(func(any)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "commands.executeCommand"
	msg.Data = make(dict, 2)
	msg.Data["command"] = command
	msg.Data["rest"] = rest
	var onresp func(any) bool
	var onret func(any)
	onresp = func(payload any) bool {
		var ok bool
		var result any
		if (nil != payload) {
			result, ok = payload, true
			if ok {
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func(any)) {
		onret = a0
	}
}

func (me implCommands) GetCommands(filterInternal bool) func(func([]string)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "commands.getCommands"
	msg.Data = make(dict, 1)
	msg.Data["filterInternal"] = filterInternal
	var onresp func(any) bool
	var onret func([]string)
	onresp = func(payload any) bool {
		var ok bool
		var result []string
		if (nil != payload) {
			var __coll__result []any
			__coll__result, ok = payload.([]any)
			if !ok {
				return false
			}
			result = make([]string, len(__coll__result))
			var __idx__result int
			__idx__result = 0
			for _, __item__result := range __coll__result {
				var __val__result string
				__val__result, ok = __item__result.(string)
				if !ok {
					return false
				}
				result[__idx__result] = __val__result
				__idx__result = __idx__result + 1
			}
		}
		if (nil != onret) {
			onret(result)
		}
		return true
	}
	me.Impl().send(msg, onresp)
	return func(a0 func([]string)) {
		onret = a0
	}
}

// Shows the entry in the status bar.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *StatusBarItem) Show() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "StatusBarItem.show"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Hide the entry in the status bar.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *StatusBarItem) Hide() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "StatusBarItem.hide"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Dispose and free associated resources. Call
// [hide](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.hide).
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *StatusBarItem) Dispose() func(func()) {
	return me.__disp__.Dispose()
}

// Obtains this `StatusBarItem`'s current property values for: `alignment`, `priority`, `text`, `tooltip`, `color`, `command`.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *StatusBarItem) __appzObjBagPullFromPeer__() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "StatusBarItem.__appzObjBagPullFromPeer__"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		var ok bool
		if (nil == me.CfgBag) {
			me.CfgBag = new(StatusBarItemBag)
		}
		me.CfgBag.__holder__ = me
		ok = me.CfgBag.loadFromJsonish(payload)
		if !ok {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Updates this `StatusBarItem`'s current property values for: `text`, `tooltip`, `color`, `command`.
// 
// `allUpdates` ── 
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *StatusBarItem) __appzObjBagPushToPeer_(allUpdates *StatusBarItemBag) func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "StatusBarItem.__appzObjBagPushToPeer_"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	msg.Data["allUpdates"] = allUpdates
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Append the given value to the channel.
// 
// `value` ── A string, falsy values will not be printed.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannel) Append(value string) func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "OutputChannel.append"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	msg.Data["value"] = value
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Append the given value and a line feed character
// to the channel.
// 
// `value` ── A string, falsy values will be printed.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannel) AppendLine(value string) func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "OutputChannel.appendLine"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	msg.Data["value"] = value
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Removes all output from the channel.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannel) Clear() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "OutputChannel.clear"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Reveal this channel in the UI.
// 
// `preserveFocus` ── When `true` the channel will not take focus.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannel) Show(preserveFocus bool) func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "OutputChannel.show"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	msg.Data["preserveFocus"] = preserveFocus
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Hide this channel from the UI.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannel) Hide() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "OutputChannel.hide"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Dispose and free associated resources.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannel) Dispose() func(func()) {
	return me.__disp__.Dispose()
}

// Obtains this `OutputChannel`'s current property value for: `name`.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannel) __appzObjBagPullFromPeer__() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "OutputChannel.__appzObjBagPullFromPeer__"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		var ok bool
		if (nil == me.CfgBag) {
			me.CfgBag = new(OutputChannelBag)
		}
		me.CfgBag.__holder__ = me
		ok = me.CfgBag.loadFromJsonish(payload)
		if !ok {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Remove this decoration type and all decorations on all text editors using it.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *TextEditorDecorationType) Dispose() func(func()) {
	return me.__disp__.Dispose()
}

// Obtains this `TextEditorDecorationType`'s current property value for: `key`.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *TextEditorDecorationType) __appzObjBagPullFromPeer__() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "TextEditorDecorationType.__appzObjBagPullFromPeer__"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		var ok bool
		if (nil == me.CfgBag) {
			me.CfgBag = new(TextEditorDecorationTypeBag)
		}
		me.CfgBag.__holder__ = me
		ok = me.CfgBag.loadFromJsonish(payload)
		if !ok {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// An event signaling when the value has changed.
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeValue` event on `Dispose`.
func (me *InputBox) OnDidChangeValue(handler func(string, InputBoxBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "InputBox.onDidChangeValue"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "InputBox.OnDidChangeValue: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 2 != len(args) {
			return ok
		}
		var _a_0_ string
		_a_0_, ok = args[0].(string)
		if !ok {
			return false
		}
		var _a_1_ InputBoxBag
		ok = _a_1_.loadFromJsonish(args[1])
		if !ok {
			return false
		}
		handler(_a_0_, _a_1_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// An event signaling when the user indicated acceptance of the input value.
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidAccept` event on `Dispose`.
func (me *InputBox) OnDidAccept(handler func(InputBoxBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "InputBox.onDidAccept"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "InputBox.OnDidAccept: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ InputBoxBag
		ok = _a_0_.loadFromJsonish(args[0])
		if !ok {
			return false
		}
		handler(_a_0_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// Makes the input UI visible in its current configuration. Any other input
// UI will first fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide) event.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *InputBox) Show() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "InputBox.show"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Hides this input UI. This will also fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide)
// event.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *InputBox) Hide() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "InputBox.hide"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// An event signaling when this input UI is hidden.
// 
// There are several reasons why this UI might have to be hidden and
// the extension will be notified through [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide).
// (Examples include: an explicit call to [QuickInput.hide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.hide),
// the user pressing Esc, some other input UI opening, etc.)
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidHide` event on `Dispose`.
func (me *InputBox) OnDidHide(handler func(InputBoxBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "InputBox.onDidHide"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "InputBox.OnDidHide: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ InputBoxBag
		ok = _a_0_.loadFromJsonish(args[0])
		if !ok {
			return false
		}
		handler(_a_0_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// Dispose of this input UI and any associated resources. If it is still
// visible, it is first hidden. After this call the input UI is no longer
// functional and no additional methods or properties on it should be
// accessed. Instead a new input UI should be created.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *InputBox) Dispose() func(func()) {
	return me.__disp__.Dispose()
}

// Obtains this `InputBox`'s current property values for: `value`, `placeholder`, `password`, `prompt`, `validationMessage`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut`.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *InputBox) __appzObjBagPullFromPeer__() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "InputBox.__appzObjBagPullFromPeer__"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		var ok bool
		if (nil == me.CfgBag) {
			me.CfgBag = new(InputBoxBag)
		}
		me.CfgBag.__holder__ = me
		ok = me.CfgBag.loadFromJsonish(payload)
		if !ok {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Updates this `InputBox`'s current property values for: `value`, `placeholder`, `password`, `prompt`, `validationMessage`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut`.
// 
// `allUpdates` ── 
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *InputBox) __appzObjBagPushToPeer_(allUpdates *InputBoxBag) func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "InputBox.__appzObjBagPushToPeer_"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	msg.Data["allUpdates"] = allUpdates
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// An event signaling when the value of the filter text has changed.
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeValue` event on `Dispose`.
func (me *QuickPick) OnDidChangeValue(handler func(string, QuickPickBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.onDidChangeValue"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "QuickPick.OnDidChangeValue: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 2 != len(args) {
			return ok
		}
		var _a_0_ string
		_a_0_, ok = args[0].(string)
		if !ok {
			return false
		}
		var _a_1_ QuickPickBag
		ok = _a_1_.loadFromJsonish(args[1])
		if !ok {
			return false
		}
		handler(_a_0_, _a_1_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// An event signaling when the user indicated acceptance of the selected item(s).
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidAccept` event on `Dispose`.
func (me *QuickPick) OnDidAccept(handler func(QuickPickBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.onDidAccept"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "QuickPick.OnDidAccept: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ QuickPickBag
		ok = _a_0_.loadFromJsonish(args[0])
		if !ok {
			return false
		}
		handler(_a_0_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// An event signaling when the active items have changed.
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeActive` event on `Dispose`.
func (me *QuickPick) OnDidChangeActive(handler func([]QuickPickItem, QuickPickBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.onDidChangeActive"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "QuickPick.OnDidChangeActive: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 2 != len(args) {
			return ok
		}
		var _a_0_ []QuickPickItem
		var __coll___a_0_ []any
		__coll___a_0_, ok = args[0].([]any)
		if !ok {
			return false
		}
		_a_0_ = make([]QuickPickItem, len(__coll___a_0_))
		var __idx___a_0_ int
		__idx___a_0_ = 0
		for _, __item___a_0_ := range __coll___a_0_ {
			var __val___a_0_ QuickPickItem
			ok = __val___a_0_.loadFromJsonish(__item___a_0_)
			if !ok {
				return false
			}
			_a_0_[__idx___a_0_] = __val___a_0_
			__idx___a_0_ = __idx___a_0_ + 1
		}
		var _a_1_ QuickPickBag
		ok = _a_1_.loadFromJsonish(args[1])
		if !ok {
			return false
		}
		handler(_a_0_, _a_1_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// An event signaling when the selected items have changed.
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidChangeSelection` event on `Dispose`.
func (me *QuickPick) OnDidChangeSelection(handler func([]QuickPickItem, QuickPickBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.onDidChangeSelection"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "QuickPick.OnDidChangeSelection: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 2 != len(args) {
			return ok
		}
		var _a_0_ []QuickPickItem
		var __coll___a_0_ []any
		__coll___a_0_, ok = args[0].([]any)
		if !ok {
			return false
		}
		_a_0_ = make([]QuickPickItem, len(__coll___a_0_))
		var __idx___a_0_ int
		__idx___a_0_ = 0
		for _, __item___a_0_ := range __coll___a_0_ {
			var __val___a_0_ QuickPickItem
			ok = __val___a_0_.loadFromJsonish(__item___a_0_)
			if !ok {
				return false
			}
			_a_0_[__idx___a_0_] = __val___a_0_
			__idx___a_0_ = __idx___a_0_ + 1
		}
		var _a_1_ QuickPickBag
		ok = _a_1_.loadFromJsonish(args[1])
		if !ok {
			return false
		}
		handler(_a_0_, _a_1_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// Makes the input UI visible in its current configuration. Any other input
// UI will first fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide) event.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *QuickPick) Show() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.show"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Hides this input UI. This will also fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide)
// event.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *QuickPick) Hide() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.hide"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		me.__appzObjBagPullFromPeer__()(func() {
			if (nil != onret) {
				onret()
			}
		})
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// An event signaling when this input UI is hidden.
// 
// There are several reasons why this UI might have to be hidden and
// the extension will be notified through [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide).
// (Examples include: an explicit call to [QuickInput.hide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.hide),
// the user pressing Esc, some other input UI opening, etc.)
// 
// `handler` ── will be invoked whenever this event fires; mandatory, not optional.
// 
// `return` ── A `Disposable` that will unsubscribe `handler` from the `OnDidHide` event on `Dispose`.
func (me *QuickPick) OnDidHide(handler func(QuickPickBag)) func(func(*Disposable)) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.onDidHide"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	var handlerFnId string
	if (nil == handler) {
		OnError(me.__disp__.impl, "QuickPick.OnDidHide: the 'handler' arg (which is not optional but required) was not passed by the caller", nil)
		return nil
	}
	handlerFnId = me.__disp__.impl.nextSub(func(args []any) bool {
		var ok bool
		if 1 != len(args) {
			return ok
		}
		var _a_0_ QuickPickBag
		ok = _a_0_.loadFromJsonish(args[0])
		if !ok {
			return false
		}
		handler(_a_0_)
		return true
	}, nil)
	msg.Data["handler"] = handlerFnId
	me.__disp__.addSub(handlerFnId)
	var onresp func(any) bool
	var onret func(*Disposable)
	onresp = func(payload any) bool {
		var ok bool
		var result *Disposable
		if (nil != payload) {
			result = new(Disposable)
			ok = result.loadFromJsonish(payload)
			if !ok {
				return false
			}
		} else {
			return false
		}
		if (nil != onret) {
			onret(result.bind(me.__disp__.impl, handlerFnId))
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func(*Disposable)) {
		onret = a0
	}
}

// Dispose of this input UI and any associated resources. If it is still
// visible, it is first hidden. After this call the input UI is no longer
// functional and no additional methods or properties on it should be
// accessed. Instead a new input UI should be created.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *QuickPick) Dispose() func(func()) {
	return me.__disp__.Dispose()
}

// Obtains this `QuickPick`'s current property values for: `value`, `placeholder`, `items`, `canSelectMany`, `matchOnDescription`, `matchOnDetail`, `activeItems`, `selectedItems`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut`.
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *QuickPick) __appzObjBagPullFromPeer__() func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.__appzObjBagPullFromPeer__"
	msg.Data = make(dict, 1)
	msg.Data[""] = me.__disp__.id
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		var ok bool
		if (nil == me.CfgBag) {
			me.CfgBag = new(QuickPickBag)
		}
		me.CfgBag.__holder__ = me
		ok = me.CfgBag.loadFromJsonish(payload)
		if !ok {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// Updates this `QuickPick`'s current property values for: `value`, `placeholder`, `items`, `canSelectMany`, `matchOnDescription`, `matchOnDetail`, `activeItems`, `selectedItems`, `title`, `step`, `totalSteps`, `enabled`, `busy`, `ignoreFocusOut`.
// 
// `allUpdates` ── 
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *QuickPick) __appzObjBagPushToPeer_(allUpdates *QuickPickBag) func(func()) {
	var msg *ipcMsg
	msg = new(ipcMsg)
	msg.QName = "QuickPick.__appzObjBagPushToPeer_"
	msg.Data = make(dict, 2)
	msg.Data[""] = me.__disp__.id
	msg.Data["allUpdates"] = allUpdates
	var onresp func(any) bool
	var onret func()
	onresp = func(payload any) bool {
		if (nil != payload) {
			return false
		}
		if (nil != onret) {
			onret()
		}
		return true
	}
	me.__disp__.impl.send(msg, onresp)
	return func(a0 func()) {
		onret = a0
	}
}

// getter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *StatusBarItemBag) ReFetch() func(func()) {
	return me.__holder__.__appzObjBagPullFromPeer__()
}

// setter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *StatusBarItemBag) ApplyChanges() func(func()) {
	return me.__holder__.__appzObjBagPushToPeer_(me)
}

// getter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *OutputChannelBag) ReFetch() func(func()) {
	return me.__holder__.__appzObjBagPullFromPeer__()
}

// getter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *TextEditorDecorationTypeBag) ReFetch() func(func()) {
	return me.__holder__.__appzObjBagPullFromPeer__()
}

// getter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *InputBoxBag) ReFetch() func(func()) {
	return me.__holder__.__appzObjBagPullFromPeer__()
}

// setter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *InputBoxBag) ApplyChanges() func(func()) {
	return me.__holder__.__appzObjBagPushToPeer_(me)
}

// getter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *QuickPickBag) ReFetch() func(func()) {
	return me.__holder__.__appzObjBagPullFromPeer__()
}

// setter docs
// 
// `return` ── A thenable that resolves when this call has completed at the counterparty.
func (me *QuickPickBag) ApplyChanges() func(func()) {
	return me.__holder__.__appzObjBagPushToPeer_(me)
}

func (me *MessageItem) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["title"]
	if ok {
		var title string
		if (nil != val) {
			title, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Title = title
	} else {
		return false
	}
	val, ok = it["isCloseAffordance"]
	if ok {
		var isCloseAffordance bool
		if (nil != val) {
			isCloseAffordance, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.IsCloseAffordance = isCloseAffordance
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if !ok {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *QuickPickItem) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["label"]
	if ok {
		var label string
		if (nil != val) {
			label, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Label = label
	} else {
		return false
	}
	val, ok = it["description"]
	if ok {
		var description string
		if (nil != val) {
			description, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Description = description
	}
	val, ok = it["detail"]
	if ok {
		var detail string
		if (nil != val) {
			detail, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Detail = detail
	}
	val, ok = it["picked"]
	if ok {
		var picked bool
		if (nil != val) {
			picked, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Picked = picked
	}
	val, ok = it["alwaysShow"]
	if ok {
		var alwaysShow bool
		if (nil != val) {
			alwaysShow, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.AlwaysShow = alwaysShow
	}
	val, ok = it["my"]
	if ok {
		var my dict
		if (nil != val) {
			my, ok = val.(dict)
			if !ok {
				return false
			}
		}
		me.My = my
	}
	return true
}

func (me *WorkspaceFolder) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["uri"]
	if ok {
		var uri string
		if (nil != val) {
			uri, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Uri = uri
	} else {
		return false
	}
	val, ok = it["name"]
	if ok {
		var name string
		if (nil != val) {
			name, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Name = name
	} else {
		return false
	}
	val, ok = it["index"]
	if ok {
		var index int
		if (nil != val) {
			index, ok = val.(int)
			if !ok {
				var __index__ float64
				__index__, ok = val.(float64)
				if !ok {
					return false
				}
				index = int(__index__)
			}
		}
		me.Index = index
	} else {
		return false
	}
	return true
}

func (me *WindowState) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["focused"]
	if ok {
		var focused bool
		if (nil != val) {
			focused, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Focused = focused
	} else {
		return false
	}
	return true
}

func (me *StatusBarItem) loadFromJsonish(payload any) bool {
	var ok bool
	me.__disp__ = new(Disposable)
	ok = me.__disp__.loadFromJsonish(payload)
	return ok
}

func (me *OutputChannel) loadFromJsonish(payload any) bool {
	var ok bool
	me.__disp__ = new(Disposable)
	ok = me.__disp__.loadFromJsonish(payload)
	return ok
}

func (me *TextEditorDecorationType) loadFromJsonish(payload any) bool {
	var ok bool
	me.__disp__ = new(Disposable)
	ok = me.__disp__.loadFromJsonish(payload)
	return ok
}

func (me *InputBox) loadFromJsonish(payload any) bool {
	var ok bool
	me.__disp__ = new(Disposable)
	ok = me.__disp__.loadFromJsonish(payload)
	return ok
}

func (me *QuickPick) loadFromJsonish(payload any) bool {
	var ok bool
	me.__disp__ = new(Disposable)
	ok = me.__disp__.loadFromJsonish(payload)
	return ok
}

func (me *EnvBag) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["appName"]
	if ok {
		var appName string
		if (nil != val) {
			appName, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.AppName = appName
	}
	val, ok = it["appRoot"]
	if ok {
		var appRoot string
		if (nil != val) {
			appRoot, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.AppRoot = appRoot
	}
	val, ok = it["language"]
	if ok {
		var language string
		if (nil != val) {
			language, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Language = language
	}
	val, ok = it["machineId"]
	if ok {
		var machineId string
		if (nil != val) {
			machineId, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.MachineId = machineId
	}
	val, ok = it["remoteName"]
	if ok {
		var remoteName string
		if (nil != val) {
			remoteName, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.RemoteName = remoteName
	}
	val, ok = it["sessionId"]
	if ok {
		var sessionId string
		if (nil != val) {
			sessionId, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.SessionId = sessionId
	}
	val, ok = it["shell"]
	if ok {
		var shell string
		if (nil != val) {
			shell, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Shell = shell
	}
	val, ok = it["uriScheme"]
	if ok {
		var uriScheme string
		if (nil != val) {
			uriScheme, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.UriScheme = uriScheme
	}
	return true
}

func (me *WorkspaceFoldersChangeEvent) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["added"]
	if ok {
		var added []WorkspaceFolder
		if (nil != val) {
			var __coll__added []any
			__coll__added, ok = val.([]any)
			if !ok {
				return false
			}
			added = make([]WorkspaceFolder, len(__coll__added))
			var __idx__added int
			__idx__added = 0
			for _, __item__added := range __coll__added {
				var __val__added WorkspaceFolder
				ok = __val__added.loadFromJsonish(__item__added)
				if !ok {
					return false
				}
				added[__idx__added] = __val__added
				__idx__added = __idx__added + 1
			}
		}
		me.Added = added
	} else {
		return false
	}
	val, ok = it["removed"]
	if ok {
		var removed []WorkspaceFolder
		if (nil != val) {
			var __coll__removed []any
			__coll__removed, ok = val.([]any)
			if !ok {
				return false
			}
			removed = make([]WorkspaceFolder, len(__coll__removed))
			var __idx__removed int
			__idx__removed = 0
			for _, __item__removed := range __coll__removed {
				var __val__removed WorkspaceFolder
				ok = __val__removed.loadFromJsonish(__item__removed)
				if !ok {
					return false
				}
				removed[__idx__removed] = __val__removed
				__idx__removed = __idx__removed + 1
			}
		}
		me.Removed = removed
	} else {
		return false
	}
	return true
}

func (me *WorkspaceBag) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["name"]
	if ok {
		var name string
		if (nil != val) {
			name, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Name = name
	}
	val, ok = it["workspaceFile"]
	if ok {
		var workspaceFile string
		if (nil != val) {
			workspaceFile, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.WorkspaceFile = workspaceFile
	}
	val, ok = it["workspaceFolders"]
	if ok {
		var workspaceFolders []WorkspaceFolder
		if (nil != val) {
			var __coll__workspaceFolders []any
			__coll__workspaceFolders, ok = val.([]any)
			if !ok {
				return false
			}
			workspaceFolders = make([]WorkspaceFolder, len(__coll__workspaceFolders))
			var __idx__workspaceFolders int
			__idx__workspaceFolders = 0
			for _, __item__workspaceFolders := range __coll__workspaceFolders {
				var __val__workspaceFolders WorkspaceFolder
				ok = __val__workspaceFolders.loadFromJsonish(__item__workspaceFolders)
				if !ok {
					return false
				}
				workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders
				__idx__workspaceFolders = __idx__workspaceFolders + 1
			}
		}
		me.WorkspaceFolders = workspaceFolders
	}
	return true
}

func (me *DiagnosticChangeEvent) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["uris"]
	if ok {
		var uris []string
		if (nil != val) {
			var __coll__uris []any
			__coll__uris, ok = val.([]any)
			if !ok {
				return false
			}
			uris = make([]string, len(__coll__uris))
			var __idx__uris int
			__idx__uris = 0
			for _, __item__uris := range __coll__uris {
				var __val__uris string
				__val__uris, ok = __item__uris.(string)
				if !ok {
					return false
				}
				uris[__idx__uris] = __val__uris
				__idx__uris = __idx__uris + 1
			}
		}
		me.Uris = uris
	} else {
		return false
	}
	return true
}

func (me *StatusBarItemBag) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["alignment"]
	if ok {
		var alignment StatusBarAlignment
		if (nil != val) {
			var i_alignment int
			i_alignment, ok = val.(int)
			if !ok {
				var __i_alignment__ float64
				__i_alignment__, ok = val.(float64)
				if !ok {
					return false
				}
				i_alignment = int(__i_alignment__)
			}
			alignment = StatusBarAlignment(i_alignment)
		}
		me.Alignment = func() StatusBarAlignment {
			return alignment
		}
	}
	val, ok = it["priority"]
	if ok {
		var priority int
		if (nil != val) {
			priority, ok = val.(int)
			if !ok {
				var __priority__ float64
				__priority__, ok = val.(float64)
				if !ok {
					return false
				}
				priority = int(__priority__)
			}
		}
		me.Priority = func() int {
			return priority
		}
	}
	val, ok = it["text"]
	if ok {
		var text string
		if (nil != val) {
			text, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Text = text
	}
	val, ok = it["tooltip"]
	if ok {
		var tooltip string
		if (nil != val) {
			tooltip, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Tooltip = tooltip
	}
	val, ok = it["color"]
	if ok {
		var color string
		if (nil != val) {
			color, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Color = color
	}
	val, ok = it["command"]
	if ok {
		var command string
		if (nil != val) {
			command, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Command = command
	}
	return true
}

func (me *OutputChannelBag) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["name"]
	if ok {
		var name string
		if (nil != val) {
			name, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Name = func() string {
			return name
		}
	}
	return true
}

func (me *TextEditorDecorationTypeBag) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["key"]
	if ok {
		var key string
		if (nil != val) {
			key, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Key = func() string {
			return key
		}
	}
	return true
}

func (me *InputBoxBag) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["value"]
	if ok {
		var value string
		if (nil != val) {
			value, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Value = value
	}
	val, ok = it["placeholder"]
	if ok {
		var placeholder string
		if (nil != val) {
			placeholder, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Placeholder = placeholder
	}
	val, ok = it["password"]
	if ok {
		var password bool
		if (nil != val) {
			password, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Password = password
	}
	val, ok = it["prompt"]
	if ok {
		var prompt string
		if (nil != val) {
			prompt, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Prompt = prompt
	}
	val, ok = it["validationMessage"]
	if ok {
		var validationMessage string
		if (nil != val) {
			validationMessage, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.ValidationMessage = validationMessage
	}
	val, ok = it["title"]
	if ok {
		var title string
		if (nil != val) {
			title, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Title = title
	}
	val, ok = it["step"]
	if ok {
		var step int
		if (nil != val) {
			step, ok = val.(int)
			if !ok {
				var __step__ float64
				__step__, ok = val.(float64)
				if !ok {
					return false
				}
				step = int(__step__)
			}
		}
		me.Step = step
	}
	val, ok = it["totalSteps"]
	if ok {
		var totalSteps int
		if (nil != val) {
			totalSteps, ok = val.(int)
			if !ok {
				var __totalSteps__ float64
				__totalSteps__, ok = val.(float64)
				if !ok {
					return false
				}
				totalSteps = int(__totalSteps__)
			}
		}
		me.TotalSteps = totalSteps
	}
	val, ok = it["enabled"]
	if ok {
		var enabled bool
		if (nil != val) {
			enabled, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Enabled = enabled
	}
	val, ok = it["busy"]
	if ok {
		var busy bool
		if (nil != val) {
			busy, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Busy = busy
	}
	val, ok = it["ignoreFocusOut"]
	if ok {
		var ignoreFocusOut bool
		if (nil != val) {
			ignoreFocusOut, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.IgnoreFocusOut = ignoreFocusOut
	}
	return true
}

func (me *QuickPickBag) loadFromJsonish(payload any) bool {
	var it dict
	var ok bool
	var val any
	it, ok = payload.(dict)
	if !ok {
		return false
	}
	val, ok = it["value"]
	if ok {
		var value string
		if (nil != val) {
			value, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Value = value
	}
	val, ok = it["placeholder"]
	if ok {
		var placeholder string
		if (nil != val) {
			placeholder, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Placeholder = placeholder
	}
	val, ok = it["items"]
	if ok {
		var items []QuickPickItem
		if (nil != val) {
			var __coll__items []any
			__coll__items, ok = val.([]any)
			if !ok {
				return false
			}
			items = make([]QuickPickItem, len(__coll__items))
			var __idx__items int
			__idx__items = 0
			for _, __item__items := range __coll__items {
				var __val__items QuickPickItem
				ok = __val__items.loadFromJsonish(__item__items)
				if !ok {
					return false
				}
				items[__idx__items] = __val__items
				__idx__items = __idx__items + 1
			}
		}
		me.Items = items
	}
	val, ok = it["canSelectMany"]
	if ok {
		var canSelectMany bool
		if (nil != val) {
			canSelectMany, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.CanSelectMany = canSelectMany
	}
	val, ok = it["matchOnDescription"]
	if ok {
		var matchOnDescription bool
		if (nil != val) {
			matchOnDescription, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.MatchOnDescription = matchOnDescription
	}
	val, ok = it["matchOnDetail"]
	if ok {
		var matchOnDetail bool
		if (nil != val) {
			matchOnDetail, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.MatchOnDetail = matchOnDetail
	}
	val, ok = it["activeItems"]
	if ok {
		var activeItems []QuickPickItem
		if (nil != val) {
			var __coll__activeItems []any
			__coll__activeItems, ok = val.([]any)
			if !ok {
				return false
			}
			activeItems = make([]QuickPickItem, len(__coll__activeItems))
			var __idx__activeItems int
			__idx__activeItems = 0
			for _, __item__activeItems := range __coll__activeItems {
				var __val__activeItems QuickPickItem
				ok = __val__activeItems.loadFromJsonish(__item__activeItems)
				if !ok {
					return false
				}
				activeItems[__idx__activeItems] = __val__activeItems
				__idx__activeItems = __idx__activeItems + 1
			}
		}
		me.ActiveItems = activeItems
	}
	val, ok = it["selectedItems"]
	if ok {
		var selectedItems []QuickPickItem
		if (nil != val) {
			var __coll__selectedItems []any
			__coll__selectedItems, ok = val.([]any)
			if !ok {
				return false
			}
			selectedItems = make([]QuickPickItem, len(__coll__selectedItems))
			var __idx__selectedItems int
			__idx__selectedItems = 0
			for _, __item__selectedItems := range __coll__selectedItems {
				var __val__selectedItems QuickPickItem
				ok = __val__selectedItems.loadFromJsonish(__item__selectedItems)
				if !ok {
					return false
				}
				selectedItems[__idx__selectedItems] = __val__selectedItems
				__idx__selectedItems = __idx__selectedItems + 1
			}
		}
		me.SelectedItems = selectedItems
	}
	val, ok = it["title"]
	if ok {
		var title string
		if (nil != val) {
			title, ok = val.(string)
			if !ok {
				return false
			}
		}
		me.Title = title
	}
	val, ok = it["step"]
	if ok {
		var step int
		if (nil != val) {
			step, ok = val.(int)
			if !ok {
				var __step__ float64
				__step__, ok = val.(float64)
				if !ok {
					return false
				}
				step = int(__step__)
			}
		}
		me.Step = step
	}
	val, ok = it["totalSteps"]
	if ok {
		var totalSteps int
		if (nil != val) {
			totalSteps, ok = val.(int)
			if !ok {
				var __totalSteps__ float64
				__totalSteps__, ok = val.(float64)
				if !ok {
					return false
				}
				totalSteps = int(__totalSteps__)
			}
		}
		me.TotalSteps = totalSteps
	}
	val, ok = it["enabled"]
	if ok {
		var enabled bool
		if (nil != val) {
			enabled, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Enabled = enabled
	}
	val, ok = it["busy"]
	if ok {
		var busy bool
		if (nil != val) {
			busy, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.Busy = busy
	}
	val, ok = it["ignoreFocusOut"]
	if ok {
		var ignoreFocusOut bool
		if (nil != val) {
			ignoreFocusOut, ok = val.(bool)
			if !ok {
				return false
			}
		}
		me.IgnoreFocusOut = ignoreFocusOut
	}
	return true
}

