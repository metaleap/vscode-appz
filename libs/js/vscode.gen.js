"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-nodejs.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
const core = require("./core");
const vsc_appz_1 = require("./vsc-appz");
class implBase {
    constructor(impl) { this.impl = impl; }
    Impl() { return this.impl; /* crikey, codegen life.. */ }
}
function newipcMsg() { return new core.ipcMsg(); }
function newDisposable() { return new core.Disposable(); }
/**
 * Represents the alignment of status bar items.

 */
var StatusBarAlignment;
(function (StatusBarAlignment) {
    /**
     * Aligned to the left side.

     */
    StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
    /**
     * Aligned to the right side.

     */
    StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
})(StatusBarAlignment = exports.StatusBarAlignment || (exports.StatusBarAlignment = {}));
function newMessageItem() {
    let me;
    me = { populateFrom: _ => MessageItem_populateFrom.call(me, _) };
    return me;
}
exports.newMessageItem = newMessageItem;
function newQuickPickItem() {
    let me;
    me = { populateFrom: _ => QuickPickItem_populateFrom.call(me, _) };
    return me;
}
exports.newQuickPickItem = newQuickPickItem;
function newWorkspaceFolder() {
    let me;
    me = { populateFrom: _ => WorkspaceFolder_populateFrom.call(me, _) };
    return me;
}
function newWindowState() {
    let me;
    me = { populateFrom: _ => WindowState_populateFrom.call(me, _) };
    return me;
}
function newStatusBarItem() {
    let me;
    me = { populateFrom: _ => StatusBarItem_populateFrom.call(me, _) };
    return me;
}
function newWorkspaceFoldersChangeEvent() {
    let me;
    me = { populateFrom: _ => WorkspaceFoldersChangeEvent_populateFrom.call(me, _) };
    return me;
}
function newDiagnosticChangeEvent() {
    let me;
    me = { populateFrom: _ => DiagnosticChangeEvent_populateFrom.call(me, _) };
    return me;
}
function newEnvProperties() {
    let me;
    me = { populateFrom: _ => EnvProperties_populateFrom.call(me, _) };
    return me;
}
function newWorkspaceProperties() {
    let me;
    me = { populateFrom: _ => WorkspaceProperties_populateFrom.call(me, _) };
    return me;
}
class impl {
    constructor() {
        this.Window = new implWindow(this);
        this.Env = new implEnv(this);
        this.Workspace = new implWorkspace(this);
        this.Languages = new implLanguages(this);
        this.Extensions = new implExtensions(this);
        this.Commands = new implCommands(this);
    }
}
exports.impl = impl;
class implWindow extends implBase {
    constructor(impl) { super(impl); }
    ShowInformationMessage1(message, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showInformationMessage1";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowInformationMessage2(message, options, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showInformationMessage2";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["options"] = options;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowInformationMessage3(message, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showInformationMessage3";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newMessageItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowInformationMessage4(message, options, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showInformationMessage4";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["options"] = options;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newMessageItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowWarningMessage1(message, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showWarningMessage1";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowWarningMessage2(message, options, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showWarningMessage2";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["options"] = options;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowWarningMessage3(message, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showWarningMessage3";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newMessageItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowWarningMessage4(message, options, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showWarningMessage4";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["options"] = options;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newMessageItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowErrorMessage1(message, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showErrorMessage1";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowErrorMessage2(message, options, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showErrorMessage2";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["options"] = options;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowErrorMessage3(message, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showErrorMessage3";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newMessageItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowErrorMessage4(message, options, items, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showErrorMessage4";
        msg.Data = {};
        msg.Data["message"] = message;
        msg.Data["options"] = options;
        msg.Data["items"] = items;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newMessageItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowInputBox(options, token, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showInputBox";
        msg.Data = {};
        let fnids;
        fnids = [];
        if ((undefined !== options && null !== options)) {
            options.validateInput_AppzFuncId = "";
            let fn;
            fn = options.validateInput;
            if ((undefined !== fn && null !== fn)) {
                {
                    options.validateInput_AppzFuncId = this.Impl().nextFuncId();
                    fnids.push(options.validateInput_AppzFuncId);
                    this.Impl().cbOther[options.validateInput_AppzFuncId] = (args) => {
                        if (1 !== args.length) {
                            return [null, false];
                        }
                        else {
                            let ok;
                            let __0;
                            if ((undefined !== args[0] && null !== args[0])) {
                                [__0, ok] = [args[0], typeof args[0] === "string"];
                                if (!ok) {
                                    return [null, false];
                                }
                            }
                            return [fn(__0), true];
                        }
                    };
                }
            }
        }
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options;
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl();
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId();
                }
            }
            msg.Data["token"] = token.fnId;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, (payload) => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid];
                    }
                }
            }
            return (undefined === on || null === on) || on(payload);
        });
    }
    ShowQuickPick1(items, options, token, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showQuickPick1";
        msg.Data = {};
        let fnids;
        fnids = [];
        if (true) {
            options.onDidSelectItem_AppzFuncId = "";
            let fn;
            fn = options.onDidSelectItem;
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
                    fnids.push(options.onDidSelectItem_AppzFuncId);
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args) => {
                        if (1 !== args.length) {
                            return [null, false];
                        }
                        else {
                            let ok;
                            let __0;
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem();
                                ok = __0.populateFrom(args[0]);
                                if (!ok) {
                                    return [null, false];
                                }
                            }
                            else {
                                return [null, false];
                            }
                            return [fn(__0), true];
                        }
                    };
                }
            }
        }
        msg.Data["items"] = items;
        options.canPickMany = true;
        msg.Data["options"] = options;
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl();
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId();
                }
            }
            msg.Data["token"] = token.fnId;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result;
                    [__coll__result, ok] = [payload, (typeof payload === "object") && (typeof payload["length"] === "number")];
                    if (!ok) {
                        return false;
                    }
                    result = new Array(__coll__result.length);
                    let __idx__result;
                    __idx__result = 0;
                    for (const __item__result of __coll__result) {
                        let __val__result;
                        [__val__result, ok] = [__item__result, typeof __item__result === "string"];
                        if (!ok) {
                            return false;
                        }
                        result[__idx__result] = __val__result;
                        __idx__result = __idx__result + 1;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, (payload) => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid];
                    }
                }
            }
            return (undefined === on || null === on) || on(payload);
        });
    }
    ShowQuickPick2(items, options, token, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showQuickPick2";
        msg.Data = {};
        let fnids;
        fnids = [];
        if ((undefined !== options && null !== options)) {
            options.onDidSelectItem_AppzFuncId = "";
            let fn;
            fn = options.onDidSelectItem;
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
                    fnids.push(options.onDidSelectItem_AppzFuncId);
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args) => {
                        if (1 !== args.length) {
                            return [null, false];
                        }
                        else {
                            let ok;
                            let __0;
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem();
                                ok = __0.populateFrom(args[0]);
                                if (!ok) {
                                    return [null, false];
                                }
                            }
                            else {
                                return [null, false];
                            }
                            return [fn(__0), true];
                        }
                    };
                }
            }
        }
        msg.Data["items"] = items;
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options;
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl();
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId();
                }
            }
            msg.Data["token"] = token.fnId;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, (payload) => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid];
                    }
                }
            }
            return (undefined === on || null === on) || on(payload);
        });
    }
    ShowQuickPick3(items, options, token, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showQuickPick3";
        msg.Data = {};
        let fnids;
        fnids = [];
        if (true) {
            options.onDidSelectItem_AppzFuncId = "";
            let fn;
            fn = options.onDidSelectItem;
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
                    fnids.push(options.onDidSelectItem_AppzFuncId);
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args) => {
                        if (1 !== args.length) {
                            return [null, false];
                        }
                        else {
                            let ok;
                            let __0;
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem();
                                ok = __0.populateFrom(args[0]);
                                if (!ok) {
                                    return [null, false];
                                }
                            }
                            else {
                                return [null, false];
                            }
                            return [fn(__0), true];
                        }
                    };
                }
            }
        }
        msg.Data["items"] = items;
        options.canPickMany = true;
        msg.Data["options"] = options;
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl();
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId();
                }
            }
            msg.Data["token"] = token.fnId;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result;
                    [__coll__result, ok] = [payload, (typeof payload === "object") && (typeof payload["length"] === "number")];
                    if (!ok) {
                        return false;
                    }
                    result = new Array(__coll__result.length);
                    let __idx__result;
                    __idx__result = 0;
                    for (const __item__result of __coll__result) {
                        let __val__result;
                        __val__result = newQuickPickItem();
                        ok = __val__result.populateFrom(__item__result);
                        if (!ok) {
                            return false;
                        }
                        result[__idx__result] = __val__result;
                        __idx__result = __idx__result + 1;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, (payload) => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid];
                    }
                }
            }
            return (undefined === on || null === on) || on(payload);
        });
    }
    ShowQuickPick4(items, options, token, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showQuickPick4";
        msg.Data = {};
        let fnids;
        fnids = [];
        if ((undefined !== options && null !== options)) {
            options.onDidSelectItem_AppzFuncId = "";
            let fn;
            fn = options.onDidSelectItem;
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId();
                    fnids.push(options.onDidSelectItem_AppzFuncId);
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args) => {
                        if (1 !== args.length) {
                            return [null, false];
                        }
                        else {
                            let ok;
                            let __0;
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem();
                                ok = __0.populateFrom(args[0]);
                                if (!ok) {
                                    return [null, false];
                                }
                            }
                            else {
                                return [null, false];
                            }
                            return [fn(__0), true];
                        }
                    };
                }
            }
        }
        msg.Data["items"] = items;
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options;
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl();
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId();
                }
            }
            msg.Data["token"] = token.fnId;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newQuickPickItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, (payload) => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid];
                    }
                }
            }
            return (undefined === on || null === on) || on(payload);
        });
    }
    SetStatusBarMessage1(text, hideAfterTimeout, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.setStatusBarMessage1";
        msg.Data = {};
        msg.Data["text"] = text;
        msg.Data["hideAfterTimeout"] = hideAfterTimeout;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newDisposable();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result.bind(this.Impl()));
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    SetStatusBarMessage2(text, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.setStatusBarMessage2";
        msg.Data = {};
        msg.Data["text"] = text;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newDisposable();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result.bind(this.Impl()));
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowSaveDialog(options, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showSaveDialog";
        msg.Data = {};
        msg.Data["options"] = options;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowOpenDialog(options, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showOpenDialog";
        msg.Data = {};
        msg.Data["options"] = options;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result;
                    [__coll__result, ok] = [payload, (typeof payload === "object") && (typeof payload["length"] === "number")];
                    if (!ok) {
                        return false;
                    }
                    result = new Array(__coll__result.length);
                    let __idx__result;
                    __idx__result = 0;
                    for (const __item__result of __coll__result) {
                        let __val__result;
                        [__val__result, ok] = [__item__result, typeof __item__result === "string"];
                        if (!ok) {
                            return false;
                        }
                        result[__idx__result] = __val__result;
                        __idx__result = __idx__result + 1;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ShowWorkspaceFolderPick(options, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.showWorkspaceFolderPick";
        msg.Data = {};
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newWorkspaceFolder();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    State(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.state";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newWindowState();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    OnDidChangeWindowState(listener, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.onDidChangeWindowState";
        msg.Data = {};
        let _fnid_listener;
        if ((undefined === listener || null === listener)) {
            vsc_appz_1.OnError(this.Impl(), "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
            return;
        }
        _fnid_listener = this.Impl().nextSub((args) => {
            let ok;
            if (1 !== args.length) {
                return ok;
            }
            let _a_0_;
            _a_0_ = newWindowState();
            ok = _a_0_.populateFrom(args[0]);
            if (!ok) {
                return false;
            }
            listener(_a_0_);
            return true;
        }, null);
        msg.Data["listener"] = _fnid_listener;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newDisposable();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result.bind(this.Impl(), _fnid_listener));
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    CreateStatusBarItem(alignment, priority, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "window.createStatusBarItem";
        msg.Data = {};
        if ((undefined !== alignment && null !== alignment)) {
            msg.Data["alignment"] = alignment;
        }
        if ((undefined !== priority && null !== priority)) {
            msg.Data["priority"] = priority;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newStatusBarItem();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
}
class implEnv extends implBase {
    constructor(impl) { super(impl); }
    OpenExternal(target, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.openExternal";
        msg.Data = {};
        msg.Data["target"] = target;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "boolean"];
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    AppName(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.appName";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    AppRoot(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.appRoot";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    Language(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.language";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    MachineId(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.machineId";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    RemoteName(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.remoteName";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    SessionId(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.sessionId";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    Shell(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.shell";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    UriScheme(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.uriScheme";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    Properties(then) {
        let msg;
        msg = newipcMsg();
        msg.QName = "env.Properties";
        msg.Data = {};
        let on;
        if ((undefined !== then && null !== then)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newEnvProperties();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                then(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
}
class implWorkspace extends implBase {
    constructor(impl) { super(impl); }
    Name(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.name";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    WorkspaceFile(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.workspaceFile";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    SaveAll(includeUntitled, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.saveAll";
        msg.Data = {};
        msg.Data["includeUntitled"] = includeUntitled;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, typeof payload === "boolean"];
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    OnDidChangeWorkspaceFolders(listener, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.onDidChangeWorkspaceFolders";
        msg.Data = {};
        let _fnid_listener;
        if ((undefined === listener || null === listener)) {
            vsc_appz_1.OnError(this.Impl(), "Workspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
            return;
        }
        _fnid_listener = this.Impl().nextSub((args) => {
            let ok;
            if (1 !== args.length) {
                return ok;
            }
            let _a_0_;
            _a_0_ = newWorkspaceFoldersChangeEvent();
            ok = _a_0_.populateFrom(args[0]);
            if (!ok) {
                return false;
            }
            listener(_a_0_);
            return true;
        }, null);
        msg.Data["listener"] = _fnid_listener;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newDisposable();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result.bind(this.Impl(), _fnid_listener));
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    GetWorkspaceFolder(uri, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.getWorkspaceFolder";
        msg.Data = {};
        msg.Data["uri"] = uri;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newWorkspaceFolder();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    WorkspaceFolders(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.workspaceFolders";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result;
                    [__coll__result, ok] = [payload, (typeof payload === "object") && (typeof payload["length"] === "number")];
                    if (!ok) {
                        return false;
                    }
                    result = new Array(__coll__result.length);
                    let __idx__result;
                    __idx__result = 0;
                    for (const __item__result of __coll__result) {
                        let __val__result;
                        __val__result = newWorkspaceFolder();
                        ok = __val__result.populateFrom(__item__result);
                        if (!ok) {
                            return false;
                        }
                        result[__idx__result] = __val__result;
                        __idx__result = __idx__result + 1;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    FindFiles(include, exclude, maxResults, token, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.findFiles";
        msg.Data = {};
        msg.Data["include"] = include;
        if ((undefined !== exclude && null !== exclude)) {
            msg.Data["exclude"] = exclude;
        }
        if ((undefined !== maxResults && null !== maxResults)) {
            msg.Data["maxResults"] = maxResults;
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl();
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId();
                }
            }
            msg.Data["token"] = token.fnId;
        }
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result;
                    [__coll__result, ok] = [payload, (typeof payload === "object") && (typeof payload["length"] === "number")];
                    if (!ok) {
                        return false;
                    }
                    result = new Array(__coll__result.length);
                    let __idx__result;
                    __idx__result = 0;
                    for (const __item__result of __coll__result) {
                        let __val__result;
                        [__val__result, ok] = [__item__result, typeof __item__result === "string"];
                        if (!ok) {
                            return false;
                        }
                        result[__idx__result] = __val__result;
                        __idx__result = __idx__result + 1;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    AsRelativePath(pathOrUri, includeWorkspaceFolder, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.asRelativePath";
        msg.Data = {};
        msg.Data["pathOrUri"] = pathOrUri;
        msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let _result_;
                    [_result_, ok] = [payload, typeof payload === "string"];
                    if (!ok) {
                        return false;
                    }
                    result = _result_;
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    Properties(then) {
        let msg;
        msg = newipcMsg();
        msg.QName = "workspace.Properties";
        msg.Data = {};
        let on;
        if ((undefined !== then && null !== then)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newWorkspaceProperties();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                then(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
}
class implLanguages extends implBase {
    constructor(impl) { super(impl); }
    GetLanguages(andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "languages.getLanguages";
        msg.Data = {};
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result;
                    [__coll__result, ok] = [payload, (typeof payload === "object") && (typeof payload["length"] === "number")];
                    if (!ok) {
                        return false;
                    }
                    result = new Array(__coll__result.length);
                    let __idx__result;
                    __idx__result = 0;
                    for (const __item__result of __coll__result) {
                        let __val__result;
                        [__val__result, ok] = [__item__result, typeof __item__result === "string"];
                        if (!ok) {
                            return false;
                        }
                        result[__idx__result] = __val__result;
                        __idx__result = __idx__result + 1;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    OnDidChangeDiagnostics(listener, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "languages.onDidChangeDiagnostics";
        msg.Data = {};
        let _fnid_listener;
        if ((undefined === listener || null === listener)) {
            vsc_appz_1.OnError(this.Impl(), "Languages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
            return;
        }
        _fnid_listener = this.Impl().nextSub((args) => {
            let ok;
            if (1 !== args.length) {
                return ok;
            }
            let _a_0_;
            _a_0_ = newDiagnosticChangeEvent();
            ok = _a_0_.populateFrom(args[0]);
            if (!ok) {
                return false;
            }
            listener(_a_0_);
            return true;
        }, null);
        msg.Data["listener"] = _fnid_listener;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newDisposable();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result.bind(this.Impl(), _fnid_listener));
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
}
class implExtensions extends implBase {
    constructor(impl) { super(impl); }
    OnDidChange(listener, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "extensions.onDidChange";
        msg.Data = {};
        let _fnid_listener;
        if ((undefined === listener || null === listener)) {
            vsc_appz_1.OnError(this.Impl(), "Extensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", null);
            return;
        }
        _fnid_listener = this.Impl().nextSub((args) => {
            let ok;
            if (0 !== args.length) {
                return ok;
            }
            listener();
            return true;
        }, null);
        msg.Data["listener"] = _fnid_listener;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newDisposable();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result.bind(this.Impl(), _fnid_listener));
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
}
class implCommands extends implBase {
    constructor(impl) { super(impl); }
    RegisterCommand(command, callback, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "commands.registerCommand";
        msg.Data = {};
        msg.Data["command"] = command;
        let _fnid_callback;
        if ((undefined === callback || null === callback)) {
            vsc_appz_1.OnError(this.Impl(), "Commands.RegisterCommand: the 'callback' arg (which is not optional but required) was not passed by the caller", null);
            return;
        }
        _fnid_callback = this.Impl().nextSub(null, (args) => {
            let ok;
            if (1 !== args.length) {
                return [null, ok];
            }
            let ret;
            let _a_0_;
            [_a_0_, ok] = [args[0], (typeof args[0] === "object") && (typeof args[0]["length"] === "number")];
            if (!ok) {
                return [null, false];
            }
            ret = callback(_a_0_);
            return [ret, true];
        });
        msg.Data["callback"] = _fnid_callback;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    result = newDisposable();
                    ok = result.populateFrom(payload);
                    if (!ok) {
                        return false;
                    }
                }
                else {
                    return false;
                }
                andThen(result.bind(this.Impl(), _fnid_callback));
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    ExecuteCommand(command, rest, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "commands.executeCommand";
        msg.Data = {};
        msg.Data["command"] = command;
        msg.Data["rest"] = rest;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    [result, ok] = [payload, true];
                    if (ok) {
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
    GetCommands(filterInternal, andThen) {
        let msg;
        msg = newipcMsg();
        msg.QName = "commands.getCommands";
        msg.Data = {};
        msg.Data["filterInternal"] = filterInternal;
        let on;
        if ((undefined !== andThen && null !== andThen)) {
            on = (payload) => {
                let ok;
                let result;
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result;
                    [__coll__result, ok] = [payload, (typeof payload === "object") && (typeof payload["length"] === "number")];
                    if (!ok) {
                        return false;
                    }
                    result = new Array(__coll__result.length);
                    let __idx__result;
                    __idx__result = 0;
                    for (const __item__result of __coll__result) {
                        let __val__result;
                        [__val__result, ok] = [__item__result, typeof __item__result === "string"];
                        if (!ok) {
                            return false;
                        }
                        result[__idx__result] = __val__result;
                        __idx__result = __idx__result + 1;
                    }
                }
                andThen(result);
                return true;
            };
        }
        this.Impl().send(msg, on);
    }
}
function MessageItem_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["title"], undefined !== it["title"]];
    if (ok) {
        let title;
        if ((undefined !== val && null !== val)) {
            [title, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
        }
        this.title = title;
    }
    else {
        return false;
    }
    [val, ok] = [it["isCloseAffordance"], undefined !== it["isCloseAffordance"]];
    if (ok) {
        let isCloseAffordance;
        if ((undefined !== val && null !== val)) {
            let _isCloseAffordance_;
            [_isCloseAffordance_, ok] = [val, typeof val === "boolean"];
            if (!ok) {
                return false;
            }
            isCloseAffordance = _isCloseAffordance_;
        }
        this.isCloseAffordance = isCloseAffordance;
    }
    [val, ok] = [it["my"], undefined !== it["my"]];
    if (ok) {
        let my;
        if ((undefined !== val && null !== val)) {
            [my, ok] = [val, typeof val === "object"];
            if (!ok) {
                return false;
            }
        }
        this.my = my;
    }
    return true;
}
function QuickPickItem_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["label"], undefined !== it["label"]];
    if (ok) {
        let label;
        if ((undefined !== val && null !== val)) {
            [label, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
        }
        this.label = label;
    }
    else {
        return false;
    }
    [val, ok] = [it["description"], undefined !== it["description"]];
    if (ok) {
        let description;
        if ((undefined !== val && null !== val)) {
            let _description_;
            [_description_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            description = _description_;
        }
        this.description = description;
    }
    [val, ok] = [it["detail"], undefined !== it["detail"]];
    if (ok) {
        let detail;
        if ((undefined !== val && null !== val)) {
            let _detail_;
            [_detail_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            detail = _detail_;
        }
        this.detail = detail;
    }
    [val, ok] = [it["picked"], undefined !== it["picked"]];
    if (ok) {
        let picked;
        if ((undefined !== val && null !== val)) {
            let _picked_;
            [_picked_, ok] = [val, typeof val === "boolean"];
            if (!ok) {
                return false;
            }
            picked = _picked_;
        }
        this.picked = picked;
    }
    [val, ok] = [it["alwaysShow"], undefined !== it["alwaysShow"]];
    if (ok) {
        let alwaysShow;
        if ((undefined !== val && null !== val)) {
            let _alwaysShow_;
            [_alwaysShow_, ok] = [val, typeof val === "boolean"];
            if (!ok) {
                return false;
            }
            alwaysShow = _alwaysShow_;
        }
        this.alwaysShow = alwaysShow;
    }
    [val, ok] = [it["my"], undefined !== it["my"]];
    if (ok) {
        let my;
        if ((undefined !== val && null !== val)) {
            [my, ok] = [val, typeof val === "object"];
            if (!ok) {
                return false;
            }
        }
        this.my = my;
    }
    return true;
}
function WorkspaceFolder_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["uri"], undefined !== it["uri"]];
    if (ok) {
        let uri;
        if ((undefined !== val && null !== val)) {
            [uri, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
        }
        this.uri = uri;
    }
    else {
        return false;
    }
    [val, ok] = [it["name"], undefined !== it["name"]];
    if (ok) {
        let name;
        if ((undefined !== val && null !== val)) {
            [name, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
        }
        this.name = name;
    }
    else {
        return false;
    }
    [val, ok] = [it["index"], undefined !== it["index"]];
    if (ok) {
        let index;
        if ((undefined !== val && null !== val)) {
            [index, ok] = [val, typeof val === "number"];
            if (!ok) {
                let __index__;
                [__index__, ok] = [val, typeof val === "number"];
                if (!ok) {
                    return false;
                }
                index = __index__;
            }
        }
        this.index = index;
    }
    else {
        return false;
    }
    return true;
}
function WindowState_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["focused"], undefined !== it["focused"]];
    if (ok) {
        let focused;
        if ((undefined !== val && null !== val)) {
            [focused, ok] = [val, typeof val === "boolean"];
            if (!ok) {
                return false;
            }
        }
        this.focused = focused;
    }
    else {
        return false;
    }
    return true;
}
function StatusBarItem_populateFrom(payload) {
    let ok;
    this.disp = newDisposable();
    ok = this.disp.populateFrom(payload);
    return ok;
}
function EnvProperties_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["appName"], undefined !== it["appName"]];
    if (ok) {
        let appName;
        if ((undefined !== val && null !== val)) {
            let _appName_;
            [_appName_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            appName = _appName_;
        }
        this.appName = appName;
    }
    [val, ok] = [it["appRoot"], undefined !== it["appRoot"]];
    if (ok) {
        let appRoot;
        if ((undefined !== val && null !== val)) {
            let _appRoot_;
            [_appRoot_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            appRoot = _appRoot_;
        }
        this.appRoot = appRoot;
    }
    [val, ok] = [it["language"], undefined !== it["language"]];
    if (ok) {
        let language;
        if ((undefined !== val && null !== val)) {
            let _language_;
            [_language_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            language = _language_;
        }
        this.language = language;
    }
    [val, ok] = [it["machineId"], undefined !== it["machineId"]];
    if (ok) {
        let machineId;
        if ((undefined !== val && null !== val)) {
            let _machineId_;
            [_machineId_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            machineId = _machineId_;
        }
        this.machineId = machineId;
    }
    [val, ok] = [it["remoteName"], undefined !== it["remoteName"]];
    if (ok) {
        let remoteName;
        if ((undefined !== val && null !== val)) {
            let _remoteName_;
            [_remoteName_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            remoteName = _remoteName_;
        }
        this.remoteName = remoteName;
    }
    [val, ok] = [it["sessionId"], undefined !== it["sessionId"]];
    if (ok) {
        let sessionId;
        if ((undefined !== val && null !== val)) {
            let _sessionId_;
            [_sessionId_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            sessionId = _sessionId_;
        }
        this.sessionId = sessionId;
    }
    [val, ok] = [it["shell"], undefined !== it["shell"]];
    if (ok) {
        let shell;
        if ((undefined !== val && null !== val)) {
            let _shell_;
            [_shell_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            shell = _shell_;
        }
        this.shell = shell;
    }
    [val, ok] = [it["uriScheme"], undefined !== it["uriScheme"]];
    if (ok) {
        let uriScheme;
        if ((undefined !== val && null !== val)) {
            let _uriScheme_;
            [_uriScheme_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            uriScheme = _uriScheme_;
        }
        this.uriScheme = uriScheme;
    }
    return true;
}
function WorkspaceFoldersChangeEvent_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["added"], undefined !== it["added"]];
    if (ok) {
        let added;
        if ((undefined !== val && null !== val)) {
            let __coll__added;
            [__coll__added, ok] = [val, (typeof val === "object") && (typeof val["length"] === "number")];
            if (!ok) {
                return false;
            }
            added = new Array(__coll__added.length);
            let __idx__added;
            __idx__added = 0;
            for (const __item__added of __coll__added) {
                let __val__added;
                __val__added = newWorkspaceFolder();
                ok = __val__added.populateFrom(__item__added);
                if (!ok) {
                    return false;
                }
                added[__idx__added] = __val__added;
                __idx__added = __idx__added + 1;
            }
        }
        this.added = added;
    }
    else {
        return false;
    }
    [val, ok] = [it["removed"], undefined !== it["removed"]];
    if (ok) {
        let removed;
        if ((undefined !== val && null !== val)) {
            let __coll__removed;
            [__coll__removed, ok] = [val, (typeof val === "object") && (typeof val["length"] === "number")];
            if (!ok) {
                return false;
            }
            removed = new Array(__coll__removed.length);
            let __idx__removed;
            __idx__removed = 0;
            for (const __item__removed of __coll__removed) {
                let __val__removed;
                __val__removed = newWorkspaceFolder();
                ok = __val__removed.populateFrom(__item__removed);
                if (!ok) {
                    return false;
                }
                removed[__idx__removed] = __val__removed;
                __idx__removed = __idx__removed + 1;
            }
        }
        this.removed = removed;
    }
    else {
        return false;
    }
    return true;
}
function WorkspaceProperties_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["name"], undefined !== it["name"]];
    if (ok) {
        let name;
        if ((undefined !== val && null !== val)) {
            let _name_;
            [_name_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            name = _name_;
        }
        this.name = name;
    }
    [val, ok] = [it["workspaceFile"], undefined !== it["workspaceFile"]];
    if (ok) {
        let workspaceFile;
        if ((undefined !== val && null !== val)) {
            let _workspaceFile_;
            [_workspaceFile_, ok] = [val, typeof val === "string"];
            if (!ok) {
                return false;
            }
            workspaceFile = _workspaceFile_;
        }
        this.workspaceFile = workspaceFile;
    }
    [val, ok] = [it["workspaceFolders"], undefined !== it["workspaceFolders"]];
    if (ok) {
        let workspaceFolders;
        if ((undefined !== val && null !== val)) {
            let __coll__workspaceFolders;
            [__coll__workspaceFolders, ok] = [val, (typeof val === "object") && (typeof val["length"] === "number")];
            if (!ok) {
                return false;
            }
            workspaceFolders = new Array(__coll__workspaceFolders.length);
            let __idx__workspaceFolders;
            __idx__workspaceFolders = 0;
            for (const __item__workspaceFolders of __coll__workspaceFolders) {
                let __val__workspaceFolders;
                __val__workspaceFolders = newWorkspaceFolder();
                ok = __val__workspaceFolders.populateFrom(__item__workspaceFolders);
                if (!ok) {
                    return false;
                }
                workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders;
                __idx__workspaceFolders = __idx__workspaceFolders + 1;
            }
        }
        this.workspaceFolders = workspaceFolders;
    }
    return true;
}
function DiagnosticChangeEvent_populateFrom(payload) {
    let it;
    let ok;
    let val;
    [it, ok] = [payload, typeof payload === "object"];
    if (!ok) {
        return false;
    }
    [val, ok] = [it["uris"], undefined !== it["uris"]];
    if (ok) {
        let uris;
        if ((undefined !== val && null !== val)) {
            let __coll__uris;
            [__coll__uris, ok] = [val, (typeof val === "object") && (typeof val["length"] === "number")];
            if (!ok) {
                return false;
            }
            uris = new Array(__coll__uris.length);
            let __idx__uris;
            __idx__uris = 0;
            for (const __item__uris of __coll__uris) {
                let __val__uris;
                [__val__uris, ok] = [__item__uris, typeof __item__uris === "string"];
                if (!ok) {
                    return false;
                }
                uris[__idx__uris] = __val__uris;
                __idx__uris = __idx__uris + 1;
            }
        }
        this.uris = uris;
    }
    else {
        return false;
    }
    return true;
}
