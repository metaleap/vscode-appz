// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-nodesjs.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
import * as aux from './aux'
import { OnError } from './vsc-appz'
type ipcMsg = aux.ipcMsg
type Cancel = aux.Cancel
type Disposable = aux.Disposable
interface fromJson { populateFrom: (_: any) => boolean }

abstract class implBase {
    impl: impl
    constructor(impl: impl) { this.impl = impl }
    Impl() { return this.impl as any as aux.impl /* crikey, codegen life.. */ }
}

function new_ipcMsg() { return new aux.ipcMsg() }
function new_Disposable() { return new aux.Disposable() }

/**
 * Type Definition for Visual Studio Code 1.38 Extension API
 * See https://code.visualstudio.com/api for more information

 */
export interface Vscode {
    /**
     * Namespace for dealing with the current window of the editor. That is visible
     * and active editors, as well as, UI elements to show messages, selections, and
     * asking for user input.

     */
    Window: Window

    /**
     * Namespace describing the environment the editor runs in.

     */
    Env: Env

    /**
     * Namespace for dealing with the current workspace. A workspace is the representation
     * of the folder that has been opened. There is no workspace when just a file but not a
     * folder has been opened.
     * 
     * The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
     * events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
     * the editor-process so that they should be always used instead of nodejs-equivalents.

     */
    Workspace: Workspace

    /**
     * Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
     * like IntelliSense, code actions, diagnostics etc.
     * 
     * Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
     * like automatic word-completion, code navigation, or code checking have become popular across different tools for different
     * programming languages.
     * 
     * The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
     * by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
     * that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
     * mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
     * 
     * ```javascript
     * languages.registerHoverProvider('javascript', {
     *  	provideHover(document, position, token) {
     *  		return new Hover('I am a hover!');
     *  	}
     * });
     * ```
     * 
     * Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
     * a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
     * a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
     * scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
     * the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
     * score is used for determining the order in which providers are asked to participate.

     */
    Languages: Languages

    /**
     * Namespace for dealing with installed extensions. Extensions are represented
     * by an [extension](#Extension)-interface which enables reflection on them.
     * 
     * Extension writers can provide APIs to other extensions by returning their API public
     * surface from the `activate`-call.
     * 
     * ```javascript
     * export function activate(context: vscode.ExtensionContext) {
     *  	let api = {
     *  		sum(a, b) {
     *  			return a + b;
     *  		},
     *  		mul(a, b) {
     *  			return a * b;
     *  		}
     *  	};
     *  	// 'export' public api-surface
     *  	return api;
     * }
     * ```
     * When depending on the API of another extension add an `extensionDependency`-entry
     * to `package.json`, and use the [getExtension](#extensions.getExtension)-function
     * and the [exports](#Extension.exports)-property, like below:
     * 
     * ```javascript
     * let mathExt = extensions.getExtension('genius.math');
     * let importedApi = mathExt.exports;
     * 
     * console.log(importedApi.mul(42, 1));
     * ```

     */
    Extensions: Extensions

    /**
     * Namespace for dealing with commands. In short, a command is a function with a
     * unique identifier. The function is sometimes also called _command handler_.
     * 
     * Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
     * and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
     * can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
     * 
     * * palette - Use the `commands`-section in `package.json` to make a command show in
     * the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
     * * keybinding - Use the `keybindings`-section in `package.json` to enable
     * [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
     * for your extension.
     * 
     * Commands from other extensions and from the editor itself are accessible to an extension. However,
     * when invoking an editor command not all argument types are supported.
     * 
     * This is a sample that registers a command handler and adds an entry for that command to the palette. First
     * register a command handler with the identifier `extension.sayHello`.
     * ```javascript
     * commands.registerCommand('extension.sayHello', () => {
     *  	window.showInformationMessage('Hello World!');
     * });
     * ```
     * Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
     * ```json
     * {
     *  	"contributes": {
     *  		"commands": [{
     *  			"command": "extension.sayHello",
     *  			"title": "Hello World"
     *  		}]
     *  	}
     * }
     * ```

     */
    Commands: Commands
}

/**
 * Namespace for dealing with the current window of the editor. That is visible
 * and active editors, as well as, UI elements to show messages, selections, and
 * asking for user input.

 */
export interface Window {
    /**
     * Show an information message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage1: (message: string, items: string[], then?: (_: string) => void) => void

    /**
     * Show an information message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage2: (message: string, options: MessageOptions, items: string[], then?: (_: string) => void) => void

    /**
     * Show an information message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage3: (message: string, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show an information message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage4: (message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage1: (message: string, items: string[], then?: (_: string) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage2: (message: string, options: MessageOptions, items: string[], then?: (_: string) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage3: (message: string, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage4: (message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage1: (message: string, items: string[], then?: (_: string) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage2: (message: string, options: MessageOptions, items: string[], then?: (_: string) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage3: (message: string, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage4: (message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Opens an input box to ask the user for input.
     * 
     * The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
     * returned value will be the string typed by the user or an empty string if the user did not type
     * anything but dismissed the input box with OK.

     * @param options Configures the behavior of the input box.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
     */
    ShowInputBox: (options?: InputBoxOptions, token?: Cancel, then?: (_: string) => void) => void

    /**
     * Shows a selection list allowing multiple selections.

     * @param items An array of strings, or a promise that resolves to an array of strings.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selected items or `undefined`.
     */
    ShowQuickPick1: (items: string[], options: QuickPickOptions, token?: Cancel, then?: (_: string[]) => void) => void

    /**
     * Shows a selection list.

     * @param items An array of strings, or a promise that resolves to an array of strings.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selection or `undefined`.
     */
    ShowQuickPick2: (items: string[], options?: QuickPickOptions, token?: Cancel, then?: (_: string) => void) => void

    /**
     * Shows a selection list allowing multiple selections.

     * @param items An array of items, or a promise that resolves to an array of items.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selected items or `undefined`.
     */
    ShowQuickPick3: (items: QuickPickItem[], options: QuickPickOptions, token?: Cancel, then?: (_: QuickPickItem[]) => void) => void

    /**
     * Shows a selection list.

     * @param items An array of items, or a promise that resolves to an array of items.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selected item or `undefined`.
     */
    ShowQuickPick4: (items: QuickPickItem[], options?: QuickPickOptions, token?: Cancel, then?: (_: QuickPickItem) => void) => void

    /**
     * Set a message to the status bar. This is a short hand for the more powerful
     * status bar [items](#window.createStatusBarItem).

     * @param text The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
     * @param hideAfterTimeout Timeout in milliseconds after which the message will be disposed.
     * @param then A disposable which hides the status bar message.
     */
    SetStatusBarMessage1: (text: string, hideAfterTimeout: number, then?: (_: Disposable) => void) => void

    /**
     * Set a message to the status bar. This is a short hand for the more powerful
     * status bar [items](#window.createStatusBarItem).
     * 
     * *Note* that status bar messages stack and that they must be disposed when no
     * longer used.

     * @param text The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
     * @param then A disposable which hides the status bar message.
     */
    SetStatusBarMessage2: (text: string, then?: (_: Disposable) => void) => void

    /**
     * Shows a file save dialog to the user which allows to select a file
     * for saving-purposes.

     * @param options Options that control the dialog.
     * @param then A promise that resolves to the selected resource or `undefined`.
     */
    ShowSaveDialog: (options: SaveDialogOptions, then?: (_: string) => void) => void

    /**
     * Shows a file open dialog to the user which allows to select a file
     * for opening-purposes.

     * @param options Options that control the dialog.
     * @param then A promise that resolves to the selected resources or `undefined`.
     */
    ShowOpenDialog: (options: OpenDialogOptions, then?: (_: string[]) => void) => void

    /**
     * Shows a selection list of [workspace folders](#workspace.workspaceFolders) to pick from.
     * Returns `undefined` if no folder is open.

     * @param options Configures the behavior of the workspace folder list.
     * @param then A promise that resolves to the workspace folder or `undefined`.
     */
    ShowWorkspaceFolderPick: (options?: WorkspaceFolderPickOptions, then?: (_: WorkspaceFolder) => void) => void

    /**
     * Represents the current window's state.

     */
    State: (then?: (_: WindowState) => void) => void

    /**
     * An [event](#Event) which fires when the focus state of the current window
     * changes. The value of the event represents whether the window is focused.

     */
    OnDidChangeWindowState: (listener: (_: WindowState) => void, then?: (_: Disposable) => void) => void
}

/**
 * Namespace describing the environment the editor runs in.

 */
export interface Env {
    /**
     * Opens an *external* item, e.g. a http(s) or mailto-link, using the
     * default application.
     * 
     * *Note* that [`showTextDocument`](#window.showTextDocument) is the right
     * way to open a text document inside the editor, not this function.

     * @param target The uri that should be opened.
     * @param then A promise indicating if open was successful.
     */
    OpenExternal: (target: string, then?: (_: boolean) => void) => void

    /**
     * The application name of the editor, like 'VS Code'.

     */
    AppName: (then?: (_: string) => void) => void

    /**
     * The application root folder from which the editor is running.

     */
    AppRoot: (then?: (_: string) => void) => void

    /**
     * Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.

     */
    Language: (then?: (_: string) => void) => void

    /**
     * A unique identifier for the computer.

     */
    MachineId: (then?: (_: string) => void) => void

    /**
     * The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
     * Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
     * 
     * *Note* that the value is `undefined` when there is no remote extension host but that the
     * value is defined in all extension hosts (local and remote) in case a remote extension host
     * exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
     * a specific extension runs remote or not.

     */
    RemoteName: (then?: (_: string) => void) => void

    /**
     * A unique identifier for the current session.
     * Changes each time the editor is started.

     */
    SessionId: (then?: (_: string) => void) => void

    /**
     * The detected default shell for the extension host, this is overridden by the
     * `terminal.integrated.shell` setting for the extension host's platform.

     */
    Shell: (then?: (_: string) => void) => void

    /**
     * The custom uri scheme the editor registers to in the operating system.

     */
    UriScheme: (then?: (_: string) => void) => void

    /**
     * Provides single-call access to numerous individual `Env` properties at once.

     */
    Properties: (then: (_: EnvProperties) => void) => void
}

/**
 * Namespace for dealing with the current workspace. A workspace is the representation
 * of the folder that has been opened. There is no workspace when just a file but not a
 * folder has been opened.
 * 
 * The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
 * events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
 * the editor-process so that they should be always used instead of nodejs-equivalents.

 */
export interface Workspace {
    /**
     * The name of the workspace. `undefined` when no folder
     * has been opened.

     */
    Name: (then?: (_: string) => void) => void

    /**
     * The location of the workspace file, for example:
     * 
     * `file:///Users/name/Development/myProject.code-workspace`
     * 
     * or
     * 
     * `untitled:1555503116870`
     * 
     * for a workspace that is untitled and not yet saved.
     * 
     * Depending on the workspace that is opened, the value will be:
     *   * `undefined` when no workspace or  a single folder is opened
     *   * the path of the workspace file as `Uri` otherwise. if the workspace
     * is untitled, the returned URI will use the `untitled:` scheme
     * 
     * The location can e.g. be used with the `vscode.openFolder` command to
     * open the workspace again after it has been closed.
     * 
     * **Example:**
     * ```typescript
     * vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
     * ```
     * 
     * **Note:** it is not advised to use `workspace.workspaceFile` to write
     * configuration data into the file. You can use `workspace.getConfiguration().update()`
     * for that purpose which will work both when a single folder is opened as
     * well as an untitled or saved workspace.

     */
    WorkspaceFile: (then?: (_: string) => void) => void

    /**
     * Save all dirty files.

     * @param includeUntitled Also save files that have been created during this session.
     * @param then A thenable that resolves when the files have been saved.
     */
    SaveAll: (includeUntitled: boolean, then?: (_: boolean) => void) => void

    /**
     * An event that is emitted when a workspace folder is added or removed.

     */
    OnDidChangeWorkspaceFolders: (listener: (_: WorkspaceFoldersChangeEvent) => void, then?: (_: Disposable) => void) => void

    /**
     * Returns the [workspace folder](#WorkspaceFolder) that contains a given uri.
     * * returns `undefined` when the given uri doesn't match any workspace folder
     * * returns the *input* when the given uri is a workspace folder itself

     * @param uri An uri.
     * @param then A workspace folder or `undefined`
     */
    GetWorkspaceFolder: (uri: string, then?: (_: WorkspaceFolder) => void) => void

    /**
     * List of workspace folders or `undefined` when no folder is open.
     * *Note* that the first entry corresponds to the value of `rootPath`.

     */
    WorkspaceFolders: (then?: (_: WorkspaceFolder[]) => void) => void

    /**
     * Find files across all [workspace folders](#workspace.workspaceFolders) in the workspace.
     * `findFiles('**​/*.js', '**​/node_modules/**', 10)`

     * @param include A [glob pattern](#GlobPattern) that defines the files to search for. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](#RelativePattern) to restrict the search results to a [workspace folder](#WorkspaceFolder).
     * @param exclude A [glob pattern](#GlobPattern) that defines files and folders to exclude. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will apply, when `null` no excludes will apply.
     * @param maxResults An upper-bound for the result.
     * @param token A token that can be used to signal cancellation to the underlying search engine.
     * @param then A thenable that resolves to an array of resource identifiers. Will return no results if no [workspace folders](#workspace.workspaceFolders) are opened.
     */
    FindFiles: (include: string, exclude?: string, maxResults?: number, token?: Cancel, then?: (_: string[]) => void) => void

    /**
     * Returns a path that is relative to the workspace folder or folders.
     * 
     * When there are no [workspace folders](#workspace.workspaceFolders) or when the path
     * is not contained in them, the input is returned.

     * @param pathOrUri A path or uri. When a uri is given its [fsPath](#Uri.fsPath) is used.
     * @param includeWorkspaceFolder When `true` and when the given path is contained inside a workspace folder the name of the workspace is prepended. Defaults to `true` when there are multiple workspace folders and `false` otherwise.
     * @param then A path relative to the root or the input.
     */
    AsRelativePath: (pathOrUri: string, includeWorkspaceFolder: boolean, then?: (_: string) => void) => void

    /**
     * Provides single-call access to numerous individual `Workspace` properties at once.

     */
    Properties: (then: (_: WorkspaceProperties) => void) => void
}

/**
 * Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
 * like IntelliSense, code actions, diagnostics etc.
 * 
 * Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
 * like automatic word-completion, code navigation, or code checking have become popular across different tools for different
 * programming languages.
 * 
 * The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
 * by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
 * that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
 * mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
 * 
 * ```javascript
 * languages.registerHoverProvider('javascript', {
 *  	provideHover(document, position, token) {
 *  		return new Hover('I am a hover!');
 *  	}
 * });
 * ```
 * 
 * Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
 * a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
 * a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
 * scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
 * the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
 * score is used for determining the order in which providers are asked to participate.

 */
export interface Languages {
    /**
     * Return the identifiers of all known languages.

     * @param then Promise resolving to an array of identifier strings.
     */
    GetLanguages: (then?: (_: string[]) => void) => void

    /**
     * An [event](#Event) which fires when the global set of diagnostics changes. This is
     * newly added and removed diagnostics.

     */
    OnDidChangeDiagnostics: (listener: (_: DiagnosticChangeEvent) => void, then?: (_: Disposable) => void) => void
}

/**
 * Namespace for dealing with installed extensions. Extensions are represented
 * by an [extension](#Extension)-interface which enables reflection on them.
 * 
 * Extension writers can provide APIs to other extensions by returning their API public
 * surface from the `activate`-call.
 * 
 * ```javascript
 * export function activate(context: vscode.ExtensionContext) {
 *  	let api = {
 *  		sum(a, b) {
 *  			return a + b;
 *  		},
 *  		mul(a, b) {
 *  			return a * b;
 *  		}
 *  	};
 *  	// 'export' public api-surface
 *  	return api;
 * }
 * ```
 * When depending on the API of another extension add an `extensionDependency`-entry
 * to `package.json`, and use the [getExtension](#extensions.getExtension)-function
 * and the [exports](#Extension.exports)-property, like below:
 * 
 * ```javascript
 * let mathExt = extensions.getExtension('genius.math');
 * let importedApi = mathExt.exports;
 * 
 * console.log(importedApi.mul(42, 1));
 * ```

 */
export interface Extensions {
    /**
     * An event which fires when `extensions.all` changes. This can happen when extensions are
     * installed, uninstalled, enabled or disabled.

     */
    OnDidChange: (listener: () => void, then?: (_: Disposable) => void) => void
}

/**
 * Namespace for dealing with commands. In short, a command is a function with a
 * unique identifier. The function is sometimes also called _command handler_.
 * 
 * Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
 * and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
 * can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
 * 
 * * palette - Use the `commands`-section in `package.json` to make a command show in
 * the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
 * * keybinding - Use the `keybindings`-section in `package.json` to enable
 * [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
 * for your extension.
 * 
 * Commands from other extensions and from the editor itself are accessible to an extension. However,
 * when invoking an editor command not all argument types are supported.
 * 
 * This is a sample that registers a command handler and adds an entry for that command to the palette. First
 * register a command handler with the identifier `extension.sayHello`.
 * ```javascript
 * commands.registerCommand('extension.sayHello', () => {
 *  	window.showInformationMessage('Hello World!');
 * });
 * ```
 * Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
 * ```json
 * {
 *  	"contributes": {
 *  		"commands": [{
 *  			"command": "extension.sayHello",
 *  			"title": "Hello World"
 *  		}]
 *  	}
 * }
 * ```

 */
export interface Commands {
    /**
     * Retrieve the list of all available commands. Commands starting an underscore are
     * treated as internal commands.

     * @param filterInternal Set `true` to not see internal commands (starting with an underscore)
     * @param then Thenable that resolves to a list of command ids.
     */
    GetCommands: (filterInternal: boolean, then?: (_: string[]) => void) => void
}

/**
 * Options to configure the behavior of the message.

 */
export interface MessageOptions {
    /**
     * Indicates that this message should be modal.

     */
    Modal?: boolean
}

/**
 * Represents an action that is shown with an information, warning, or
 * error message.

 */
export interface MessageItem extends fromJson {
    /**
     * A short title like 'Retry', 'Open Log' etc.

     */
    Title: string

    /**
     * A hint for modal dialogs that the item should be triggered
     * when the user cancels the dialog (e.g. by pressing the ESC
     * key).
     * 
     * Note: this option is ignored for non-modal messages.

     */
    IsCloseAffordance?: boolean

    /**
     * Free-form custom data, preserved across a roundtrip.

     */
    My?: { [_: string]: any}
}

function new_MessageItem () {
    let me: MessageItem
    me = { populateFrom: _ => MessageItem_populateFrom.call(me, _) } as MessageItem
    return me
}

/**
 * Options to configure the behavior of the input box UI.

 */
export interface InputBoxOptions {
    /**
     * The value to prefill in the input box.

     */
    Value?: string

    /**
     * Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
     * first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
     * word will be selected, when empty (start equals end) only the cursor will be set,
     * otherwise the defined range will be selected.

     */
    ValueSelection?: [number, number]

    /**
     * The text to display underneath the input box.

     */
    Prompt?: string

    /**
     * An optional string to show as place holder in the input box to guide the user what to type.

     */
    PlaceHolder?: string

    /**
     * Set to `true` to show a password prompt that will not show the typed value.

     */
    Password?: boolean

    /**
     * Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.

     */
    IgnoreFocusOut?: boolean

    /**
     * An optional function that will be called to validate input and to give a hint
     * to the user.
     * 
     * `value` ── The current value of the input box.
     * 
     * `return` ── A human readable string which is presented as diagnostic message.
     * Return `undefined`, `null`, or the empty string when 'value' is valid.

     */
    ValidateInput?: (_: string) => string

    /**
     * For internal runtime use only.

     */
    ValidateInput_AppzFuncId: string
}

/**
 * Options to configure the behavior of the quick pick UI.

 */
export interface QuickPickOptions {
    /**
     * An optional flag to include the description when filtering the picks.

     */
    MatchOnDescription?: boolean

    /**
     * An optional flag to include the detail when filtering the picks.

     */
    MatchOnDetail?: boolean

    /**
     * An optional string to show as place holder in the input box to guide the user what to pick on.

     */
    PlaceHolder?: string

    /**
     * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.

     */
    IgnoreFocusOut?: boolean

    /**
     * An optional flag to make the picker accept multiple selections, if true the result is an array of picks.

     */
    CanPickMany?: boolean

    /**
     * An optional function that is invoked whenever an item is selected.

     */
    OnDidSelectItem?: (_: QuickPickItem) => any

    /**
     * For internal runtime use only.

     */
    OnDidSelectItem_AppzFuncId: string
}

/**
 * Represents an item that can be selected from
 * a list of items.

 */
export interface QuickPickItem extends fromJson {
    /**
     * A human readable string which is rendered prominent.

     */
    Label: string

    /**
     * A human readable string which is rendered less prominent.

     */
    Description?: string

    /**
     * A human readable string which is rendered less prominent.

     */
    Detail?: string

    /**
     * Optional flag indicating if this item is picked initially.
     * (Only honored when the picker allows multiple selections.)

     */
    Picked?: boolean

    /**
     * Always show this item.

     */
    AlwaysShow?: boolean

    /**
     * Free-form custom data, preserved across a roundtrip.

     */
    My?: { [_: string]: any}
}

function new_QuickPickItem () {
    let me: QuickPickItem
    me = { populateFrom: _ => QuickPickItem_populateFrom.call(me, _) } as QuickPickItem
    return me
}

/**
 * Options to configure the behaviour of a file save dialog.

 */
export interface SaveDialogOptions {
    /**
     * The resource the dialog shows when opened.

     */
    DefaultUri?: string

    /**
     * A human-readable string for the save button.

     */
    SaveLabel?: string

    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions, e.g.
     * ```ts
     * {
     *  	'Images': ['png', 'jpg']
     *  	'TypeScript': ['ts', 'tsx']
     * }
     * ```

     */
    Filters?: { [_:string]: string[]}
}

/**
 * Options to configure the behaviour of a file open dialog.
 * 
 * * Note 1: A dialog can select files, folders, or both. This is not true for Windows
 * which enforces to open either files or folder, but *not both*.
 * * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
 * and the editor then silently adjusts the options to select files.

 */
export interface OpenDialogOptions {
    /**
     * The resource the dialog shows when opened.

     */
    DefaultUri?: string

    /**
     * A human-readable string for the open button.

     */
    OpenLabel?: string

    /**
     * Allow to select files, defaults to `true`.

     */
    CanSelectFiles?: boolean

    /**
     * Allow to select folders, defaults to `false`.

     */
    CanSelectFolders?: boolean

    /**
     * Allow to select many files or folders.

     */
    CanSelectMany?: boolean

    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions, e.g.
     * ```ts
     * {
     *  	'Images': ['png', 'jpg']
     *  	'TypeScript': ['ts', 'tsx']
     * }
     * ```

     */
    Filters?: { [_:string]: string[]}
}

/**
 * Options to configure the behaviour of the [workspace folder](#WorkspaceFolder) pick UI.

 */
export interface WorkspaceFolderPickOptions {
    /**
     * An optional string to show as place holder in the input box to guide the user what to pick on.

     */
    PlaceHolder?: string

    /**
     * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.

     */
    IgnoreFocusOut?: boolean
}

/**
 * A workspace folder is one of potentially many roots opened by the editor. All workspace folders
 * are equal which means there is no notion of an active or master workspace folder.

 */
export interface WorkspaceFolder extends fromJson {
    /**
     * The associated uri for this workspace folder.
     * 
     * *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
     * workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.

     */
    Uri: string

    /**
     * The name of this workspace folder. Defaults to
     * the basename of its [uri-path](#Uri.path)

     */
    Name: string

    /**
     * The ordinal number of this workspace folder.

     */
    Index: number
}

function new_WorkspaceFolder () {
    let me: WorkspaceFolder
    me = { populateFrom: _ => WorkspaceFolder_populateFrom.call(me, _) } as WorkspaceFolder
    return me
}

/**
 * Represents the state of a window.

 */
export interface WindowState extends fromJson {
    /**
     * Whether the current window is focused.

     */
    Focused: boolean
}

function new_WindowState () {
    let me: WindowState
    me = { populateFrom: _ => WindowState_populateFrom.call(me, _) } as WindowState
    return me
}

/**
 * An event describing a change to the set of [workspace folders](#workspace.workspaceFolders).

 */
export interface WorkspaceFoldersChangeEvent extends fromJson {
    /**
     * Added workspace folders.

     */
    Added: WorkspaceFolder[]

    /**
     * Removed workspace folders.

     */
    Removed: WorkspaceFolder[]
}

function new_WorkspaceFoldersChangeEvent () {
    let me: WorkspaceFoldersChangeEvent
    me = { populateFrom: _ => WorkspaceFoldersChangeEvent_populateFrom.call(me, _) } as WorkspaceFoldersChangeEvent
    return me
}

/**
 * The event that is fired when diagnostics change.

 */
export interface DiagnosticChangeEvent extends fromJson {
    /**
     * An array of resources for which diagnostics have changed.

     */
    Uris: string[]
}

function new_DiagnosticChangeEvent () {
    let me: DiagnosticChangeEvent
    me = { populateFrom: _ => DiagnosticChangeEvent_populateFrom.call(me, _) } as DiagnosticChangeEvent
    return me
}

/**
 * Namespace describing the environment the editor runs in.

 */
export interface EnvProperties extends fromJson {
    /**
     * The application name of the editor, like 'VS Code'.

     */
    AppName?: string

    /**
     * The application root folder from which the editor is running.

     */
    AppRoot?: string

    /**
     * Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.

     */
    Language?: string

    /**
     * A unique identifier for the computer.

     */
    MachineId?: string

    /**
     * The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
     * Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
     * 
     * *Note* that the value is `undefined` when there is no remote extension host but that the
     * value is defined in all extension hosts (local and remote) in case a remote extension host
     * exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
     * a specific extension runs remote or not.

     */
    RemoteName?: string

    /**
     * A unique identifier for the current session.
     * Changes each time the editor is started.

     */
    SessionId?: string

    /**
     * The detected default shell for the extension host, this is overridden by the
     * `terminal.integrated.shell` setting for the extension host's platform.

     */
    Shell?: string

    /**
     * The custom uri scheme the editor registers to in the operating system.

     */
    UriScheme?: string
}

function new_EnvProperties () {
    let me: EnvProperties
    me = { populateFrom: _ => EnvProperties_populateFrom.call(me, _) } as EnvProperties
    return me
}

/**
 * Namespace for dealing with the current workspace. A workspace is the representation
 * of the folder that has been opened. There is no workspace when just a file but not a
 * folder has been opened.
 * 
 * The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
 * events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
 * the editor-process so that they should be always used instead of nodejs-equivalents.

 */
export interface WorkspaceProperties extends fromJson {
    /**
     * The name of the workspace. `undefined` when no folder
     * has been opened.

     */
    Name?: string

    /**
     * The location of the workspace file, for example:
     * 
     * `file:///Users/name/Development/myProject.code-workspace`
     * 
     * or
     * 
     * `untitled:1555503116870`
     * 
     * for a workspace that is untitled and not yet saved.
     * 
     * Depending on the workspace that is opened, the value will be:
     *   * `undefined` when no workspace or  a single folder is opened
     *   * the path of the workspace file as `Uri` otherwise. if the workspace
     * is untitled, the returned URI will use the `untitled:` scheme
     * 
     * The location can e.g. be used with the `vscode.openFolder` command to
     * open the workspace again after it has been closed.
     * 
     * **Example:**
     * ```typescript
     * vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
     * ```
     * 
     * **Note:** it is not advised to use `workspace.workspaceFile` to write
     * configuration data into the file. You can use `workspace.getConfiguration().update()`
     * for that purpose which will work both when a single folder is opened as
     * well as an untitled or saved workspace.

     */
    WorkspaceFile?: string

    /**
     * List of workspace folders or `undefined` when no folder is open.
     * *Note* that the first entry corresponds to the value of `rootPath`.

     */
    WorkspaceFolders?: WorkspaceFolder[]
}

function new_WorkspaceProperties () {
    let me: WorkspaceProperties
    me = { populateFrom: _ => WorkspaceProperties_populateFrom.call(me, _) } as WorkspaceProperties
    return me
}

export abstract class impl implements Vscode {
    Window: Window
    Env: Env
    Workspace: Workspace
    Languages: Languages
    Extensions: Extensions
    Commands: Commands
    constructor() {
        this.Window = new implWindow(this)
        this.Env = new implEnv(this)
        this.Workspace = new implWorkspace(this)
        this.Languages = new implLanguages(this)
        this.Extensions = new implExtensions(this)
        this.Commands = new implCommands(this)
    }
}

class implWindow extends implBase implements Window {
    constructor(impl: impl) { super(impl) }
    ShowInformationMessage1(message: string, items: string[], then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showInformationMessage1"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowInformationMessage2(message: string, options: MessageOptions, items: string[], then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showInformationMessage2"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowInformationMessage3(message: string, items: MessageItem[], then?: (_: MessageItem) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showInformationMessage3"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: MessageItem
                if ((undefined !== payload && null !== payload)) {
                    result = new_MessageItem()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowInformationMessage4(message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showInformationMessage4"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: MessageItem
                if ((undefined !== payload && null !== payload)) {
                    result = new_MessageItem()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowWarningMessage1(message: string, items: string[], then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showWarningMessage1"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowWarningMessage2(message: string, options: MessageOptions, items: string[], then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showWarningMessage2"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowWarningMessage3(message: string, items: MessageItem[], then?: (_: MessageItem) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showWarningMessage3"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: MessageItem
                if ((undefined !== payload && null !== payload)) {
                    result = new_MessageItem()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowWarningMessage4(message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showWarningMessage4"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: MessageItem
                if ((undefined !== payload && null !== payload)) {
                    result = new_MessageItem()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowErrorMessage1(message: string, items: string[], then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showErrorMessage1"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowErrorMessage2(message: string, options: MessageOptions, items: string[], then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showErrorMessage2"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowErrorMessage3(message: string, items: MessageItem[], then?: (_: MessageItem) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showErrorMessage3"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: MessageItem
                if ((undefined !== payload && null !== payload)) {
                    result = new_MessageItem()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowErrorMessage4(message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showErrorMessage4"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: MessageItem
                if ((undefined !== payload && null !== payload)) {
                    result = new_MessageItem()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowInputBox(options?: InputBoxOptions, token?: Cancel, then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showInputBox"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if ((undefined !== options && null !== options)) {
            options.ValidateInput_AppzFuncId = ""
            let fn: (_: string) => string
            fn = options.ValidateInput
            if ((undefined !== fn && null !== fn)) {
                {
                    options.ValidateInput_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.ValidateInput_AppzFuncId)
                    this.Impl().cbOther[options.ValidateInput_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if ((1 != args.length)) {
                            return [null,false]
                        } else {
                            let ok: boolean
                            let __0: string
                            if ((undefined !== args[0] && null !== args[0])) {
                                [__0,ok] = [args[0], true]
                                if ((!ok)) {
                                    return [null,false]
                                }
                            }
                            return [fn(__0),true]
                        }                        
                    }
                }
            }
        }
        msg.Data["options"] = options
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if (("" == token.fnId)) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if ((fnids.length != 0)) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return ((undefined === on || null === on) || on(payload))
        })
    }

    ShowQuickPick1(items: string[], options: QuickPickOptions, token?: Cancel, then?: (_: string[]) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showQuickPick1"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if (true) {
            options.OnDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.OnDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.OnDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if ((1 != args.length)) {
                            return [null,false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = new_QuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if ((!ok)) {
                                    return [null,false]
                                }
                            } else {
                                return [null,false]
                            }                            
                            return [fn(__0),true]
                        }                        
                    }
                }
            }
        }
        msg.Data["items"] = items
        options.CanPickMany = true
        msg.Data["options"] = options
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if (("" == token.fnId)) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string[]
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result: any[]
                    [__coll__result,ok] = [payload, false]
                    if ((!ok)) {
                        return false
                    }
                    result = []
                    let __idx__result: number
                    __idx__result = 0
                    for (const __item__result of __coll__result) {
                        let __val__result: string
                        [__val__result,ok] = [__item__result, true]
                        if ((!ok)) {
                            return false
                        }
                        result[__idx__result] = __val__result
                        __idx__result = (__idx__result + 1)
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if ((fnids.length != 0)) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return ((undefined === on || null === on) || on(payload))
        })
    }

    ShowQuickPick2(items: string[], options?: QuickPickOptions, token?: Cancel, then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showQuickPick2"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if ((undefined !== options && null !== options)) {
            options.OnDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.OnDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.OnDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if ((1 != args.length)) {
                            return [null,false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = new_QuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if ((!ok)) {
                                    return [null,false]
                                }
                            } else {
                                return [null,false]
                            }                            
                            return [fn(__0),true]
                        }                        
                    }
                }
            }
        }
        msg.Data["items"] = items
        msg.Data["options"] = options
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if (("" == token.fnId)) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if ((fnids.length != 0)) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return ((undefined === on || null === on) || on(payload))
        })
    }

    ShowQuickPick3(items: QuickPickItem[], options: QuickPickOptions, token?: Cancel, then?: (_: QuickPickItem[]) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showQuickPick3"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if (true) {
            options.OnDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.OnDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.OnDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if ((1 != args.length)) {
                            return [null,false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = new_QuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if ((!ok)) {
                                    return [null,false]
                                }
                            } else {
                                return [null,false]
                            }                            
                            return [fn(__0),true]
                        }                        
                    }
                }
            }
        }
        msg.Data["items"] = items
        options.CanPickMany = true
        msg.Data["options"] = options
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if (("" == token.fnId)) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: QuickPickItem[]
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result: any[]
                    [__coll__result,ok] = [payload, false]
                    if ((!ok)) {
                        return false
                    }
                    result = []
                    let __idx__result: number
                    __idx__result = 0
                    for (const __item__result of __coll__result) {
                        let __val__result: QuickPickItem
                        __val__result = new_QuickPickItem()
                        ok = __val__result.populateFrom(__item__result)
                        if ((!ok)) {
                            return false
                        }
                        result[__idx__result] = __val__result
                        __idx__result = (__idx__result + 1)
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if ((fnids.length != 0)) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return ((undefined === on || null === on) || on(payload))
        })
    }

    ShowQuickPick4(items: QuickPickItem[], options?: QuickPickOptions, token?: Cancel, then?: (_: QuickPickItem) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showQuickPick4"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if ((undefined !== options && null !== options)) {
            options.OnDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.OnDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.OnDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.OnDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.OnDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if ((1 != args.length)) {
                            return [null,false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = new_QuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if ((!ok)) {
                                    return [null,false]
                                }
                            } else {
                                return [null,false]
                            }                            
                            return [fn(__0),true]
                        }                        
                    }
                }
            }
        }
        msg.Data["items"] = items
        msg.Data["options"] = options
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if (("" == token.fnId)) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: QuickPickItem
                if ((undefined !== payload && null !== payload)) {
                    result = new_QuickPickItem()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if ((fnids.length != 0)) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return ((undefined === on || null === on) || on(payload))
        })
    }

    SetStatusBarMessage1(text: string, hideAfterTimeout: number, then?: (_: Disposable) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.setStatusBarMessage1"
        msg.Data = {}
        msg.Data["text"] = text
        msg.Data["hideAfterTimeout"] = hideAfterTimeout
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: Disposable
                if ((undefined !== payload && null !== payload)) {
                    result = new_Disposable()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result.bind(this.Impl(), ""))
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    SetStatusBarMessage2(text: string, then?: (_: Disposable) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.setStatusBarMessage2"
        msg.Data = {}
        msg.Data["text"] = text
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: Disposable
                if ((undefined !== payload && null !== payload)) {
                    result = new_Disposable()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result.bind(this.Impl(), ""))
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowSaveDialog(options: SaveDialogOptions, then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showSaveDialog"
        msg.Data = {}
        msg.Data["options"] = options
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowOpenDialog(options: OpenDialogOptions, then?: (_: string[]) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showOpenDialog"
        msg.Data = {}
        msg.Data["options"] = options
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string[]
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result: any[]
                    [__coll__result,ok] = [payload, false]
                    if ((!ok)) {
                        return false
                    }
                    result = []
                    let __idx__result: number
                    __idx__result = 0
                    for (const __item__result of __coll__result) {
                        let __val__result: string
                        [__val__result,ok] = [__item__result, true]
                        if ((!ok)) {
                            return false
                        }
                        result[__idx__result] = __val__result
                        __idx__result = (__idx__result + 1)
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    ShowWorkspaceFolderPick(options?: WorkspaceFolderPickOptions, then?: (_: WorkspaceFolder) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.showWorkspaceFolderPick"
        msg.Data = {}
        msg.Data["options"] = options
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: WorkspaceFolder
                if ((undefined !== payload && null !== payload)) {
                    result = new_WorkspaceFolder()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    State(then?: (_: WindowState) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.state"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: WindowState
                if ((undefined !== payload && null !== payload)) {
                    result = new_WindowState()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    OnDidChangeWindowState(listener: (_: WindowState) => void, then?: (_: Disposable) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "window.onDidChangeWindowState"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return 
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if ((1 != args.length)) {
                return ok
            }
            let _a_0_: WindowState
            _a_0_ = new_WindowState()
            ok = _a_0_.populateFrom(args[0])
            if ((!ok)) {
                return false
            }
            listener(_a_0_)
            return true
        })
        msg.Data["listener"] = _fnid_listener
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: Disposable
                if ((undefined !== payload && null !== payload)) {
                    result = new_Disposable()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result.bind(this.Impl(), _fnid_listener))
                return true
            }
        }
        this.Impl().send(msg, on)
    }

}

class implEnv extends implBase implements Env {
    constructor(impl: impl) { super(impl) }
    OpenExternal(target: string, then?: (_: boolean) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.openExternal"
        msg.Data = {}
        msg.Data["target"] = target
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: boolean
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    AppName(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.appName"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    AppRoot(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.appRoot"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    Language(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.language"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    MachineId(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.machineId"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    RemoteName(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.remoteName"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    SessionId(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.sessionId"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    Shell(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.shell"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    UriScheme(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.uriScheme"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    Properties(then: (_: EnvProperties) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "env.Properties"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: EnvProperties
                if ((undefined !== payload && null !== payload)) {
                    result = new_EnvProperties()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

}

class implWorkspace extends implBase implements Workspace {
    constructor(impl: impl) { super(impl) }
    Name(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.name"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    WorkspaceFile(then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.workspaceFile"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    SaveAll(includeUntitled: boolean, then?: (_: boolean) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.saveAll"
        msg.Data = {}
        msg.Data["includeUntitled"] = includeUntitled
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: boolean
                if ((undefined !== payload && null !== payload)) {
                    [result,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    OnDidChangeWorkspaceFolders(listener: (_: WorkspaceFoldersChangeEvent) => void, then?: (_: Disposable) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.onDidChangeWorkspaceFolders"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Workspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return 
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if ((1 != args.length)) {
                return ok
            }
            let _a_0_: WorkspaceFoldersChangeEvent
            _a_0_ = new_WorkspaceFoldersChangeEvent()
            ok = _a_0_.populateFrom(args[0])
            if ((!ok)) {
                return false
            }
            listener(_a_0_)
            return true
        })
        msg.Data["listener"] = _fnid_listener
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: Disposable
                if ((undefined !== payload && null !== payload)) {
                    result = new_Disposable()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result.bind(this.Impl(), _fnid_listener))
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    GetWorkspaceFolder(uri: string, then?: (_: WorkspaceFolder) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.getWorkspaceFolder"
        msg.Data = {}
        msg.Data["uri"] = uri
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: WorkspaceFolder
                if ((undefined !== payload && null !== payload)) {
                    result = new_WorkspaceFolder()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    WorkspaceFolders(then?: (_: WorkspaceFolder[]) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.workspaceFolders"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: WorkspaceFolder[]
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result: any[]
                    [__coll__result,ok] = [payload, false]
                    if ((!ok)) {
                        return false
                    }
                    result = []
                    let __idx__result: number
                    __idx__result = 0
                    for (const __item__result of __coll__result) {
                        let __val__result: WorkspaceFolder
                        __val__result = new_WorkspaceFolder()
                        ok = __val__result.populateFrom(__item__result)
                        if ((!ok)) {
                            return false
                        }
                        result[__idx__result] = __val__result
                        __idx__result = (__idx__result + 1)
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    FindFiles(include: string, exclude?: string, maxResults?: number, token?: Cancel, then?: (_: string[]) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.findFiles"
        msg.Data = {}
        msg.Data["include"] = include
        msg.Data["exclude"] = exclude
        msg.Data["maxResults"] = maxResults
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if (("" == token.fnId)) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string[]
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result: any[]
                    [__coll__result,ok] = [payload, false]
                    if ((!ok)) {
                        return false
                    }
                    result = []
                    let __idx__result: number
                    __idx__result = 0
                    for (const __item__result of __coll__result) {
                        let __val__result: string
                        [__val__result,ok] = [__item__result, true]
                        if ((!ok)) {
                            return false
                        }
                        result[__idx__result] = __val__result
                        __idx__result = (__idx__result + 1)
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    AsRelativePath(pathOrUri: string, includeWorkspaceFolder: boolean, then?: (_: string) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.asRelativePath"
        msg.Data = {}
        msg.Data["pathOrUri"] = pathOrUri
        msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string
                if ((undefined !== payload && null !== payload)) {
                    let _result_: string
                    [_result_,ok] = [payload, true]
                    if ((!ok)) {
                        return false
                    }
                    result = _result_
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    Properties(then: (_: WorkspaceProperties) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "workspace.Properties"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: WorkspaceProperties
                if ((undefined !== payload && null !== payload)) {
                    result = new_WorkspaceProperties()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

}

class implLanguages extends implBase implements Languages {
    constructor(impl: impl) { super(impl) }
    GetLanguages(then?: (_: string[]) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "languages.getLanguages"
        msg.Data = {}
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string[]
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result: any[]
                    [__coll__result,ok] = [payload, false]
                    if ((!ok)) {
                        return false
                    }
                    result = []
                    let __idx__result: number
                    __idx__result = 0
                    for (const __item__result of __coll__result) {
                        let __val__result: string
                        [__val__result,ok] = [__item__result, true]
                        if ((!ok)) {
                            return false
                        }
                        result[__idx__result] = __val__result
                        __idx__result = (__idx__result + 1)
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

    OnDidChangeDiagnostics(listener: (_: DiagnosticChangeEvent) => void, then?: (_: Disposable) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "languages.onDidChangeDiagnostics"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Languages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return 
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if ((1 != args.length)) {
                return ok
            }
            let _a_0_: DiagnosticChangeEvent
            _a_0_ = new_DiagnosticChangeEvent()
            ok = _a_0_.populateFrom(args[0])
            if ((!ok)) {
                return false
            }
            listener(_a_0_)
            return true
        })
        msg.Data["listener"] = _fnid_listener
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: Disposable
                if ((undefined !== payload && null !== payload)) {
                    result = new_Disposable()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result.bind(this.Impl(), _fnid_listener))
                return true
            }
        }
        this.Impl().send(msg, on)
    }

}

class implExtensions extends implBase implements Extensions {
    constructor(impl: impl) { super(impl) }
    OnDidChange(listener: () => void, then?: (_: Disposable) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "extensions.onDidChange"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Extensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return 
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if ((0 != args.length)) {
                return ok
            }
            listener()
            return true
        })
        msg.Data["listener"] = _fnid_listener
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: Disposable
                if ((undefined !== payload && null !== payload)) {
                    result = new_Disposable()
                    ok = result.populateFrom(payload)
                    if ((!ok)) {
                        return false
                    }
                } else {
                    return false
                }                
                then(result.bind(this.Impl(), _fnid_listener))
                return true
            }
        }
        this.Impl().send(msg, on)
    }

}

class implCommands extends implBase implements Commands {
    constructor(impl: impl) { super(impl) }
    GetCommands(filterInternal: boolean, then?: (_: string[]) => void): void {
        let msg: ipcMsg
        msg = new_ipcMsg()
        msg.QName = "commands.getCommands"
        msg.Data = {}
        msg.Data["filterInternal"] = filterInternal
        let on: (_: any) => boolean
        if ((undefined !== then && null !== then)) {
            on = (payload: any): boolean => {
                let ok: boolean
                let result: string[]
                if ((undefined !== payload && null !== payload)) {
                    let __coll__result: any[]
                    [__coll__result,ok] = [payload, false]
                    if ((!ok)) {
                        return false
                    }
                    result = []
                    let __idx__result: number
                    __idx__result = 0
                    for (const __item__result of __coll__result) {
                        let __val__result: string
                        [__val__result,ok] = [__item__result, true]
                        if ((!ok)) {
                            return false
                        }
                        result[__idx__result] = __val__result
                        __idx__result = (__idx__result + 1)
                    }
                }
                then(result)
                return true
            }
        }
        this.Impl().send(msg, on)
    }

}

function MessageItem_populateFrom(this: MessageItem, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["title"]
    if (ok) {
        let title: string
        if ((undefined !== val && null !== val)) {
            [title,ok] = [val, true]
            if ((!ok)) {
                return false
            }
        }
        this.Title = title
    } else {
        return false
    }    
    [val,ok] = it["isCloseAffordance"]
    if (ok) {
        let isCloseAffordance: boolean
        if ((undefined !== val && null !== val)) {
            let _isCloseAffordance_: boolean
            [_isCloseAffordance_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            isCloseAffordance = _isCloseAffordance_
        }
        this.IsCloseAffordance = isCloseAffordance
    }
    [val,ok] = it["my"]
    if (ok) {
        let my: { [_: string]: any}
        if ((undefined !== val && null !== val)) {
            [my,ok] = [val, true]
            if ((!ok)) {
                return false
            }
        }
        this.My = my
    }
    return true
}

function QuickPickItem_populateFrom(this: QuickPickItem, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["label"]
    if (ok) {
        let label: string
        if ((undefined !== val && null !== val)) {
            [label,ok] = [val, true]
            if ((!ok)) {
                return false
            }
        }
        this.Label = label
    } else {
        return false
    }    
    [val,ok] = it["description"]
    if (ok) {
        let description: string
        if ((undefined !== val && null !== val)) {
            let _description_: string
            [_description_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            description = _description_
        }
        this.Description = description
    }
    [val,ok] = it["detail"]
    if (ok) {
        let detail: string
        if ((undefined !== val && null !== val)) {
            let _detail_: string
            [_detail_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            detail = _detail_
        }
        this.Detail = detail
    }
    [val,ok] = it["picked"]
    if (ok) {
        let picked: boolean
        if ((undefined !== val && null !== val)) {
            let _picked_: boolean
            [_picked_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            picked = _picked_
        }
        this.Picked = picked
    }
    [val,ok] = it["alwaysShow"]
    if (ok) {
        let alwaysShow: boolean
        if ((undefined !== val && null !== val)) {
            let _alwaysShow_: boolean
            [_alwaysShow_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            alwaysShow = _alwaysShow_
        }
        this.AlwaysShow = alwaysShow
    }
    [val,ok] = it["my"]
    if (ok) {
        let my: { [_: string]: any}
        if ((undefined !== val && null !== val)) {
            [my,ok] = [val, true]
            if ((!ok)) {
                return false
            }
        }
        this.My = my
    }
    return true
}

function WorkspaceFolder_populateFrom(this: WorkspaceFolder, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["uri"]
    if (ok) {
        let uri: string
        if ((undefined !== val && null !== val)) {
            [uri,ok] = [val, true]
            if ((!ok)) {
                return false
            }
        }
        this.Uri = uri
    } else {
        return false
    }    
    [val,ok] = it["name"]
    if (ok) {
        let name: string
        if ((undefined !== val && null !== val)) {
            [name,ok] = [val, true]
            if ((!ok)) {
                return false
            }
        }
        this.Name = name
    } else {
        return false
    }    
    [val,ok] = it["index"]
    if (ok) {
        let index: number
        if ((undefined !== val && null !== val)) {
            [index,ok] = [val, true]
            if ((!ok)) {
                let __index__: number
                [__index__,ok] = [val, true]
                if ((!ok)) {
                    return false
                }
                index = [__index__, true]
            }
        }
        this.Index = index
    } else {
        return false
    }    
    return true
}

function WindowState_populateFrom(this: WindowState, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["focused"]
    if (ok) {
        let focused: boolean
        if ((undefined !== val && null !== val)) {
            [focused,ok] = [val, true]
            if ((!ok)) {
                return false
            }
        }
        this.Focused = focused
    } else {
        return false
    }    
    return true
}

function EnvProperties_populateFrom(this: EnvProperties, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["appName"]
    if (ok) {
        let appName: string
        if ((undefined !== val && null !== val)) {
            let _appName_: string
            [_appName_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            appName = _appName_
        }
        this.AppName = appName
    }
    [val,ok] = it["appRoot"]
    if (ok) {
        let appRoot: string
        if ((undefined !== val && null !== val)) {
            let _appRoot_: string
            [_appRoot_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            appRoot = _appRoot_
        }
        this.AppRoot = appRoot
    }
    [val,ok] = it["language"]
    if (ok) {
        let language: string
        if ((undefined !== val && null !== val)) {
            let _language_: string
            [_language_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            language = _language_
        }
        this.Language = language
    }
    [val,ok] = it["machineId"]
    if (ok) {
        let machineId: string
        if ((undefined !== val && null !== val)) {
            let _machineId_: string
            [_machineId_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            machineId = _machineId_
        }
        this.MachineId = machineId
    }
    [val,ok] = it["remoteName"]
    if (ok) {
        let remoteName: string
        if ((undefined !== val && null !== val)) {
            let _remoteName_: string
            [_remoteName_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            remoteName = _remoteName_
        }
        this.RemoteName = remoteName
    }
    [val,ok] = it["sessionId"]
    if (ok) {
        let sessionId: string
        if ((undefined !== val && null !== val)) {
            let _sessionId_: string
            [_sessionId_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            sessionId = _sessionId_
        }
        this.SessionId = sessionId
    }
    [val,ok] = it["shell"]
    if (ok) {
        let shell: string
        if ((undefined !== val && null !== val)) {
            let _shell_: string
            [_shell_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            shell = _shell_
        }
        this.Shell = shell
    }
    [val,ok] = it["uriScheme"]
    if (ok) {
        let uriScheme: string
        if ((undefined !== val && null !== val)) {
            let _uriScheme_: string
            [_uriScheme_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            uriScheme = _uriScheme_
        }
        this.UriScheme = uriScheme
    }
    return true
}

function WorkspaceFoldersChangeEvent_populateFrom(this: WorkspaceFoldersChangeEvent, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["added"]
    if (ok) {
        let added: WorkspaceFolder[]
        if ((undefined !== val && null !== val)) {
            let __coll__added: any[]
            [__coll__added,ok] = [val, false]
            if ((!ok)) {
                return false
            }
            added = []
            let __idx__added: number
            __idx__added = 0
            for (const __item__added of __coll__added) {
                let __val__added: WorkspaceFolder
                __val__added = new_WorkspaceFolder()
                ok = __val__added.populateFrom(__item__added)
                if ((!ok)) {
                    return false
                }
                added[__idx__added] = __val__added
                __idx__added = (__idx__added + 1)
            }
        }
        this.Added = added
    } else {
        return false
    }    
    [val,ok] = it["removed"]
    if (ok) {
        let removed: WorkspaceFolder[]
        if ((undefined !== val && null !== val)) {
            let __coll__removed: any[]
            [__coll__removed,ok] = [val, false]
            if ((!ok)) {
                return false
            }
            removed = []
            let __idx__removed: number
            __idx__removed = 0
            for (const __item__removed of __coll__removed) {
                let __val__removed: WorkspaceFolder
                __val__removed = new_WorkspaceFolder()
                ok = __val__removed.populateFrom(__item__removed)
                if ((!ok)) {
                    return false
                }
                removed[__idx__removed] = __val__removed
                __idx__removed = (__idx__removed + 1)
            }
        }
        this.Removed = removed
    } else {
        return false
    }    
    return true
}

function WorkspaceProperties_populateFrom(this: WorkspaceProperties, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["name"]
    if (ok) {
        let name: string
        if ((undefined !== val && null !== val)) {
            let _name_: string
            [_name_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            name = _name_
        }
        this.Name = name
    }
    [val,ok] = it["workspaceFile"]
    if (ok) {
        let workspaceFile: string
        if ((undefined !== val && null !== val)) {
            let _workspaceFile_: string
            [_workspaceFile_,ok] = [val, true]
            if ((!ok)) {
                return false
            }
            workspaceFile = _workspaceFile_
        }
        this.WorkspaceFile = workspaceFile
    }
    [val,ok] = it["workspaceFolders"]
    if (ok) {
        let workspaceFolders: WorkspaceFolder[]
        if ((undefined !== val && null !== val)) {
            let __coll__workspaceFolders: any[]
            [__coll__workspaceFolders,ok] = [val, false]
            if ((!ok)) {
                return false
            }
            workspaceFolders = []
            let __idx__workspaceFolders: number
            __idx__workspaceFolders = 0
            for (const __item__workspaceFolders of __coll__workspaceFolders) {
                let __val__workspaceFolders: WorkspaceFolder
                __val__workspaceFolders = new_WorkspaceFolder()
                ok = __val__workspaceFolders.populateFrom(__item__workspaceFolders)
                if ((!ok)) {
                    return false
                }
                workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders
                __idx__workspaceFolders = (__idx__workspaceFolders + 1)
            }
        }
        this.WorkspaceFolders = workspaceFolders
    }
    return true
}

function DiagnosticChangeEvent_populateFrom(this: DiagnosticChangeEvent, payload: any): boolean {
    let it: { [_: string]: any}
    let ok: boolean
    let val: any
    [it,ok] = [payload, true]
    if ((!ok)) {
        return false
    }
    [val,ok] = it["uris"]
    if (ok) {
        let uris: string[]
        if ((undefined !== val && null !== val)) {
            let __coll__uris: any[]
            [__coll__uris,ok] = [val, false]
            if ((!ok)) {
                return false
            }
            uris = []
            let __idx__uris: number
            __idx__uris = 0
            for (const __item__uris of __coll__uris) {
                let __val__uris: string
                [__val__uris,ok] = [__item__uris, true]
                if ((!ok)) {
                    return false
                }
                uris[__idx__uris] = __val__uris
                __idx__uris = (__idx__uris + 1)
            }
        }
        this.Uris = uris
    } else {
        return false
    }    
    return true
}

