// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-nodejs.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
import * as core from './core'
import { OnError } from './vsc-appz'
type ipcMsg = core.ipcMsg
type Cancel = core.Cancel
type Disposable = core.Disposable
interface fromJson { populateFrom: (_: any) => boolean }
interface withDisp { disp: Disposable }

abstract class implBase {
    impl: impl
    constructor(impl: impl) { this.impl = impl }
    Impl() { return this.impl as any as core.impl /* crikey, codegen life.. */ }
}

function newipcMsg() { return new core.ipcMsg() }
function newDisposable() { return new core.Disposable() }

/**
 * Represents the alignment of status bar items.

 */
export enum StatusBarAlignment {
    /**
     * Aligned to the left side.

     */
    Left = 1,

    /**
     * Aligned to the right side.

     */
    Right = 2,
}

/**
 * Describes the behavior of decorations when typing/editing at their edges.

 */
export enum DecorationRangeBehavior {
    /**
     * The decoration's range will widen when edits occur at the start or end.

     */
    OpenOpen = 0,

    /**
     * The decoration's range will not widen when edits occur at the start of end.

     */
    ClosedClosed = 1,

    /**
     * The decoration's range will widen when edits occur at the start, but not at the end.

     */
    OpenClosed = 2,

    /**
     * The decoration's range will widen when edits occur at the end, but not at the start.

     */
    ClosedOpen = 3,
}

/**
 * Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
 * The overview ruler supports three lanes.

 */
export enum OverviewRulerLane {
    /**
     * Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
     * The overview ruler supports three lanes.

     */
    Left = 1,

    /**
     * Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
     * The overview ruler supports three lanes.

     */
    Center = 2,

    /**
     * Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
     * The overview ruler supports three lanes.

     */
    Right = 4,

    /**
     * Represents different positions for rendering a decoration in an [overview ruler](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions.overviewRulerLane).
     * The overview ruler supports three lanes.

     */
    Full = 7,
}

/**
 * Type Definition for Visual Studio Code 1.39 Extension API
 * See https://code.visualstudio.com/api for more information

 */
export interface Vscode {
    /**
     * Namespace for dealing with the current window of the editor. That is visible
     * and active editors, as well as, UI elements to show messages, selections, and
     * asking for user input.

     */
    Window: Window

    /**
     * Namespace describing the environment the editor runs in.

     */
    Env: Env

    /**
     * Namespace for dealing with the current workspace. A workspace is the representation
     * of the folder that has been opened. There is no workspace when just a file but not a
     * folder has been opened.
     * 
     * The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
     * events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
     * the editor-process so that they should be always used instead of nodejs-equivalents.

     */
    Workspace: Workspace

    /**
     * Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
     * like IntelliSense, code actions, diagnostics etc.
     * 
     * Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
     * like automatic word-completion, code navigation, or code checking have become popular across different tools for different
     * programming languages.
     * 
     * The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
     * by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
     * that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
     * mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
     * 
     * 
     * ```javascript
     * 
     * languages.registerHoverProvider('javascript', {
     *  	provideHover(document, position, token) {
     *  		return new Hover('I am a hover!');
     *  	}
     * });
     * 
     * ```
     * 
     * 
     * Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
     * a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
     * a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
     * scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
     * the score is only checked to be `>0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
     * score is used for determining the order in which providers are asked to participate.

     */
    Languages: Languages

    /**
     * Namespace for dealing with installed extensions. Extensions are represented
     * by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
     * 
     * Extension writers can provide APIs to other extensions by returning their API public
     * surface from the `activate`-call.
     * 
     * 
     * ```javascript
     * 
     * export function activate(context: vscode.ExtensionContext) {
     *  	let api = {
     *  		sum(a, b) {
     *  			return a + b;
     *  		},
     *  		mul(a, b) {
     *  			return a * b;
     *  		}
     *  	};
     *  	// 'export' public api-surface
     *  	return api;
     * }
     * 
     * ```
     * 
     * When depending on the API of another extension add an `extensionDependency`-entry
     * to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
     * and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
     * 
     * 
     * ```javascript
     * 
     * let mathExt = extensions.getExtension('genius.math');
     * let importedApi = mathExt.exports;
     * 
     * console.log(importedApi.mul(42, 1));
     * 
     * ```
     * 

     */
    Extensions: Extensions

    /**
     * Namespace for dealing with commands. In short, a command is a function with a
     * unique identifier. The function is sometimes also called _command handler_.
     * 
     * Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
     * and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
     * can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
     * 
     * * palette - Use the `commands`-section in `package.json` to make a command show in
     * the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
     * * keybinding - Use the `keybindings`-section in `package.json` to enable
     * [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
     * for your extension.
     * 
     * Commands from other extensions and from the editor itself are accessible to an extension. However,
     * when invoking an editor command not all argument types are supported.
     * 
     * This is a sample that registers a command handler and adds an entry for that command to the palette. First
     * register a command handler with the identifier `extension.sayHello`.
     * 
     * ```javascript
     * 
     * commands.registerCommand('extension.sayHello', () => {
     *  	window.showInformationMessage('Hello World!');
     * });
     * 
     * ```
     * 
     * Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
     * 
     * ```json
     * 
     * {
     *  	"contributes": {
     *  		"commands": [{
     *  			"command": "extension.sayHello",
     *  			"title": "Hello World"
     *  		}]
     *  	}
     * }
     * 
     * ```
     * 

     */
    Commands: Commands
}

/**
 * Namespace for dealing with the current window of the editor. That is visible
 * and active editors, as well as, UI elements to show messages, selections, and
 * asking for user input.

 */
export interface Window {
    /**
     * Show an information message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage1: (message: string, items: string[]) => (_: (_: string) => void) => void

    /**
     * Show an information message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage2: (message: string, options: MessageOptions, items: string[]) => (_: (_: string) => void) => void

    /**
     * Show an information message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage3: (message: string, items: MessageItem[]) => (_: (_: MessageItem) => void) => void

    /**
     * Show an information message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage4: (message: string, options: MessageOptions, items: MessageItem[]) => (_: (_: MessageItem) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage1: (message: string, items: string[]) => (_: (_: string) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage2: (message: string, options: MessageOptions, items: string[]) => (_: (_: string) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage3: (message: string, items: MessageItem[]) => (_: (_: MessageItem) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage4: (message: string, options: MessageOptions, items: MessageItem[]) => (_: (_: MessageItem) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage1: (message: string, items: string[]) => (_: (_: string) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage2: (message: string, options: MessageOptions, items: string[]) => (_: (_: string) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage3: (message: string, items: MessageItem[]) => (_: (_: MessageItem) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @return A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage4: (message: string, options: MessageOptions, items: MessageItem[]) => (_: (_: MessageItem) => void) => void

    /**
     * Opens an input box to ask the user for input.
     * 
     * The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
     * returned value will be the string typed by the user or an empty string if the user did not type
     * anything but dismissed the input box with OK.

     * @param options Configures the behavior of the input box.
     * @param token A token that can be used to signal cancellation.
     * @return A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
     */
    ShowInputBox: (options?: InputBoxOptions, token?: Cancel) => (_: (_: string) => void) => void

    /**
     * Shows a selection list allowing multiple selections.

     * @param items An array of strings, or a promise that resolves to an array of strings.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @return A promise that resolves to the selected items or `undefined`.
     */
    ShowQuickPick1: (items: string[], options: QuickPickOptions, token?: Cancel) => (_: (_: string[]) => void) => void

    /**
     * Shows a selection list.

     * @param items An array of strings, or a promise that resolves to an array of strings.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @return A promise that resolves to the selection or `undefined`.
     */
    ShowQuickPick2: (items: string[], options?: QuickPickOptions, token?: Cancel) => (_: (_: string) => void) => void

    /**
     * Shows a selection list allowing multiple selections.

     * @param items An array of items, or a promise that resolves to an array of items.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @return A promise that resolves to the selected items or `undefined`.
     */
    ShowQuickPick3: (items: QuickPickItem[], options: QuickPickOptions, token?: Cancel) => (_: (_: QuickPickItem[]) => void) => void

    /**
     * Shows a selection list.

     * @param items An array of items, or a promise that resolves to an array of items.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @return A promise that resolves to the selected item or `undefined`.
     */
    ShowQuickPick4: (items: QuickPickItem[], options?: QuickPickOptions, token?: Cancel) => (_: (_: QuickPickItem) => void) => void

    /**
     * Set a message to the status bar. This is a short hand for the more powerful
     * status bar [items](https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem).

     * @param text The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).
     * @param hideAfterTimeout Timeout in milliseconds after which the message will be disposed.
     * @return A disposable which hides the status bar message.
     */
    SetStatusBarMessage1: (text: string, hideAfterTimeout: number) => (_: (_: Disposable) => void) => void

    /**
     * Set a message to the status bar. This is a short hand for the more powerful
     * status bar [items](https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem).
     * 
     * *Note* that status bar messages stack and that they must be disposed when no
     * longer used.

     * @param text The message to show, supports icon substitution as in status bar [items](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.text).
     * @return A disposable which hides the status bar message.
     */
    SetStatusBarMessage2: (text: string) => (_: (_: Disposable) => void) => void

    /**
     * Shows a file save dialog to the user which allows to select a file
     * for saving-purposes.

     * @param options Options that control the dialog.
     * @return A promise that resolves to the selected resource or `undefined`.
     */
    ShowSaveDialog: (options: SaveDialogOptions) => (_: (_: string) => void) => void

    /**
     * Shows a file open dialog to the user which allows to select a file
     * for opening-purposes.

     * @param options Options that control the dialog.
     * @return A promise that resolves to the selected resources or `undefined`.
     */
    ShowOpenDialog: (options: OpenDialogOptions) => (_: (_: string[]) => void) => void

    /**
     * Shows a selection list of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) to pick from.
     * Returns `undefined` if no folder is open.

     * @param options Configures the behavior of the workspace folder list.
     * @return A promise that resolves to the workspace folder or `undefined`.
     */
    ShowWorkspaceFolderPick: (options?: WorkspaceFolderPickOptions) => (_: (_: WorkspaceFolder) => void) => void

    /**
     * Represents the current window's state.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    State: (_: (_: WindowState) => void) => void

    /**
     * An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the focus state of the current window
     * changes. The value of the event represents whether the window is focused.

     * @param listener will be invoked whenever this event fires; mandatory, not optional.
     * @return A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWindowState` event on `Dispose`.
     */
    OnDidChangeWindowState: (listener: (_: WindowState) => void) => (_: (_: Disposable) => void) => void

    /**
     * Creates a status bar [item](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem).

     * @param alignment The alignment of the item.
     * @param priority The priority of the item. Higher values mean the item should be shown more to the left.
     * @return A new status bar item.
     * @param optionallyInitialStateToApplyUponCreation ff specified, the newly created `StatusBarItem` will be initialized with all the property values herein well before your return-continuation, if any, is invoked.
     */
    CreateStatusBarItem: (alignment?: StatusBarAlignment, priority?: number, optionallyInitialStateToApplyUponCreation?: StatusBarItemState) => (_: (_: StatusBarItem, __: StatusBarItemState) => void) => void

    /**
     * Creates a new [output channel](https://code.visualstudio.com/api/references/vscode-api#OutputChannel) with the given name.

     * @param name Human-readable string which will be used to represent the channel in the UI.
     * @return A thenable that resolves when the `OutputChannel` has been created and initialized.
     */
    CreateOutputChannel: (name: string) => (_: (_: OutputChannel, __: OutputChannelState) => void) => void

    /**
     * Create a TextEditorDecorationType that can be used to add decorations to text editors.

     * @param options Rendering options for the decoration type.
     * @return A new decoration type instance.
     */
    CreateTextEditorDecorationType: (options: DecorationRenderOptions) => (_: (_: TextEditorDecorationType, __: TextEditorDecorationTypeState) => void) => void

    /**
     * Creates a [InputBox](https://code.visualstudio.com/api/references/vscode-api#InputBox) to let the user enter some text input.
     * 
     * Note that in many cases the more convenient [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox)
     * is easier to use. [window.createInputBox](https://code.visualstudio.com/api/references/vscode-api#window.createInputBox) should be used
     * when [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox) does not offer the required flexibility.

     * @return A new [InputBox](https://code.visualstudio.com/api/references/vscode-api#InputBox).
     * @param optionallyInitialStateToApplyUponCreation ff specified, the newly created `InputBox` will be initialized with all the property values herein well before your return-continuation, if any, is invoked.
     */
    CreateInputBox: (optionallyInitialStateToApplyUponCreation?: InputBoxState) => (_: (_: InputBox, __: InputBoxState) => void) => void

    /**
     * Creates a [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick) to let the user pick an item from a list
     * of items of type T.
     * 
     * Note that in many cases the more convenient [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick)
     * is easier to use. [window.createQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.createQuickPick) should be used
     * when [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick) does not offer the required flexibility.

     * @return A new [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick).
     * @param optionallyInitialStateToApplyUponCreation ff specified, the newly created `QuickPick` will be initialized with all the property values herein well before your return-continuation, if any, is invoked.
     */
    CreateQuickPick: (optionallyInitialStateToApplyUponCreation?: QuickPickState) => (_: (_: QuickPick, __: QuickPickState) => void) => void
}

/**
 * Namespace describing the environment the editor runs in.

 */
export interface Env {
    /**
     * Opens an *external* item, e.g. a http(s) or mailto-link, using the
     * default application.
     * 
     * *Note* that [`showTextDocument`](https://code.visualstudio.com/api/references/vscode-api#window.showTextDocument) is the right
     * way to open a text document inside the editor, not this function.

     * @param target The uri that should be opened.
     * @return A promise indicating if open was successful.
     */
    OpenExternal: (target: string) => (_: (_: boolean) => void) => void

    /**
     * The application name of the editor, like 'VS Code'.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    AppName: (_: (_: string) => void) => void

    /**
     * The application root folder from which the editor is running.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    AppRoot: (_: (_: string) => void) => void

    /**
     * Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    Language: (_: (_: string) => void) => void

    /**
     * A unique identifier for the computer.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    MachineId: (_: (_: string) => void) => void

    /**
     * The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
     * Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
     * 
     * *Note* that the value is `undefined` when there is no remote extension host but that the
     * value is defined in all extension hosts (local and remote) in case a remote extension host
     * exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
     * a specific extension runs remote or not.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    RemoteName: (_: (_: string) => void) => void

    /**
     * A unique identifier for the current session.
     * Changes each time the editor is started.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    SessionId: (_: (_: string) => void) => void

    /**
     * The detected default shell for the extension host, this is overridden by the
     * `terminal.integrated.shell` setting for the extension host's platform.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    Shell: (_: (_: string) => void) => void

    /**
     * The custom uri scheme the editor registers to in the operating system.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    UriScheme: (_: (_: string) => void) => void

    /**
     * Provides single-call access to numerous individual `Env` properties at once.

     */
    Properties: (_: (_: EnvProperties) => void) => void

    /**
     * The clipboard provides read and write access to the system's clipboard.

     */
    Clipboard: () => Clipboard
}

/**
 * The clipboard provides read and write access to the system's clipboard.

 */
export interface Clipboard {
    /**
     * Read the current clipboard contents as text.

     * @return A thenable that resolves to a string.
     */
    ReadText: (_: (_: string) => void) => void

    /**
     * Writes text into the clipboard.

     * @return A thenable that resolves when writing happened.
     * @param value 
     */
    WriteText: (value: string) => (_: () => void) => void
}

/**
 * Namespace for dealing with the current workspace. A workspace is the representation
 * of the folder that has been opened. There is no workspace when just a file but not a
 * folder has been opened.
 * 
 * The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
 * events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
 * the editor-process so that they should be always used instead of nodejs-equivalents.

 */
export interface Workspace {
    /**
     * The name of the workspace. `undefined` when no folder
     * has been opened.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    Name: (_: (_: string) => void) => void

    /**
     * The location of the workspace file, for example:
     * 
     * `file:///Users/name/Development/myProject.code-workspace`
     * 
     * or
     * 
     * `untitled:1555503116870`
     * 
     * for a workspace that is untitled and not yet saved.
     * 
     * Depending on the workspace that is opened, the value will be:
     *   * `undefined` when no workspace or  a single folder is opened
     *   * the path of the workspace file as `Uri` otherwise. if the workspace
     * is untitled, the returned URI will use the `untitled:` scheme
     * 
     * The location can e.g. be used with the `vscode.openFolder` command to
     * open the workspace again after it has been closed.
     * 
     * **Example:**
     * 
     * ```typescript
     * 
     * vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
     * 
     * ```
     * 
     * 
     * **Note:** it is not advised to use `workspace.workspaceFile` to write
     * configuration data into the file. You can use `workspace.getConfiguration().update()`
     * for that purpose which will work both when a single folder is opened as
     * well as an untitled or saved workspace.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    WorkspaceFile: (_: (_: string) => void) => void

    /**
     * Save all dirty files.

     * @param includeUntitled Also save files that have been created during this session.
     * @return A thenable that resolves when the files have been saved.
     */
    SaveAll: (includeUntitled: boolean) => (_: (_: boolean) => void) => void

    /**
     * An event that is emitted when a workspace folder is added or removed.

     * @param listener will be invoked whenever this event fires; mandatory, not optional.
     * @return A `Disposable` that will unsubscribe `listener` from the `OnDidChangeWorkspaceFolders` event on `Dispose`.
     */
    OnDidChangeWorkspaceFolders: (listener: (_: WorkspaceFoldersChangeEvent) => void) => (_: (_: Disposable) => void) => void

    /**
     * Returns the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) that contains a given uri.
     * * returns `undefined` when the given uri doesn't match any workspace folder
     * * returns the *input* when the given uri is a workspace folder itself

     * @param uri An uri.
     * @return A workspace folder or `undefined`
     */
    GetWorkspaceFolder: (uri: string) => (_: (_: WorkspaceFolder) => void) => void

    /**
     * List of workspace folders or `undefined` when no folder is open.
     * *Note* that the first entry corresponds to the value of `rootPath`.

     * @return A thenable that resolves when this call has completed at the counterparty and its result (if any) obtained.
     */
    WorkspaceFolders: (_: (_: WorkspaceFolder[]) => void) => void

    /**
     * Find files across all [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) in the workspace.
     * `findFiles('**​/*.js', '**​/node_modules/**', 10)`

     * @param include A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines the files to search for. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](https://code.visualstudio.com/api/references/vscode-api#RelativePattern) to restrict the search results to a [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder).
     * @param exclude A [glob pattern](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) that defines files and folders to exclude. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will apply, when `null` no excludes will apply.
     * @param maxResults An upper-bound for the result.
     * @param token A token that can be used to signal cancellation to the underlying search engine.
     * @return A thenable that resolves to an array of resource identifiers. Will return no results if no [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) are opened.
     */
    FindFiles: (include: string, exclude?: string, maxResults?: number, token?: Cancel) => (_: (_: string[]) => void) => void

    /**
     * Returns a path that is relative to the workspace folder or folders.
     * 
     * When there are no [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders) or when the path
     * is not contained in them, the input is returned.

     * @param pathOrUri A path or uri. When a uri is given its [fsPath](https://code.visualstudio.com/api/references/vscode-api#Uri.fsPath) is used.
     * @param includeWorkspaceFolder When `true` and when the given path is contained inside a workspace folder the name of the workspace is prepended. Defaults to `true` when there are multiple workspace folders and `false` otherwise.
     * @return A path relative to the root or the input.
     */
    AsRelativePath: (pathOrUri: string, includeWorkspaceFolder: boolean) => (_: (_: string) => void) => void

    /**
     * Provides single-call access to numerous individual `Workspace` properties at once.

     */
    Properties: (_: (_: WorkspaceProperties) => void) => void
}

/**
 * Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
 * like IntelliSense, code actions, diagnostics etc.
 * 
 * Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
 * like automatic word-completion, code navigation, or code checking have become popular across different tools for different
 * programming languages.
 * 
 * The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
 * by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
 * that can be called with a [TextDocument](https://code.visualstudio.com/api/references/vscode-api#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
 * mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
 * 
 * 
 * ```javascript
 * 
 * languages.registerHoverProvider('javascript', {
 *  	provideHover(document, position, token) {
 *  		return new Hover('I am a hover!');
 *  	}
 * });
 * 
 * ```
 * 
 * 
 * Registration is done using a [document selector](https://code.visualstudio.com/api/references/vscode-api#DocumentSelector) which is either a language id, like `javascript` or
 * a more complex [filter](https://code.visualstudio.com/api/references/vscode-api#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
 * a selector will result in a [score](https://code.visualstudio.com/api/references/vscode-api#languages.match) that is used to determine if and how a provider shall be used. When
 * scores are equal the provider that came last wins. For features that allow full arity, like [hover](https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider),
 * the score is only checked to be `>0`, for other features, like [IntelliSense](https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider) the
 * score is used for determining the order in which providers are asked to participate.

 */
export interface Languages {
    /**
     * Return the identifiers of all known languages.

     * @return Promise resolving to an array of identifier strings.
     */
    GetLanguages: (_: (_: string[]) => void) => void

    /**
     * An [event](https://code.visualstudio.com/api/references/vscode-api#Event) which fires when the global set of diagnostics changes. This is
     * newly added and removed diagnostics.

     * @param listener will be invoked whenever this event fires; mandatory, not optional.
     * @return A `Disposable` that will unsubscribe `listener` from the `OnDidChangeDiagnostics` event on `Dispose`.
     */
    OnDidChangeDiagnostics: (listener: (_: DiagnosticChangeEvent) => void) => (_: (_: Disposable) => void) => void
}

/**
 * Namespace for dealing with installed extensions. Extensions are represented
 * by an [extension](https://code.visualstudio.com/api/references/vscode-api#Extension)-interface which enables reflection on them.
 * 
 * Extension writers can provide APIs to other extensions by returning their API public
 * surface from the `activate`-call.
 * 
 * 
 * ```javascript
 * 
 * export function activate(context: vscode.ExtensionContext) {
 *  	let api = {
 *  		sum(a, b) {
 *  			return a + b;
 *  		},
 *  		mul(a, b) {
 *  			return a * b;
 *  		}
 *  	};
 *  	// 'export' public api-surface
 *  	return api;
 * }
 * 
 * ```
 * 
 * When depending on the API of another extension add an `extensionDependency`-entry
 * to `package.json`, and use the [getExtension](https://code.visualstudio.com/api/references/vscode-api#extensions.getExtension)-function
 * and the [exports](https://code.visualstudio.com/api/references/vscode-api#Extension.exports)-property, like below:
 * 
 * 
 * ```javascript
 * 
 * let mathExt = extensions.getExtension('genius.math');
 * let importedApi = mathExt.exports;
 * 
 * console.log(importedApi.mul(42, 1));
 * 
 * ```
 * 

 */
export interface Extensions {
    /**
     * An event which fires when `extensions.all` changes. This can happen when extensions are
     * installed, uninstalled, enabled or disabled.

     * @param listener will be invoked whenever this event fires; mandatory, not optional.
     * @return A `Disposable` that will unsubscribe `listener` from the `OnDidChange` event on `Dispose`.
     */
    OnDidChange: (listener: () => void) => (_: (_: Disposable) => void) => void
}

/**
 * Namespace for dealing with commands. In short, a command is a function with a
 * unique identifier. The function is sometimes also called _command handler_.
 * 
 * Commands can be added to the editor using the [registerCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand)
 * and [registerTextEditorCommand](https://code.visualstudio.com/api/references/vscode-api#commands.registerTextEditorCommand) functions. Commands
 * can be executed [manually](https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand) or from a UI gesture. Those are:
 * 
 * * palette - Use the `commands`-section in `package.json` to make a command show in
 * the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
 * * keybinding - Use the `keybindings`-section in `package.json` to enable
 * [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
 * for your extension.
 * 
 * Commands from other extensions and from the editor itself are accessible to an extension. However,
 * when invoking an editor command not all argument types are supported.
 * 
 * This is a sample that registers a command handler and adds an entry for that command to the palette. First
 * register a command handler with the identifier `extension.sayHello`.
 * 
 * ```javascript
 * 
 * commands.registerCommand('extension.sayHello', () => {
 *  	window.showInformationMessage('Hello World!');
 * });
 * 
 * ```
 * 
 * Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
 * 
 * ```json
 * 
 * {
 *  	"contributes": {
 *  		"commands": [{
 *  			"command": "extension.sayHello",
 *  			"title": "Hello World"
 *  		}]
 *  	}
 * }
 * 
 * ```
 * 

 */
export interface Commands {
    /**
     * Registers a command that can be invoked via a keyboard shortcut,
     * a menu item, an action, or directly.
     * 
     * Registering a command with an existing command identifier twice
     * will cause an error.

     * @param command A unique identifier for the command.
     * @param callback A command handler function.
     * @return Disposable which unregisters this command on disposal.
     */
    RegisterCommand: (command: string, callback: (_: any[]) => any) => (_: (_: Disposable) => void) => void

    /**
     * Executes the command denoted by the given command identifier.
     * 
     * * *Note 1:* When executing an editor command not all types are allowed to
     * be passed as arguments. Allowed are the primitive types `string`, `boolean`,
     * `number`, `undefined`, and `null`, as well as [`Position`](https://code.visualstudio.com/api/references/vscode-api#Position), [`Range`](#Range), [`Uri`](#Uri) and [`Location`](#Location).
     * * *Note 2:* There are no restrictions when executing commands that have been contributed
     * by extensions.

     * @param command Identifier of the command to execute.
     * @param rest Parameters passed to the command function.
     * @return A thenable that resolves to the returned value of the given command. `undefined` when the command handler function doesn't return anything.
     */
    ExecuteCommand: (command: string, rest: any[]) => (_: (_: any) => void) => void

    /**
     * Retrieve the list of all available commands. Commands starting an underscore are
     * treated as internal commands.

     * @param filterInternal Set `true` to not see internal commands (starting with an underscore)
     * @return Thenable that resolves to a list of command ids.
     */
    GetCommands: (filterInternal: boolean) => (_: (_: string[]) => void) => void
}

/**
 * Represents theme specific rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).

 */
export interface ThemableDecorationRenderOptions {
    /**
     * Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
     * Alternatively a color from the color registry can be [referenced](https://code.visualstudio.com/api/references/vscode-api#ThemeColor).

     */
    backgroundColor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    outline?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'outline' for setting one or more of the individual outline properties.

     */
    outlineColor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'outline' for setting one or more of the individual outline properties.

     */
    outlineStyle?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'outline' for setting one or more of the individual outline properties.

     */
    outlineWidth?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    border?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderColor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderRadius?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderSpacing?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderStyle?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderWidth?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    fontStyle?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    fontWeight?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    textDecoration?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    cursor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    color?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    opacity?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    letterSpacing?: string

    /**
     * An **absolute path** or an URI to an image to be rendered in the gutter.

     */
    gutterIconPath?: string

    /**
     * Specifies the size of the gutter icon.
     * Available values are 'auto', 'contain', 'cover' and any percentage value.
     * For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx

     */
    gutterIconSize?: string

    /**
     * The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.

     */
    overviewRulerColor?: string

    /**
     * Defines the rendering options of the attachment that is inserted before the decorated text.

     */
    before?: ThemableDecorationAttachmentRenderOptions

    /**
     * Defines the rendering options of the attachment that is inserted after the decorated text.

     */
    after?: ThemableDecorationAttachmentRenderOptions
}

/**
 * Options to configure the behavior of the message.

 */
export interface MessageOptions {
    /**
     * Indicates that this message should be modal.

     */
    modal?: boolean
}

/**
 * Represents an action that is shown with an information, warning, or
 * error message.

 */
export interface MessageItem extends fromJson {
    /**
     * A short title like 'Retry', 'Open Log' etc.

     */
    title: string

    /**
     * A hint for modal dialogs that the item should be triggered
     * when the user cancels the dialog (e.g. by pressing the ESC
     * key).
     * 
     * Note: this option is ignored for non-modal messages.

     */
    isCloseAffordance?: boolean

    /**
     * Free-form custom data, preserved across a roundtrip.

     */
    my?: { [_: string]: any }
}

export function newMessageItem (): MessageItem {
    let me: MessageItem
    me = { populateFrom: _ => MessageItem_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as MessageItem
    return me
}

/**
 * Options to configure the behavior of the input box UI.

 */
export interface InputBoxOptions {
    /**
     * The value to prefill in the input box.

     */
    value?: string

    /**
     * Selection of the prefilled [`value`](https://code.visualstudio.com/api/references/vscode-api#InputBoxOptions.value). Defined as tuple of two number where the
     * first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
     * word will be selected, when empty (start equals end) only the cursor will be set,
     * otherwise the defined range will be selected.

     */
    valueSelection?: [number, number]

    /**
     * The text to display underneath the input box.

     */
    prompt?: string

    /**
     * An optional string to show as place holder in the input box to guide the user what to type.

     */
    placeHolder?: string

    /**
     * Set to `true` to show a password prompt that will not show the typed value.

     */
    password?: boolean

    /**
     * Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.

     */
    ignoreFocusOut?: boolean

    /**
     * An optional function that will be called to validate input and to give a hint
     * to the user.
     * 
     * `value` ── The current value of the input box.
     * 
     * `return` ── A human readable string which is presented as diagnostic message.
     * Return `undefined`, `null`, or the empty string when 'value' is valid.

     */
    validateInput?: (_: string) => string

    /**
     * For internal runtime use only.

     */
    validateInput_AppzFuncId: string
}

/**
 * Options to configure the behavior of the quick pick UI.

 */
export interface QuickPickOptions {
    /**
     * An optional flag to include the description when filtering the picks.

     */
    matchOnDescription?: boolean

    /**
     * An optional flag to include the detail when filtering the picks.

     */
    matchOnDetail?: boolean

    /**
     * An optional string to show as place holder in the input box to guide the user what to pick on.

     */
    placeHolder?: string

    /**
     * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.

     */
    ignoreFocusOut?: boolean

    /**
     * An optional flag to make the picker accept multiple selections, if true the result is an array of picks.

     */
    canPickMany?: boolean

    /**
     * An optional function that is invoked whenever an item is selected.

     */
    onDidSelectItem?: (_: QuickPickItem) => any

    /**
     * For internal runtime use only.

     */
    onDidSelectItem_AppzFuncId: string
}

/**
 * Represents an item that can be selected from
 * a list of items.

 */
export interface QuickPickItem extends fromJson {
    /**
     * A human readable string which is rendered prominent.

     */
    label: string

    /**
     * A human readable string which is rendered less prominent.

     */
    description?: string

    /**
     * A human readable string which is rendered less prominent.

     */
    detail?: string

    /**
     * Optional flag indicating if this item is picked initially.
     * (Only honored when the picker allows multiple selections.)

     */
    picked?: boolean

    /**
     * Always show this item.

     */
    alwaysShow?: boolean

    /**
     * Free-form custom data, preserved across a roundtrip.

     */
    my?: { [_: string]: any }
}

export function newQuickPickItem (): QuickPickItem {
    let me: QuickPickItem
    me = { populateFrom: _ => QuickPickItem_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as QuickPickItem
    return me
}

/**
 * Options to configure the behaviour of a file save dialog.

 */
export interface SaveDialogOptions {
    /**
     * The resource the dialog shows when opened.

     */
    defaultUri?: string

    /**
     * A human-readable string for the save button.

     */
    saveLabel?: string

    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions, e.g.
     * 
     * ```ts
     * 
     * {
     *  	'Images': ['png', 'jpg']
     *  	'TypeScript': ['ts', 'tsx']
     * }
     * 
     * ```
     * 

     */
    filters?: { [_:string]: string[] }
}

/**
 * Options to configure the behaviour of a file open dialog.
 * 
 * * Note 1: A dialog can select files, folders, or both. This is not true for Windows
 * which enforces to open either files or folder, but *not both*.
 * * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
 * and the editor then silently adjusts the options to select files.

 */
export interface OpenDialogOptions {
    /**
     * The resource the dialog shows when opened.

     */
    defaultUri?: string

    /**
     * A human-readable string for the open button.

     */
    openLabel?: string

    /**
     * Allow to select files, defaults to `true`.

     */
    canSelectFiles?: boolean

    /**
     * Allow to select folders, defaults to `false`.

     */
    canSelectFolders?: boolean

    /**
     * Allow to select many files or folders.

     */
    canSelectMany?: boolean

    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions, e.g.
     * 
     * ```ts
     * 
     * {
     *  	'Images': ['png', 'jpg']
     *  	'TypeScript': ['ts', 'tsx']
     * }
     * 
     * ```
     * 

     */
    filters?: { [_:string]: string[] }
}

/**
 * Options to configure the behaviour of the [workspace folder](https://code.visualstudio.com/api/references/vscode-api#WorkspaceFolder) pick UI.

 */
export interface WorkspaceFolderPickOptions {
    /**
     * An optional string to show as place holder in the input box to guide the user what to pick on.

     */
    placeHolder?: string

    /**
     * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.

     */
    ignoreFocusOut?: boolean
}

/**
 * A workspace folder is one of potentially many roots opened by the editor. All workspace folders
 * are equal which means there is no notion of an active or master workspace folder.

 */
export interface WorkspaceFolder extends fromJson {
    /**
     * The associated uri for this workspace folder.
     * 
     * *Note:* The [Uri](https://code.visualstudio.com/api/references/vscode-api#Uri)-type was intentionally chosen such that future releases of the editor can support
     * workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.

     */
    uri: string

    /**
     * The name of this workspace folder. Defaults to
     * the basename of its [uri-path](https://code.visualstudio.com/api/references/vscode-api#Uri.path)

     */
    name: string

    /**
     * The ordinal number of this workspace folder.

     */
    index: number
}

function newWorkspaceFolder (): WorkspaceFolder {
    let me: WorkspaceFolder
    me = { populateFrom: _ => WorkspaceFolder_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as WorkspaceFolder
    return me
}

/**
 * Represents the state of a window.

 */
export interface WindowState extends fromJson {
    /**
     * Whether the current window is focused.

     */
    focused: boolean
}

function newWindowState (): WindowState {
    let me: WindowState
    me = { populateFrom: _ => WindowState_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as WindowState
    return me
}

/**
 * A status bar item is a status bar contribution that can
 * show text and icons and run a command on click.

 */
export interface StatusBarItem extends fromJson, withDisp {
    /**
     * Shows the entry in the status bar.

     */
    Show: () => (_: () => void) => void

    /**
     * Hide the entry in the status bar.

     */
    Hide: () => (_: () => void) => void

    /**
     * Dispose and free associated resources. Call
     * [hide](https://code.visualstudio.com/api/references/vscode-api#StatusBarItem.hide).

     */
    Dispose: () => (_: () => void) => void

    Get: () => (_: (_: StatusBarItemState) => void) => void

    Set: (_: StatusBarItemState) => (_: () => void) => void
}

function newStatusBarItem (): StatusBarItem {
    let me: StatusBarItem
    me = { populateFrom: _ => StatusBarItem_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as StatusBarItem
    me.Show = () => StatusBarItem_Show.call(me, )
    me.Hide = () => StatusBarItem_Hide.call(me, )
    me.Dispose = () => StatusBarItem_Dispose.call(me, )
    me.Get = () => StatusBarItem_Get.call(me, )
    me.Set = (a0) => StatusBarItem_Set.call(me, a0)
    return me
}

/**
 * An output channel is a container for readonly textual information.
 * 
 * To get an instance of an `OutputChannel` use
 * [createOutputChannel](https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel).

 */
export interface OutputChannel extends fromJson, withDisp {
    /**
     * Append the given value to the channel.
     * 
     * `value` ── A string, falsy values will not be printed.

     */
    Append: (_: string) => (_: () => void) => void

    /**
     * Append the given value and a line feed character
     * to the channel.
     * 
     * `value` ── A string, falsy values will be printed.

     */
    AppendLine: (_: string) => (_: () => void) => void

    /**
     * Removes all output from the channel.

     */
    Clear: () => (_: () => void) => void

    /**
     * Reveal this channel in the UI.
     * 
     * `preserveFocus` ── When `true` the channel will not take focus.

     */
    Show: (_: boolean) => (_: () => void) => void

    /**
     * Hide this channel from the UI.

     */
    Hide: () => (_: () => void) => void

    /**
     * Dispose and free associated resources.

     */
    Dispose: () => (_: () => void) => void

    Get: () => (_: (_: OutputChannelState) => void) => void
}

function newOutputChannel (): OutputChannel {
    let me: OutputChannel
    me = { populateFrom: _ => OutputChannel_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as OutputChannel
    me.Append = (a0) => OutputChannel_Append.call(me, a0)
    me.AppendLine = (a0) => OutputChannel_AppendLine.call(me, a0)
    me.Clear = () => OutputChannel_Clear.call(me, )
    me.Show = (a0) => OutputChannel_Show.call(me, a0)
    me.Hide = () => OutputChannel_Hide.call(me, )
    me.Dispose = () => OutputChannel_Dispose.call(me, )
    me.Get = () => OutputChannel_Get.call(me, )
    return me
}

/**
 * Type Definition for Visual Studio Code 1.39 Extension API
 * See https://code.visualstudio.com/api for more information

 */
export interface ThemableDecorationAttachmentRenderOptions {
    /**
     * Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.

     */
    contentText?: string

    /**
     * An **absolute path** or an URI to an image to be rendered in the attachment. Either an icon
     * or a text can be shown, but not both.

     */
    contentIconPath?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    border?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    borderColor?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    fontStyle?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    fontWeight?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    textDecoration?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    color?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    backgroundColor?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    margin?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    width?: string

    /**
     * CSS styling property that will be applied to the decoration attachment.

     */
    height?: string
}

/**
 * Represents rendering styles for a [text editor decoration](https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType).

 */
export interface DecorationRenderOptions {
    /**
     * Should the decoration be rendered also on the whitespace after the line text.
     * Defaults to `false`.

     */
    isWholeLine?: boolean

    /**
     * Customize the growing behavior of the decoration when edits occur at the edges of the decoration's range.
     * Defaults to `DecorationRangeBehavior.OpenOpen`.

     */
    rangeBehavior?: DecorationRangeBehavior

    /**
     * The position in the overview ruler where the decoration should be rendered.

     */
    overviewRulerLane?: OverviewRulerLane

    /**
     * Overwrite options for light themes.

     */
    light?: ThemableDecorationRenderOptions

    /**
     * Overwrite options for dark themes.

     */
    dark?: ThemableDecorationRenderOptions

    /**
     * Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
     * Alternatively a color from the color registry can be [referenced](https://code.visualstudio.com/api/references/vscode-api#ThemeColor).

     */
    backgroundColor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    outline?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'outline' for setting one or more of the individual outline properties.

     */
    outlineColor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'outline' for setting one or more of the individual outline properties.

     */
    outlineStyle?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'outline' for setting one or more of the individual outline properties.

     */
    outlineWidth?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    border?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderColor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderRadius?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderSpacing?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderStyle?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.
     * Better use 'border' for setting one or more of the individual border properties.

     */
    borderWidth?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    fontStyle?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    fontWeight?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    textDecoration?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    cursor?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    color?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    opacity?: string

    /**
     * CSS styling property that will be applied to text enclosed by a decoration.

     */
    letterSpacing?: string

    /**
     * An **absolute path** or an URI to an image to be rendered in the gutter.

     */
    gutterIconPath?: string

    /**
     * Specifies the size of the gutter icon.
     * Available values are 'auto', 'contain', 'cover' and any percentage value.
     * For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx

     */
    gutterIconSize?: string

    /**
     * The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.

     */
    overviewRulerColor?: string

    /**
     * Defines the rendering options of the attachment that is inserted before the decorated text.

     */
    before?: ThemableDecorationAttachmentRenderOptions

    /**
     * Defines the rendering options of the attachment that is inserted after the decorated text.

     */
    after?: ThemableDecorationAttachmentRenderOptions
}

/**
 * Represents a handle to a set of decorations
 * sharing the same [styling options](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions) in a [text editor](#TextEditor).
 * 
 * To get an instance of a `TextEditorDecorationType` use
 * [createTextEditorDecorationType](https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType).

 */
export interface TextEditorDecorationType extends fromJson, withDisp {
    /**
     * Remove this decoration type and all decorations on all text editors using it.

     */
    Dispose: () => (_: () => void) => void

    Get: () => (_: (_: TextEditorDecorationTypeState) => void) => void
}

function newTextEditorDecorationType (): TextEditorDecorationType {
    let me: TextEditorDecorationType
    me = { populateFrom: _ => TextEditorDecorationType_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as TextEditorDecorationType
    me.Dispose = () => TextEditorDecorationType_Dispose.call(me, )
    me.Get = () => TextEditorDecorationType_Get.call(me, )
    return me
}

/**
 * A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user input a text value.
 * 
 * Note that in many cases the more convenient [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox)
 * is easier to use. [window.createInputBox](https://code.visualstudio.com/api/references/vscode-api#window.createInputBox) should be used
 * when [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox) does not offer the required flexibility.

 */
export interface InputBox extends fromJson, withDisp {
    /**
     * An event signaling when the value has changed.

     */
    OnDidChangeValue: (_: (_: string) => void) => (_: (_: Disposable) => void) => void

    /**
     * An event signaling when the user indicated acceptance of the input value.

     */
    OnDidAccept: (_: () => void) => (_: (_: Disposable) => void) => void

    /**
     * An event signaling when a button was triggered.

     */
    OnDidTriggerButton: (_: (_: QuickInputButton) => void) => (_: (_: Disposable) => void) => void

    /**
     * Makes the input UI visible in its current configuration. Any other input
     * UI will first fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide) event.

     */
    Show: () => (_: () => void) => void

    /**
     * Hides this input UI. This will also fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide)
     * event.

     */
    Hide: () => (_: () => void) => void

    /**
     * An event signaling when this input UI is hidden.
     * 
     * There are several reasons why this UI might have to be hidden and
     * the extension will be notified through [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide).
     * (Examples include: an explicit call to [QuickInput.hide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.hide),
     * the user pressing Esc, some other input UI opening, etc.)

     */
    OnDidHide: (_: () => void) => (_: (_: Disposable) => void) => void

    /**
     * Dispose of this input UI and any associated resources. If it is still
     * visible, it is first hidden. After this call the input UI is no longer
     * functional and no additional methods or properties on it should be
     * accessed. Instead a new input UI should be created.

     */
    Dispose: () => (_: () => void) => void

    Get: () => (_: (_: InputBoxState) => void) => void

    Set: (_: InputBoxState) => (_: () => void) => void
}

function newInputBox (): InputBox {
    let me: InputBox
    me = { populateFrom: _ => InputBox_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as InputBox
    me.OnDidChangeValue = (a0) => InputBox_OnDidChangeValue.call(me, a0)
    me.OnDidAccept = (a0) => InputBox_OnDidAccept.call(me, a0)
    me.OnDidTriggerButton = (a0) => InputBox_OnDidTriggerButton.call(me, a0)
    me.Show = () => InputBox_Show.call(me, )
    me.Hide = () => InputBox_Hide.call(me, )
    me.OnDidHide = (a0) => InputBox_OnDidHide.call(me, a0)
    me.Dispose = () => InputBox_Dispose.call(me, )
    me.Get = () => InputBox_Get.call(me, )
    me.Set = (a0) => InputBox_Set.call(me, a0)
    return me
}

/**
 * Button for an action in a [QuickPick](https://code.visualstudio.com/api/references/vscode-api#QuickPick) or [InputBox](#InputBox).

 */
export interface QuickInputButton extends fromJson {
    /**
     * Icon for the button.

     */
    iconPath: string

    /**
     * An optional tooltip.

     */
    tooltip?: string

    /**
     * Free-form custom data, preserved across a roundtrip.

     */
    my?: { [_: string]: any }
}

export function newQuickInputButton (): QuickInputButton {
    let me: QuickInputButton
    me = { populateFrom: _ => QuickInputButton_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as QuickInputButton
    return me
}

/**
 * A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user pick an item from a
 * list of items of type T. The items can be filtered through a filter text field and
 * there is an option [canSelectMany](https://code.visualstudio.com/api/references/vscode-api#QuickPick.canSelectMany) to allow for
 * selecting multiple items.
 * 
 * Note that in many cases the more convenient [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick)
 * is easier to use. [window.createQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.createQuickPick) should be used
 * when [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick) does not offer the required flexibility.

 */
export interface QuickPick extends fromJson, withDisp {
    /**
     * An event signaling when the value of the filter text has changed.

     */
    OnDidChangeValue: (_: (_: string) => void) => (_: (_: Disposable) => void) => void

    /**
     * An event signaling when the user indicated acceptance of the selected item(s).

     */
    OnDidAccept: (_: () => void) => (_: (_: Disposable) => void) => void

    /**
     * An event signaling when the active items have changed.

     */
    OnDidChangeActive: (_: (_: QuickPickItem[]) => void) => (_: (_: Disposable) => void) => void

    /**
     * An event signaling when the selected items have changed.

     */
    OnDidChangeSelection: (_: (_: QuickPickItem[]) => void) => (_: (_: Disposable) => void) => void

    /**
     * Makes the input UI visible in its current configuration. Any other input
     * UI will first fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide) event.

     */
    Show: () => (_: () => void) => void

    /**
     * Hides this input UI. This will also fire an [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide)
     * event.

     */
    Hide: () => (_: () => void) => void

    /**
     * An event signaling when this input UI is hidden.
     * 
     * There are several reasons why this UI might have to be hidden and
     * the extension will be notified through [QuickInput.onDidHide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.onDidHide).
     * (Examples include: an explicit call to [QuickInput.hide](https://code.visualstudio.com/api/references/vscode-api#QuickInput.hide),
     * the user pressing Esc, some other input UI opening, etc.)

     */
    OnDidHide: (_: () => void) => (_: (_: Disposable) => void) => void

    /**
     * Dispose of this input UI and any associated resources. If it is still
     * visible, it is first hidden. After this call the input UI is no longer
     * functional and no additional methods or properties on it should be
     * accessed. Instead a new input UI should be created.

     */
    Dispose: () => (_: () => void) => void

    Get: () => (_: (_: QuickPickState) => void) => void

    Set: (_: QuickPickState) => (_: () => void) => void
}

function newQuickPick (): QuickPick {
    let me: QuickPick
    me = { populateFrom: _ => QuickPick_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as QuickPick
    me.OnDidChangeValue = (a0) => QuickPick_OnDidChangeValue.call(me, a0)
    me.OnDidAccept = (a0) => QuickPick_OnDidAccept.call(me, a0)
    me.OnDidChangeActive = (a0) => QuickPick_OnDidChangeActive.call(me, a0)
    me.OnDidChangeSelection = (a0) => QuickPick_OnDidChangeSelection.call(me, a0)
    me.Show = () => QuickPick_Show.call(me, )
    me.Hide = () => QuickPick_Hide.call(me, )
    me.OnDidHide = (a0) => QuickPick_OnDidHide.call(me, a0)
    me.Dispose = () => QuickPick_Dispose.call(me, )
    me.Get = () => QuickPick_Get.call(me, )
    me.Set = (a0) => QuickPick_Set.call(me, a0)
    return me
}

/**
 * An event describing a change to the set of [workspace folders](https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders).

 */
export interface WorkspaceFoldersChangeEvent extends fromJson {
    /**
     * Added workspace folders.

     */
    added: WorkspaceFolder[]

    /**
     * Removed workspace folders.

     */
    removed: WorkspaceFolder[]
}

function newWorkspaceFoldersChangeEvent (): WorkspaceFoldersChangeEvent {
    let me: WorkspaceFoldersChangeEvent
    me = { populateFrom: _ => WorkspaceFoldersChangeEvent_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as WorkspaceFoldersChangeEvent
    return me
}

/**
 * The event that is fired when diagnostics change.

 */
export interface DiagnosticChangeEvent extends fromJson {
    /**
     * An array of resources for which diagnostics have changed.

     */
    uris: string[]
}

function newDiagnosticChangeEvent (): DiagnosticChangeEvent {
    let me: DiagnosticChangeEvent
    me = { populateFrom: _ => DiagnosticChangeEvent_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as DiagnosticChangeEvent
    return me
}

/**
 * Namespace describing the environment the editor runs in.

 */
export interface EnvProperties extends fromJson {
    /**
     * The application name of the editor, like 'VS Code'.

     */
    appName?: string

    /**
     * The application root folder from which the editor is running.

     */
    appRoot?: string

    /**
     * Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.

     */
    language?: string

    /**
     * A unique identifier for the computer.

     */
    machineId?: string

    /**
     * The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
     * Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
     * 
     * *Note* that the value is `undefined` when there is no remote extension host but that the
     * value is defined in all extension hosts (local and remote) in case a remote extension host
     * exists. Use [`Extension#extensionKind`](https://code.visualstudio.com/api/references/vscode-api#Extension.extensionKind) to know if
     * a specific extension runs remote or not.

     */
    remoteName?: string

    /**
     * A unique identifier for the current session.
     * Changes each time the editor is started.

     */
    sessionId?: string

    /**
     * The detected default shell for the extension host, this is overridden by the
     * `terminal.integrated.shell` setting for the extension host's platform.

     */
    shell?: string

    /**
     * The custom uri scheme the editor registers to in the operating system.

     */
    uriScheme?: string
}

function newEnvProperties (): EnvProperties {
    let me: EnvProperties
    me = { populateFrom: _ => EnvProperties_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as EnvProperties
    return me
}

/**
 * Namespace for dealing with the current workspace. A workspace is the representation
 * of the folder that has been opened. There is no workspace when just a file but not a
 * folder has been opened.
 * 
 * The workspace offers support for [listening](https://code.visualstudio.com/api/references/vscode-api#workspace.createFileSystemWatcher) to fs
 * events and for [finding](https://code.visualstudio.com/api/references/vscode-api#workspace.findFiles) files. Both perform well and run _outside_
 * the editor-process so that they should be always used instead of nodejs-equivalents.

 */
export interface WorkspaceProperties extends fromJson {
    /**
     * The name of the workspace. `undefined` when no folder
     * has been opened.

     */
    name?: string

    /**
     * The location of the workspace file, for example:
     * 
     * `file:///Users/name/Development/myProject.code-workspace`
     * 
     * or
     * 
     * `untitled:1555503116870`
     * 
     * for a workspace that is untitled and not yet saved.
     * 
     * Depending on the workspace that is opened, the value will be:
     *   * `undefined` when no workspace or  a single folder is opened
     *   * the path of the workspace file as `Uri` otherwise. if the workspace
     * is untitled, the returned URI will use the `untitled:` scheme
     * 
     * The location can e.g. be used with the `vscode.openFolder` command to
     * open the workspace again after it has been closed.
     * 
     * **Example:**
     * 
     * ```typescript
     * 
     * vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
     * 
     * ```
     * 
     * 
     * **Note:** it is not advised to use `workspace.workspaceFile` to write
     * configuration data into the file. You can use `workspace.getConfiguration().update()`
     * for that purpose which will work both when a single folder is opened as
     * well as an untitled or saved workspace.

     */
    workspaceFile?: string

    /**
     * List of workspace folders or `undefined` when no folder is open.
     * *Note* that the first entry corresponds to the value of `rootPath`.

     */
    workspaceFolders?: WorkspaceFolder[]
}

function newWorkspaceProperties (): WorkspaceProperties {
    let me: WorkspaceProperties
    me = { populateFrom: _ => WorkspaceProperties_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as WorkspaceProperties
    return me
}

/**
 * A status bar item is a status bar contribution that can
 * show text and icons and run a command on click.

 */
export interface StatusBarItemState extends fromJson {
    /**
     * The alignment of this item.

     */
    Alignment: () => StatusBarAlignment

    /**
     * The priority of this item. Higher value means the item should
     * be shown more to the left.

     */
    Priority: () => number

    /**
     * The text to show for the entry. You can embed icons in the text by leveraging the syntax:
     * 
     * `My text $(icon-name) contains icons like $(icon-name) this one.`
     * 
     * Where the icon-name is taken from the [octicon](https://octicons.github.com) icon set, e.g.
     * `light-bulb`, `thumbsup`, `zap` etc.

     */
    text?: string

    /**
     * The tooltip text when you hover over this entry.

     */
    tooltip?: string

    /**
     * The foreground color for this entry.

     */
    color?: string

    /**
     * The identifier of a command to run on click. The command must be
     * [known](https://code.visualstudio.com/api/references/vscode-api#commands.getCommands).

     */
    command?: string
}

export function newStatusBarItemState (): StatusBarItemState {
    let me: StatusBarItemState
    me = { populateFrom: _ => StatusBarItemState_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as StatusBarItemState
    return me
}

/**
 * An output channel is a container for readonly textual information.
 * 
 * To get an instance of an `OutputChannel` use
 * [createOutputChannel](https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel).

 */
export interface OutputChannelState extends fromJson {
    /**
     * The human-readable name of this output channel.

     */
    Name: () => string
}

export function newOutputChannelState (): OutputChannelState {
    let me: OutputChannelState
    me = { populateFrom: _ => OutputChannelState_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as OutputChannelState
    return me
}

/**
 * Represents a handle to a set of decorations
 * sharing the same [styling options](https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions) in a [text editor](#TextEditor).
 * 
 * To get an instance of a `TextEditorDecorationType` use
 * [createTextEditorDecorationType](https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType).

 */
export interface TextEditorDecorationTypeState extends fromJson {
    /**
     * Internal representation of the handle.

     */
    Key: () => string
}

export function newTextEditorDecorationTypeState (): TextEditorDecorationTypeState {
    let me: TextEditorDecorationTypeState
    me = { populateFrom: _ => TextEditorDecorationTypeState_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as TextEditorDecorationTypeState
    return me
}

/**
 * A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user input a text value.
 * 
 * Note that in many cases the more convenient [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox)
 * is easier to use. [window.createInputBox](https://code.visualstudio.com/api/references/vscode-api#window.createInputBox) should be used
 * when [window.showInputBox](https://code.visualstudio.com/api/references/vscode-api#window.showInputBox) does not offer the required flexibility.

 */
export interface InputBoxState extends fromJson {
    /**
     * Current input value.

     */
    value?: string

    /**
     * Optional placeholder in the filter text.

     */
    placeholder?: string

    /**
     * If the input value should be hidden. Defaults to false.

     */
    password?: boolean

    /**
     * Buttons for actions in the UI.

     */
    buttons?: QuickInputButton[]

    /**
     * An optional prompt text providing some ask or explanation to the user.

     */
    prompt?: string

    /**
     * An optional validation message indicating a problem with the current input value.

     */
    validationMessage?: string

    /**
     * An optional title.

     */
    title?: string

    /**
     * An optional current step count.

     */
    step?: number

    /**
     * An optional total step count.

     */
    totalSteps?: number

    /**
     * If the UI should allow for user input. Defaults to true.
     * 
     * Change this to false, e.g., while validating user input or
     * loading data for the next step in user input.

     */
    enabled?: boolean

    /**
     * If the UI should show a progress indicator. Defaults to false.
     * 
     * Change this to true, e.g., while loading more data or validating
     * user input.

     */
    busy?: boolean

    /**
     * If the UI should stay open even when loosing UI focus. Defaults to false.

     */
    ignoreFocusOut?: boolean
}

export function newInputBoxState (): InputBoxState {
    let me: InputBoxState
    me = { populateFrom: _ => InputBoxState_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as InputBoxState
    return me
}

/**
 * A concrete [QuickInput](https://code.visualstudio.com/api/references/vscode-api#QuickInput) to let the user pick an item from a
 * list of items of type T. The items can be filtered through a filter text field and
 * there is an option [canSelectMany](https://code.visualstudio.com/api/references/vscode-api#QuickPick.canSelectMany) to allow for
 * selecting multiple items.
 * 
 * Note that in many cases the more convenient [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick)
 * is easier to use. [window.createQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.createQuickPick) should be used
 * when [window.showQuickPick](https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick) does not offer the required flexibility.

 */
export interface QuickPickState extends fromJson {
    /**
     * Current value of the filter text.

     */
    value?: string

    /**
     * Optional placeholder in the filter text.

     */
    placeholder?: string

    /**
     * Items to pick from.

     */
    items?: QuickPickItem[]

    /**
     * If multiple items can be selected at the same time. Defaults to false.

     */
    canSelectMany?: boolean

    /**
     * If the filter text should also be matched against the description of the items. Defaults to false.

     */
    matchOnDescription?: boolean

    /**
     * If the filter text should also be matched against the detail of the items. Defaults to false.

     */
    matchOnDetail?: boolean

    /**
     * Active items. This can be read and updated by the extension.

     */
    activeItems?: QuickPickItem[]

    /**
     * Selected items. This can be read and updated by the extension.

     */
    selectedItems?: QuickPickItem[]

    /**
     * An optional title.

     */
    title?: string

    /**
     * An optional current step count.

     */
    step?: number

    /**
     * An optional total step count.

     */
    totalSteps?: number

    /**
     * If the UI should allow for user input. Defaults to true.
     * 
     * Change this to false, e.g., while validating user input or
     * loading data for the next step in user input.

     */
    enabled?: boolean

    /**
     * If the UI should show a progress indicator. Defaults to false.
     * 
     * Change this to true, e.g., while loading more data or validating
     * user input.

     */
    busy?: boolean

    /**
     * If the UI should stay open even when loosing UI focus. Defaults to false.

     */
    ignoreFocusOut?: boolean
}

export function newQuickPickState (): QuickPickState {
    let me: QuickPickState
    me = { populateFrom: _ => QuickPickState_populateFrom.call(me, _), toString: () => JSON.stringify(me, (_, v) => (typeof v === 'function') ? undefined : v) } as QuickPickState
    return me
}

export abstract class impl implements Vscode {
    Window: Window
    Env: Env
    Clipboard: Clipboard
    Workspace: Workspace
    Languages: Languages
    Extensions: Extensions
    Commands: Commands
    constructor() {
        this.Window = new implWindow(this)
        this.Env = new implEnv(this)
        this.Clipboard = new implClipboard(this)
        this.Workspace = new implWorkspace(this)
        this.Languages = new implLanguages(this)
        this.Extensions = new implExtensions(this)
        this.Commands = new implCommands(this)
    }
}

class implWindow extends implBase implements Window {
    constructor(impl: impl) { super(impl) }
    ShowInformationMessage1(message: string, items: string[]): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showInformationMessage1"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowInformationMessage2(message: string, options: MessageOptions, items: string[]): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showInformationMessage2"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowInformationMessage3(message: string, items: MessageItem[]): (_: (_: MessageItem) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showInformationMessage3"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: MessageItem) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: MessageItem
            if ((undefined !== payload && null !== payload)) {
                result = newMessageItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: MessageItem) => void): void => {
            onret = a0
        }
    }

    ShowInformationMessage4(message: string, options: MessageOptions, items: MessageItem[]): (_: (_: MessageItem) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showInformationMessage4"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: MessageItem) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: MessageItem
            if ((undefined !== payload && null !== payload)) {
                result = newMessageItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: MessageItem) => void): void => {
            onret = a0
        }
    }

    ShowWarningMessage1(message: string, items: string[]): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showWarningMessage1"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowWarningMessage2(message: string, options: MessageOptions, items: string[]): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showWarningMessage2"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowWarningMessage3(message: string, items: MessageItem[]): (_: (_: MessageItem) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showWarningMessage3"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: MessageItem) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: MessageItem
            if ((undefined !== payload && null !== payload)) {
                result = newMessageItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: MessageItem) => void): void => {
            onret = a0
        }
    }

    ShowWarningMessage4(message: string, options: MessageOptions, items: MessageItem[]): (_: (_: MessageItem) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showWarningMessage4"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: MessageItem) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: MessageItem
            if ((undefined !== payload && null !== payload)) {
                result = newMessageItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: MessageItem) => void): void => {
            onret = a0
        }
    }

    ShowErrorMessage1(message: string, items: string[]): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showErrorMessage1"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowErrorMessage2(message: string, options: MessageOptions, items: string[]): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showErrorMessage2"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowErrorMessage3(message: string, items: MessageItem[]): (_: (_: MessageItem) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showErrorMessage3"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: MessageItem) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: MessageItem
            if ((undefined !== payload && null !== payload)) {
                result = newMessageItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: MessageItem) => void): void => {
            onret = a0
        }
    }

    ShowErrorMessage4(message: string, options: MessageOptions, items: MessageItem[]): (_: (_: MessageItem) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showErrorMessage4"
        msg.Data = {}
        msg.Data["message"] = message
        msg.Data["options"] = options
        msg.Data["items"] = items
        let onresp: (_: any) => boolean
        let onret: (_: MessageItem) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: MessageItem
            if ((undefined !== payload && null !== payload)) {
                result = newMessageItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: MessageItem) => void): void => {
            onret = a0
        }
    }

    ShowInputBox(options?: InputBoxOptions, token?: Cancel): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showInputBox"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if ((undefined !== options && null !== options)) {
            options.validateInput_AppzFuncId = ""
            let fn: (_: string) => string
            fn = options.validateInput
            if ((undefined !== fn && null !== fn)) {
                {
                    options.validateInput_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.validateInput_AppzFuncId)
                    this.Impl().cbOther[options.validateInput_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if (1 !== args.length) {
                            return [null, false]
                        } else {
                            let ok: boolean
                            let __0: string
                            if ((undefined !== args[0] && null !== args[0])) {
                                [__0, ok] = [args[0] as string, typeof args[0] === "string"]
                                if (!ok) {
                                    return [null, false]
                                }
                            }
                            return [fn(__0), true]
                        }
                    }
                }
            }
        }
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return (undefined === onresp || null === onresp) || onresp(payload)
        })
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowQuickPick1(items: string[], options: QuickPickOptions, token?: Cancel): (_: (_: string[]) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showQuickPick1"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if (true) {
            options.onDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.onDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.onDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if (1 !== args.length) {
                            return [null, false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if (!ok) {
                                    return [null, false]
                                }
                            } else {
                                return [null, false]
                            }
                            return [fn(__0), true]
                        }
                    }
                }
            }
        }
        msg.Data["items"] = items
        options.canPickMany = true
        msg.Data["options"] = options
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let onresp: (_: any) => boolean
        let onret: (_: string[]) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string[]
            if ((undefined !== payload && null !== payload)) {
                let __coll__result: any[]
                [__coll__result, ok] = [payload as any[], (typeof payload === "object") && (typeof payload["length"] === "number")]
                if (!ok) {
                    return false
                }
                result = new Array(__coll__result.length)
                let __idx__result: number
                __idx__result = 0
                for (const __item__result of __coll__result) {
                    let __val__result: string
                    [__val__result, ok] = [__item__result as string, typeof __item__result === "string"]
                    if (!ok) {
                        return false
                    }
                    result[__idx__result] = __val__result
                    __idx__result = __idx__result + 1
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return (undefined === onresp || null === onresp) || onresp(payload)
        })
        return (a0: (_: string[]) => void): void => {
            onret = a0
        }
    }

    ShowQuickPick2(items: string[], options?: QuickPickOptions, token?: Cancel): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showQuickPick2"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if ((undefined !== options && null !== options)) {
            options.onDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.onDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.onDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if (1 !== args.length) {
                            return [null, false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if (!ok) {
                                    return [null, false]
                                }
                            } else {
                                return [null, false]
                            }
                            return [fn(__0), true]
                        }
                    }
                }
            }
        }
        msg.Data["items"] = items
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return (undefined === onresp || null === onresp) || onresp(payload)
        })
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowQuickPick3(items: QuickPickItem[], options: QuickPickOptions, token?: Cancel): (_: (_: QuickPickItem[]) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showQuickPick3"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if (true) {
            options.onDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.onDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.onDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if (1 !== args.length) {
                            return [null, false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if (!ok) {
                                    return [null, false]
                                }
                            } else {
                                return [null, false]
                            }
                            return [fn(__0), true]
                        }
                    }
                }
            }
        }
        msg.Data["items"] = items
        options.canPickMany = true
        msg.Data["options"] = options
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let onresp: (_: any) => boolean
        let onret: (_: QuickPickItem[]) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: QuickPickItem[]
            if ((undefined !== payload && null !== payload)) {
                let __coll__result: any[]
                [__coll__result, ok] = [payload as any[], (typeof payload === "object") && (typeof payload["length"] === "number")]
                if (!ok) {
                    return false
                }
                result = new Array(__coll__result.length)
                let __idx__result: number
                __idx__result = 0
                for (const __item__result of __coll__result) {
                    let __val__result: QuickPickItem
                    __val__result = newQuickPickItem()
                    ok = __val__result.populateFrom(__item__result)
                    if (!ok) {
                        return false
                    }
                    result[__idx__result] = __val__result
                    __idx__result = __idx__result + 1
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return (undefined === onresp || null === onresp) || onresp(payload)
        })
        return (a0: (_: QuickPickItem[]) => void): void => {
            onret = a0
        }
    }

    ShowQuickPick4(items: QuickPickItem[], options?: QuickPickOptions, token?: Cancel): (_: (_: QuickPickItem) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showQuickPick4"
        msg.Data = {}
        let fnids: string[]
        fnids = []
        if ((undefined !== options && null !== options)) {
            options.onDidSelectItem_AppzFuncId = ""
            let fn: (_: QuickPickItem) => any
            fn = options.onDidSelectItem
            if ((undefined !== fn && null !== fn)) {
                {
                    options.onDidSelectItem_AppzFuncId = this.Impl().nextFuncId()
                    fnids.push(options.onDidSelectItem_AppzFuncId)
                    this.Impl().cbOther[options.onDidSelectItem_AppzFuncId] = (args: any[]): [any, boolean] => {
                        if (1 !== args.length) {
                            return [null, false]
                        } else {
                            let ok: boolean
                            let __0: QuickPickItem
                            if ((undefined !== args[0] && null !== args[0])) {
                                __0 = newQuickPickItem()
                                ok = __0.populateFrom(args[0])
                                if (!ok) {
                                    return [null, false]
                                }
                            } else {
                                return [null, false]
                            }
                            return [fn(__0), true]
                        }
                    }
                }
            }
        }
        msg.Data["items"] = items
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let onresp: (_: any) => boolean
        let onret: (_: QuickPickItem) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: QuickPickItem
            if ((undefined !== payload && null !== payload)) {
                result = newQuickPickItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, (payload: any): boolean => {
            if (fnids.length !== 0) {
                {
                    for (const fnid of fnids) {
                        delete this.Impl().cbOther[fnid]
                    }
                }
            }
            return (undefined === onresp || null === onresp) || onresp(payload)
        })
        return (a0: (_: QuickPickItem) => void): void => {
            onret = a0
        }
    }

    SetStatusBarMessage1(text: string, hideAfterTimeout: number): (_: (_: Disposable) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.setStatusBarMessage1"
        msg.Data = {}
        msg.Data["text"] = text
        msg.Data["hideAfterTimeout"] = hideAfterTimeout
        let onresp: (_: any) => boolean
        let onret: (_: Disposable) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: Disposable
            if ((undefined !== payload && null !== payload)) {
                result = newDisposable()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result.bind(this.Impl()))
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: Disposable) => void): void => {
            onret = a0
        }
    }

    SetStatusBarMessage2(text: string): (_: (_: Disposable) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.setStatusBarMessage2"
        msg.Data = {}
        msg.Data["text"] = text
        let onresp: (_: any) => boolean
        let onret: (_: Disposable) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: Disposable
            if ((undefined !== payload && null !== payload)) {
                result = newDisposable()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result.bind(this.Impl()))
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: Disposable) => void): void => {
            onret = a0
        }
    }

    ShowSaveDialog(options: SaveDialogOptions): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showSaveDialog"
        msg.Data = {}
        msg.Data["options"] = options
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    ShowOpenDialog(options: OpenDialogOptions): (_: (_: string[]) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showOpenDialog"
        msg.Data = {}
        msg.Data["options"] = options
        let onresp: (_: any) => boolean
        let onret: (_: string[]) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string[]
            if ((undefined !== payload && null !== payload)) {
                let __coll__result: any[]
                [__coll__result, ok] = [payload as any[], (typeof payload === "object") && (typeof payload["length"] === "number")]
                if (!ok) {
                    return false
                }
                result = new Array(__coll__result.length)
                let __idx__result: number
                __idx__result = 0
                for (const __item__result of __coll__result) {
                    let __val__result: string
                    [__val__result, ok] = [__item__result as string, typeof __item__result === "string"]
                    if (!ok) {
                        return false
                    }
                    result[__idx__result] = __val__result
                    __idx__result = __idx__result + 1
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string[]) => void): void => {
            onret = a0
        }
    }

    ShowWorkspaceFolderPick(options?: WorkspaceFolderPickOptions): (_: (_: WorkspaceFolder) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.showWorkspaceFolderPick"
        msg.Data = {}
        if ((undefined !== options && null !== options)) {
            msg.Data["options"] = options
        }
        let onresp: (_: any) => boolean
        let onret: (_: WorkspaceFolder) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: WorkspaceFolder
            if ((undefined !== payload && null !== payload)) {
                result = newWorkspaceFolder()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: WorkspaceFolder) => void): void => {
            onret = a0
        }
    }

    State(): (_: (_: WindowState) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.state"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: WindowState) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: WindowState
            if ((undefined !== payload && null !== payload)) {
                result = newWindowState()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: WindowState) => void): void => {
            onret = a0
        }
    }

    OnDidChangeWindowState(listener: (_: WindowState) => void): (_: (_: Disposable) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.onDidChangeWindowState"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return null
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if (1 !== args.length) {
                return ok
            }
            let _a_0_: WindowState
            _a_0_ = newWindowState()
            ok = _a_0_.populateFrom(args[0])
            if (!ok) {
                return false
            }
            listener(_a_0_)
            return true
        }, null)
        msg.Data["listener"] = _fnid_listener
        let onresp: (_: any) => boolean
        let onret: (_: Disposable) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: Disposable
            if ((undefined !== payload && null !== payload)) {
                result = newDisposable()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result.bind(this.Impl(), _fnid_listener))
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: Disposable) => void): void => {
            onret = a0
        }
    }

    CreateStatusBarItem(alignment?: StatusBarAlignment, priority?: number, optionallyInitialStateToApplyUponCreation?: StatusBarItemState): (_: (_: StatusBarItem, __: StatusBarItemState) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.createStatusBarItem"
        msg.Data = {}
        if ((undefined !== alignment && null !== alignment)) {
            msg.Data["alignment"] = alignment
        }
        if ((undefined !== priority && null !== priority)) {
            msg.Data["priority"] = priority
        }
        let onresp: (_: any) => boolean
        let onret: (_: StatusBarItem, __: StatusBarItemState) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: StatusBarItem
            if ((undefined !== payload && null !== payload)) {
                result = newStatusBarItem()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
                result.disp.impl = this.Impl()
            }
            {
                if ((undefined !== optionallyInitialStateToApplyUponCreation && null !== optionallyInitialStateToApplyUponCreation)) {
                    result.Set(optionallyInitialStateToApplyUponCreation)
                }
                result.Get()((state: StatusBarItemState): void => {
                    if ((undefined !== onret && null !== onret)) {
                        onret(result, state)
                    }
                })
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: StatusBarItem, __: StatusBarItemState) => void): void => {
            onret = a0
        }
    }

    CreateOutputChannel(name: string): (_: (_: OutputChannel, __: OutputChannelState) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.createOutputChannel"
        msg.Data = {}
        msg.Data["name"] = name
        let onresp: (_: any) => boolean
        let onret: (_: OutputChannel, __: OutputChannelState) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: OutputChannel
            if ((undefined !== payload && null !== payload)) {
                result = newOutputChannel()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
                result.disp.impl = this.Impl()
            }
            {
                result.Get()((state: OutputChannelState): void => {
                    if ((undefined !== onret && null !== onret)) {
                        onret(result, state)
                    }
                })
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: OutputChannel, __: OutputChannelState) => void): void => {
            onret = a0
        }
    }

    CreateTextEditorDecorationType(options: DecorationRenderOptions): (_: (_: TextEditorDecorationType, __: TextEditorDecorationTypeState) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.createTextEditorDecorationType"
        msg.Data = {}
        msg.Data["options"] = options
        let onresp: (_: any) => boolean
        let onret: (_: TextEditorDecorationType, __: TextEditorDecorationTypeState) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: TextEditorDecorationType
            if ((undefined !== payload && null !== payload)) {
                result = newTextEditorDecorationType()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
                result.disp.impl = this.Impl()
            }
            {
                result.Get()((state: TextEditorDecorationTypeState): void => {
                    if ((undefined !== onret && null !== onret)) {
                        onret(result, state)
                    }
                })
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: TextEditorDecorationType, __: TextEditorDecorationTypeState) => void): void => {
            onret = a0
        }
    }

    CreateInputBox(optionallyInitialStateToApplyUponCreation?: InputBoxState): (_: (_: InputBox, __: InputBoxState) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.createInputBox"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: InputBox, __: InputBoxState) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: InputBox
            if ((undefined !== payload && null !== payload)) {
                result = newInputBox()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
                result.disp.impl = this.Impl()
            }
            {
                if ((undefined !== optionallyInitialStateToApplyUponCreation && null !== optionallyInitialStateToApplyUponCreation)) {
                    result.Set(optionallyInitialStateToApplyUponCreation)
                }
                result.Get()((state: InputBoxState): void => {
                    if ((undefined !== onret && null !== onret)) {
                        onret(result, state)
                    }
                })
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: InputBox, __: InputBoxState) => void): void => {
            onret = a0
        }
    }

    CreateQuickPick(optionallyInitialStateToApplyUponCreation?: QuickPickState): (_: (_: QuickPick, __: QuickPickState) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "window.createQuickPick"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: QuickPick, __: QuickPickState) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: QuickPick
            if ((undefined !== payload && null !== payload)) {
                result = newQuickPick()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
                result.disp.impl = this.Impl()
            }
            {
                if ((undefined !== optionallyInitialStateToApplyUponCreation && null !== optionallyInitialStateToApplyUponCreation)) {
                    result.Set(optionallyInitialStateToApplyUponCreation)
                }
                result.Get()((state: QuickPickState): void => {
                    if ((undefined !== onret && null !== onret)) {
                        onret(result, state)
                    }
                })
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: QuickPick, __: QuickPickState) => void): void => {
            onret = a0
        }
    }

}

class implEnv extends implBase implements Env {
    constructor(impl: impl) { super(impl) }
    OpenExternal(target: string): (_: (_: boolean) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.openExternal"
        msg.Data = {}
        msg.Data["target"] = target
        let onresp: (_: any) => boolean
        let onret: (_: boolean) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: boolean
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as boolean, typeof payload === "boolean"]
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: boolean) => void): void => {
            onret = a0
        }
    }

    AppName(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.appName"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    AppRoot(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.appRoot"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    Language(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.language"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    MachineId(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.machineId"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    RemoteName(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.remoteName"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    SessionId(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.sessionId"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    Shell(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.shell"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    UriScheme(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.uriScheme"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    Properties(): (_: (_: EnvProperties) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "env.Properties"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: EnvProperties) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: EnvProperties
            if ((undefined !== payload && null !== payload)) {
                result = newEnvProperties()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: EnvProperties) => void): void => {
            onret = a0
        }
    }

    Clipboard(): Clipboard {
        return this.Impl().Clipboard
    }

}

class implClipboard extends implBase implements Clipboard {
    constructor(impl: impl) { super(impl) }
    ReadText(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "clipboard.readText"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    WriteText(value: string): (_: () => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "clipboard.writeText"
        msg.Data = {}
        msg.Data["value"] = value
        let onresp: (_: any) => boolean
        let onret: () => void
        onresp = (payload: any): boolean => {
            if ((undefined !== payload && null !== payload)) {
                return false
            }
            if ((undefined !== onret && null !== onret)) {
                onret()
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: () => void): void => {
            onret = a0
        }
    }

}

class implWorkspace extends implBase implements Workspace {
    constructor(impl: impl) { super(impl) }
    Name(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.name"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    WorkspaceFile(): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.workspaceFile"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    SaveAll(includeUntitled: boolean): (_: (_: boolean) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.saveAll"
        msg.Data = {}
        msg.Data["includeUntitled"] = includeUntitled
        let onresp: (_: any) => boolean
        let onret: (_: boolean) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: boolean
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload as boolean, typeof payload === "boolean"]
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: boolean) => void): void => {
            onret = a0
        }
    }

    OnDidChangeWorkspaceFolders(listener: (_: WorkspaceFoldersChangeEvent) => void): (_: (_: Disposable) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.onDidChangeWorkspaceFolders"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Workspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return null
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if (1 !== args.length) {
                return ok
            }
            let _a_0_: WorkspaceFoldersChangeEvent
            _a_0_ = newWorkspaceFoldersChangeEvent()
            ok = _a_0_.populateFrom(args[0])
            if (!ok) {
                return false
            }
            listener(_a_0_)
            return true
        }, null)
        msg.Data["listener"] = _fnid_listener
        let onresp: (_: any) => boolean
        let onret: (_: Disposable) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: Disposable
            if ((undefined !== payload && null !== payload)) {
                result = newDisposable()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result.bind(this.Impl(), _fnid_listener))
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: Disposable) => void): void => {
            onret = a0
        }
    }

    GetWorkspaceFolder(uri: string): (_: (_: WorkspaceFolder) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.getWorkspaceFolder"
        msg.Data = {}
        msg.Data["uri"] = uri
        let onresp: (_: any) => boolean
        let onret: (_: WorkspaceFolder) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: WorkspaceFolder
            if ((undefined !== payload && null !== payload)) {
                result = newWorkspaceFolder()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: WorkspaceFolder) => void): void => {
            onret = a0
        }
    }

    WorkspaceFolders(): (_: (_: WorkspaceFolder[]) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.workspaceFolders"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: WorkspaceFolder[]) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: WorkspaceFolder[]
            if ((undefined !== payload && null !== payload)) {
                let __coll__result: any[]
                [__coll__result, ok] = [payload as any[], (typeof payload === "object") && (typeof payload["length"] === "number")]
                if (!ok) {
                    return false
                }
                result = new Array(__coll__result.length)
                let __idx__result: number
                __idx__result = 0
                for (const __item__result of __coll__result) {
                    let __val__result: WorkspaceFolder
                    __val__result = newWorkspaceFolder()
                    ok = __val__result.populateFrom(__item__result)
                    if (!ok) {
                        return false
                    }
                    result[__idx__result] = __val__result
                    __idx__result = __idx__result + 1
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: WorkspaceFolder[]) => void): void => {
            onret = a0
        }
    }

    FindFiles(include: string, exclude?: string, maxResults?: number, token?: Cancel): (_: (_: string[]) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.findFiles"
        msg.Data = {}
        msg.Data["include"] = include
        if ((undefined !== exclude && null !== exclude)) {
            msg.Data["exclude"] = exclude
        }
        if ((undefined !== maxResults && null !== maxResults)) {
            msg.Data["maxResults"] = maxResults
        }
        if ((undefined !== token && null !== token)) {
            token.impl = this.Impl()
            if ("" === token.fnId) {
                {
                    token.fnId = this.Impl().nextFuncId()
                }
            }
            msg.Data["token"] = token.fnId
        }
        let onresp: (_: any) => boolean
        let onret: (_: string[]) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string[]
            if ((undefined !== payload && null !== payload)) {
                let __coll__result: any[]
                [__coll__result, ok] = [payload as any[], (typeof payload === "object") && (typeof payload["length"] === "number")]
                if (!ok) {
                    return false
                }
                result = new Array(__coll__result.length)
                let __idx__result: number
                __idx__result = 0
                for (const __item__result of __coll__result) {
                    let __val__result: string
                    [__val__result, ok] = [__item__result as string, typeof __item__result === "string"]
                    if (!ok) {
                        return false
                    }
                    result[__idx__result] = __val__result
                    __idx__result = __idx__result + 1
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string[]) => void): void => {
            onret = a0
        }
    }

    AsRelativePath(pathOrUri: string, includeWorkspaceFolder: boolean): (_: (_: string) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.asRelativePath"
        msg.Data = {}
        msg.Data["pathOrUri"] = pathOrUri
        msg.Data["includeWorkspaceFolder"] = includeWorkspaceFolder
        let onresp: (_: any) => boolean
        let onret: (_: string) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string
            if ((undefined !== payload && null !== payload)) {
                let _result_: string
                [_result_, ok] = [payload as string, typeof payload === "string"]
                if (!ok) {
                    return false
                }
                result = _result_
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string) => void): void => {
            onret = a0
        }
    }

    Properties(): (_: (_: WorkspaceProperties) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "workspace.Properties"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: WorkspaceProperties) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: WorkspaceProperties
            if ((undefined !== payload && null !== payload)) {
                result = newWorkspaceProperties()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: WorkspaceProperties) => void): void => {
            onret = a0
        }
    }

}

class implLanguages extends implBase implements Languages {
    constructor(impl: impl) { super(impl) }
    GetLanguages(): (_: (_: string[]) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "languages.getLanguages"
        msg.Data = {}
        let onresp: (_: any) => boolean
        let onret: (_: string[]) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string[]
            if ((undefined !== payload && null !== payload)) {
                let __coll__result: any[]
                [__coll__result, ok] = [payload as any[], (typeof payload === "object") && (typeof payload["length"] === "number")]
                if (!ok) {
                    return false
                }
                result = new Array(__coll__result.length)
                let __idx__result: number
                __idx__result = 0
                for (const __item__result of __coll__result) {
                    let __val__result: string
                    [__val__result, ok] = [__item__result as string, typeof __item__result === "string"]
                    if (!ok) {
                        return false
                    }
                    result[__idx__result] = __val__result
                    __idx__result = __idx__result + 1
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string[]) => void): void => {
            onret = a0
        }
    }

    OnDidChangeDiagnostics(listener: (_: DiagnosticChangeEvent) => void): (_: (_: Disposable) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "languages.onDidChangeDiagnostics"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Languages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return null
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if (1 !== args.length) {
                return ok
            }
            let _a_0_: DiagnosticChangeEvent
            _a_0_ = newDiagnosticChangeEvent()
            ok = _a_0_.populateFrom(args[0])
            if (!ok) {
                return false
            }
            listener(_a_0_)
            return true
        }, null)
        msg.Data["listener"] = _fnid_listener
        let onresp: (_: any) => boolean
        let onret: (_: Disposable) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: Disposable
            if ((undefined !== payload && null !== payload)) {
                result = newDisposable()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result.bind(this.Impl(), _fnid_listener))
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: Disposable) => void): void => {
            onret = a0
        }
    }

}

class implExtensions extends implBase implements Extensions {
    constructor(impl: impl) { super(impl) }
    OnDidChange(listener: () => void): (_: (_: Disposable) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "extensions.onDidChange"
        msg.Data = {}
        let _fnid_listener: string
        if ((undefined === listener || null === listener)) {
            OnError(this.Impl(), "Extensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
            return null
        }
        _fnid_listener = this.Impl().nextSub((args: any[]): boolean => {
            let ok: boolean
            if (0 !== args.length) {
                return ok
            }
            listener()
            return true
        }, null)
        msg.Data["listener"] = _fnid_listener
        let onresp: (_: any) => boolean
        let onret: (_: Disposable) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: Disposable
            if ((undefined !== payload && null !== payload)) {
                result = newDisposable()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result.bind(this.Impl(), _fnid_listener))
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: Disposable) => void): void => {
            onret = a0
        }
    }

}

class implCommands extends implBase implements Commands {
    constructor(impl: impl) { super(impl) }
    RegisterCommand(command: string, callback: (_: any[]) => any): (_: (_: Disposable) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "commands.registerCommand"
        msg.Data = {}
        msg.Data["command"] = command
        let _fnid_callback: string
        if ((undefined === callback || null === callback)) {
            OnError(this.Impl(), "Commands.RegisterCommand: the 'callback' arg (which is not optional but required) was not passed by the caller", null)
            return null
        }
        _fnid_callback = this.Impl().nextSub(null, (args: any[]): [any, boolean] => {
            let ok: boolean
            if (1 !== args.length) {
                return [null, ok]
            }
            let ret: any
            let _a_0_: any[]
            [_a_0_, ok] = [args[0] as any[], (typeof args[0] === "object") && (typeof args[0]["length"] === "number")]
            if (!ok) {
                return [null, false]
            }
            ret = callback(_a_0_)
            return [ret, true]
        })
        msg.Data["callback"] = _fnid_callback
        let onresp: (_: any) => boolean
        let onret: (_: Disposable) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: Disposable
            if ((undefined !== payload && null !== payload)) {
                result = newDisposable()
                ok = result.populateFrom(payload)
                if (!ok) {
                    return false
                }
            } else {
                return false
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result.bind(this.Impl(), _fnid_callback))
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: Disposable) => void): void => {
            onret = a0
        }
    }

    ExecuteCommand(command: string, rest: any[]): (_: (_: any) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "commands.executeCommand"
        msg.Data = {}
        msg.Data["command"] = command
        msg.Data["rest"] = rest
        let onresp: (_: any) => boolean
        let onret: (_: any) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: any
            if ((undefined !== payload && null !== payload)) {
                [result, ok] = [payload, true]
                if (ok) {
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: any) => void): void => {
            onret = a0
        }
    }

    GetCommands(filterInternal: boolean): (_: (_: string[]) => void) => void {
        let msg: ipcMsg
        msg = newipcMsg()
        msg.QName = "commands.getCommands"
        msg.Data = {}
        msg.Data["filterInternal"] = filterInternal
        let onresp: (_: any) => boolean
        let onret: (_: string[]) => void
        onresp = (payload: any): boolean => {
            let ok: boolean
            let result: string[]
            if ((undefined !== payload && null !== payload)) {
                let __coll__result: any[]
                [__coll__result, ok] = [payload as any[], (typeof payload === "object") && (typeof payload["length"] === "number")]
                if (!ok) {
                    return false
                }
                result = new Array(__coll__result.length)
                let __idx__result: number
                __idx__result = 0
                for (const __item__result of __coll__result) {
                    let __val__result: string
                    [__val__result, ok] = [__item__result as string, typeof __item__result === "string"]
                    if (!ok) {
                        return false
                    }
                    result[__idx__result] = __val__result
                    __idx__result = __idx__result + 1
                }
            }
            {
                if ((undefined !== onret && null !== onret)) {
                    onret(result)
                }
            }
            return true
        }
        this.Impl().send(msg, onresp)
        return (a0: (_: string[]) => void): void => {
            onret = a0
        }
    }

}

function StatusBarItem_Show(this: StatusBarItem, ): (_: (_: StatusBarItemState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "StatusBarItem.show"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: StatusBarItemState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: StatusBarItemState
        if ((undefined !== payload && null !== payload)) {
            result = newStatusBarItemState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: StatusBarItemState) => void): void => {
        onret = a0
    }
}

function StatusBarItem_Hide(this: StatusBarItem, ): (_: (_: StatusBarItemState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "StatusBarItem.hide"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: StatusBarItemState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: StatusBarItemState
        if ((undefined !== payload && null !== payload)) {
            result = newStatusBarItemState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: StatusBarItemState) => void): void => {
        onret = a0
    }
}

function StatusBarItem_Dispose(this: StatusBarItem, ): (_: () => void) => void {
    return this.disp.Dispose()
}

function StatusBarItem_Get(this: StatusBarItem, ): (_: (_: StatusBarItemState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "StatusBarItem.appzObjPropsGet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: StatusBarItemState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: StatusBarItemState
        if ((undefined !== payload && null !== payload)) {
            result = newStatusBarItemState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: StatusBarItemState) => void): void => {
        onret = a0
    }
}

function StatusBarItem_Set(this: StatusBarItem, allUpdates: StatusBarItemState): (_: () => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "StatusBarItem.appzObjPropsSet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    msg.Data["allUpdates"] = allUpdates
    let onresp: (_: any) => boolean
    let onret: () => void
    onresp = (payload: any): boolean => {
        if ((undefined !== payload && null !== payload)) {
            return false
        }
        if ((undefined !== onret && null !== onret)) {
            onret()
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: () => void): void => {
        onret = a0
    }
}

function OutputChannel_Append(this: OutputChannel, value: string): (_: (_: OutputChannelState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "OutputChannel.append"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    msg.Data["value"] = value
    let onresp: (_: any) => boolean
    let onret: (_: OutputChannelState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: OutputChannelState
        if ((undefined !== payload && null !== payload)) {
            result = newOutputChannelState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: OutputChannelState) => void): void => {
        onret = a0
    }
}

function OutputChannel_AppendLine(this: OutputChannel, value: string): (_: (_: OutputChannelState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "OutputChannel.appendLine"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    msg.Data["value"] = value
    let onresp: (_: any) => boolean
    let onret: (_: OutputChannelState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: OutputChannelState
        if ((undefined !== payload && null !== payload)) {
            result = newOutputChannelState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: OutputChannelState) => void): void => {
        onret = a0
    }
}

function OutputChannel_Clear(this: OutputChannel, ): (_: (_: OutputChannelState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "OutputChannel.clear"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: OutputChannelState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: OutputChannelState
        if ((undefined !== payload && null !== payload)) {
            result = newOutputChannelState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: OutputChannelState) => void): void => {
        onret = a0
    }
}

function OutputChannel_Show(this: OutputChannel, preserveFocus?: boolean): (_: (_: OutputChannelState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "OutputChannel.show"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    msg.Data["preserveFocus"] = preserveFocus
    let onresp: (_: any) => boolean
    let onret: (_: OutputChannelState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: OutputChannelState
        if ((undefined !== payload && null !== payload)) {
            result = newOutputChannelState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: OutputChannelState) => void): void => {
        onret = a0
    }
}

function OutputChannel_Hide(this: OutputChannel, ): (_: (_: OutputChannelState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "OutputChannel.hide"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: OutputChannelState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: OutputChannelState
        if ((undefined !== payload && null !== payload)) {
            result = newOutputChannelState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: OutputChannelState) => void): void => {
        onret = a0
    }
}

function OutputChannel_Dispose(this: OutputChannel, ): (_: () => void) => void {
    return this.disp.Dispose()
}

function OutputChannel_Get(this: OutputChannel, ): (_: (_: OutputChannelState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "OutputChannel.appzObjPropsGet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: OutputChannelState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: OutputChannelState
        if ((undefined !== payload && null !== payload)) {
            result = newOutputChannelState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: OutputChannelState) => void): void => {
        onret = a0
    }
}

function TextEditorDecorationType_Dispose(this: TextEditorDecorationType, ): (_: () => void) => void {
    return this.disp.Dispose()
}

function TextEditorDecorationType_Get(this: TextEditorDecorationType, ): (_: (_: TextEditorDecorationTypeState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "TextEditorDecorationType.appzObjPropsGet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: TextEditorDecorationTypeState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: TextEditorDecorationTypeState
        if ((undefined !== payload && null !== payload)) {
            result = newTextEditorDecorationTypeState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: TextEditorDecorationTypeState) => void): void => {
        onret = a0
    }
}

function InputBox_OnDidChangeValue(this: InputBox, handler: (_: string, __: InputBoxState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.onDidChangeValue"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "InputBox.OnDidChangeValue: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (2 !== args.length) {
            return ok
        }
        let _a_0_: string
        [_a_0_, ok] = [args[0] as string, typeof args[0] === "string"]
        if (!ok) {
            return false
        }
        let _a_1_: InputBoxState
        _a_1_ = newInputBoxState()
        ok = _a_1_.populateFrom(args[1])
        if (!ok) {
            return false
        }
        handler(_a_0_, _a_1_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function InputBox_OnDidAccept(this: InputBox, handler: (_: InputBoxState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.onDidAccept"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "InputBox.OnDidAccept: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (1 !== args.length) {
            return ok
        }
        let _a_0_: InputBoxState
        _a_0_ = newInputBoxState()
        ok = _a_0_.populateFrom(args[0])
        if (!ok) {
            return false
        }
        handler(_a_0_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function InputBox_OnDidTriggerButton(this: InputBox, handler: (_: QuickInputButton, __: InputBoxState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.onDidTriggerButton"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "InputBox.OnDidTriggerButton: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (2 !== args.length) {
            return ok
        }
        let _a_0_: QuickInputButton
        _a_0_ = newQuickInputButton()
        ok = _a_0_.populateFrom(args[0])
        if (!ok) {
            return false
        }
        let _a_1_: InputBoxState
        _a_1_ = newInputBoxState()
        ok = _a_1_.populateFrom(args[1])
        if (!ok) {
            return false
        }
        handler(_a_0_, _a_1_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function InputBox_Show(this: InputBox, ): (_: (_: InputBoxState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.show"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: InputBoxState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: InputBoxState
        if ((undefined !== payload && null !== payload)) {
            result = newInputBoxState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: InputBoxState) => void): void => {
        onret = a0
    }
}

function InputBox_Hide(this: InputBox, ): (_: (_: InputBoxState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.hide"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: InputBoxState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: InputBoxState
        if ((undefined !== payload && null !== payload)) {
            result = newInputBoxState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: InputBoxState) => void): void => {
        onret = a0
    }
}

function InputBox_OnDidHide(this: InputBox, handler: (_: InputBoxState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.onDidHide"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "InputBox.OnDidHide: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (1 !== args.length) {
            return ok
        }
        let _a_0_: InputBoxState
        _a_0_ = newInputBoxState()
        ok = _a_0_.populateFrom(args[0])
        if (!ok) {
            return false
        }
        handler(_a_0_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function InputBox_Dispose(this: InputBox, ): (_: () => void) => void {
    return this.disp.Dispose()
}

function InputBox_Get(this: InputBox, ): (_: (_: InputBoxState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.appzObjPropsGet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: InputBoxState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: InputBoxState
        if ((undefined !== payload && null !== payload)) {
            result = newInputBoxState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: InputBoxState) => void): void => {
        onret = a0
    }
}

function InputBox_Set(this: InputBox, allUpdates: InputBoxState): (_: () => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "InputBox.appzObjPropsSet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    msg.Data["allUpdates"] = allUpdates
    let onresp: (_: any) => boolean
    let onret: () => void
    onresp = (payload: any): boolean => {
        if ((undefined !== payload && null !== payload)) {
            return false
        }
        if ((undefined !== onret && null !== onret)) {
            onret()
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: () => void): void => {
        onret = a0
    }
}

function QuickPick_OnDidChangeValue(this: QuickPick, handler: (_: string, __: QuickPickState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.onDidChangeValue"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "QuickPick.OnDidChangeValue: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (2 !== args.length) {
            return ok
        }
        let _a_0_: string
        [_a_0_, ok] = [args[0] as string, typeof args[0] === "string"]
        if (!ok) {
            return false
        }
        let _a_1_: QuickPickState
        _a_1_ = newQuickPickState()
        ok = _a_1_.populateFrom(args[1])
        if (!ok) {
            return false
        }
        handler(_a_0_, _a_1_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function QuickPick_OnDidAccept(this: QuickPick, handler: (_: QuickPickState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.onDidAccept"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "QuickPick.OnDidAccept: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (1 !== args.length) {
            return ok
        }
        let _a_0_: QuickPickState
        _a_0_ = newQuickPickState()
        ok = _a_0_.populateFrom(args[0])
        if (!ok) {
            return false
        }
        handler(_a_0_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function QuickPick_OnDidChangeActive(this: QuickPick, handler: (_: QuickPickItem[], __: QuickPickState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.onDidChangeActive"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "QuickPick.OnDidChangeActive: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (2 !== args.length) {
            return ok
        }
        let _a_0_: QuickPickItem[]
        let __coll___a_0_: any[]
        [__coll___a_0_, ok] = [args[0] as any[], (typeof args[0] === "object") && (typeof args[0]["length"] === "number")]
        if (!ok) {
            return false
        }
        _a_0_ = new Array(__coll___a_0_.length)
        let __idx___a_0_: number
        __idx___a_0_ = 0
        for (const __item___a_0_ of __coll___a_0_) {
            let __val___a_0_: QuickPickItem
            __val___a_0_ = newQuickPickItem()
            ok = __val___a_0_.populateFrom(__item___a_0_)
            if (!ok) {
                return false
            }
            _a_0_[__idx___a_0_] = __val___a_0_
            __idx___a_0_ = __idx___a_0_ + 1
        }
        let _a_1_: QuickPickState
        _a_1_ = newQuickPickState()
        ok = _a_1_.populateFrom(args[1])
        if (!ok) {
            return false
        }
        handler(_a_0_, _a_1_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function QuickPick_OnDidChangeSelection(this: QuickPick, handler: (_: QuickPickItem[], __: QuickPickState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.onDidChangeSelection"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "QuickPick.OnDidChangeSelection: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (2 !== args.length) {
            return ok
        }
        let _a_0_: QuickPickItem[]
        let __coll___a_0_: any[]
        [__coll___a_0_, ok] = [args[0] as any[], (typeof args[0] === "object") && (typeof args[0]["length"] === "number")]
        if (!ok) {
            return false
        }
        _a_0_ = new Array(__coll___a_0_.length)
        let __idx___a_0_: number
        __idx___a_0_ = 0
        for (const __item___a_0_ of __coll___a_0_) {
            let __val___a_0_: QuickPickItem
            __val___a_0_ = newQuickPickItem()
            ok = __val___a_0_.populateFrom(__item___a_0_)
            if (!ok) {
                return false
            }
            _a_0_[__idx___a_0_] = __val___a_0_
            __idx___a_0_ = __idx___a_0_ + 1
        }
        let _a_1_: QuickPickState
        _a_1_ = newQuickPickState()
        ok = _a_1_.populateFrom(args[1])
        if (!ok) {
            return false
        }
        handler(_a_0_, _a_1_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function QuickPick_Show(this: QuickPick, ): (_: (_: QuickPickState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.show"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: QuickPickState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: QuickPickState
        if ((undefined !== payload && null !== payload)) {
            result = newQuickPickState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: QuickPickState) => void): void => {
        onret = a0
    }
}

function QuickPick_Hide(this: QuickPick, ): (_: (_: QuickPickState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.hide"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: QuickPickState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: QuickPickState
        if ((undefined !== payload && null !== payload)) {
            result = newQuickPickState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: QuickPickState) => void): void => {
        onret = a0
    }
}

function QuickPick_OnDidHide(this: QuickPick, handler: (_: QuickPickState) => void): (_: (_: Disposable) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.onDidHide"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let _fnid_handler: string
    if ((undefined === handler || null === handler)) {
        OnError(this.disp.impl, "QuickPick.OnDidHide: the 'handler' arg (which is not optional but required) was not passed by the caller", null)
        return null
    }
    _fnid_handler = this.disp.impl.nextSub((args: any[]): boolean => {
        let ok: boolean
        if (1 !== args.length) {
            return ok
        }
        let _a_0_: QuickPickState
        _a_0_ = newQuickPickState()
        ok = _a_0_.populateFrom(args[0])
        if (!ok) {
            return false
        }
        handler(_a_0_)
        return true
    }, null)
    msg.Data["handler"] = _fnid_handler
    this.disp.addSub(_fnid_handler)
    let onresp: (_: any) => boolean
    let onret: (_: Disposable) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: Disposable
        if ((undefined !== payload && null !== payload)) {
            result = newDisposable()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        } else {
            return false
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result.bind(this.disp.impl, _fnid_handler))
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: Disposable) => void): void => {
        onret = a0
    }
}

function QuickPick_Dispose(this: QuickPick, ): (_: () => void) => void {
    return this.disp.Dispose()
}

function QuickPick_Get(this: QuickPick, ): (_: (_: QuickPickState) => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.appzObjPropsGet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    let onresp: (_: any) => boolean
    let onret: (_: QuickPickState) => void
    onresp = (payload: any): boolean => {
        let ok: boolean
        let result: QuickPickState
        if ((undefined !== payload && null !== payload)) {
            result = newQuickPickState()
            ok = result.populateFrom(payload)
            if (!ok) {
                return false
            }
        }
        {
            if ((undefined !== onret && null !== onret)) {
                onret(result)
            }
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: (_: QuickPickState) => void): void => {
        onret = a0
    }
}

function QuickPick_Set(this: QuickPick, allUpdates: QuickPickState): (_: () => void) => void {
    let msg: ipcMsg
    msg = newipcMsg()
    msg.QName = "QuickPick.appzObjPropsSet"
    msg.Data = {}
    msg.Data[""] = this.disp.id
    msg.Data["allUpdates"] = allUpdates
    let onresp: (_: any) => boolean
    let onret: () => void
    onresp = (payload: any): boolean => {
        if ((undefined !== payload && null !== payload)) {
            return false
        }
        if ((undefined !== onret && null !== onret)) {
            onret()
        }
        return true
    }
    this.disp.impl.send(msg, onresp)
    return (a0: () => void): void => {
        onret = a0
    }
}

function MessageItem_populateFrom(this: MessageItem, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["title"], undefined !== it["title"]]
    if (ok) {
        let title: string
        if ((undefined !== val && null !== val)) {
            [title, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.title = title
    } else {
        return false
    }
    [val, ok] = [it["isCloseAffordance"], undefined !== it["isCloseAffordance"]]
    if (ok) {
        let isCloseAffordance: boolean
        if ((undefined !== val && null !== val)) {
            let _isCloseAffordance_: boolean
            [_isCloseAffordance_, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
            isCloseAffordance = _isCloseAffordance_
        }
        this.isCloseAffordance = isCloseAffordance
    }
    [val, ok] = [it["my"], undefined !== it["my"]]
    if (ok) {
        let my: { [_: string]: any }
        if ((undefined !== val && null !== val)) {
            [my, ok] = [val as { [_: string]: any }, typeof val === "object"]
            if (!ok) {
                return false
            }
        }
        this.my = my
    }
    return true
}

function QuickPickItem_populateFrom(this: QuickPickItem, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["label"], undefined !== it["label"]]
    if (ok) {
        let label: string
        if ((undefined !== val && null !== val)) {
            [label, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.label = label
    } else {
        return false
    }
    [val, ok] = [it["description"], undefined !== it["description"]]
    if (ok) {
        let description: string
        if ((undefined !== val && null !== val)) {
            let _description_: string
            [_description_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            description = _description_
        }
        this.description = description
    }
    [val, ok] = [it["detail"], undefined !== it["detail"]]
    if (ok) {
        let detail: string
        if ((undefined !== val && null !== val)) {
            let _detail_: string
            [_detail_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            detail = _detail_
        }
        this.detail = detail
    }
    [val, ok] = [it["picked"], undefined !== it["picked"]]
    if (ok) {
        let picked: boolean
        if ((undefined !== val && null !== val)) {
            let _picked_: boolean
            [_picked_, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
            picked = _picked_
        }
        this.picked = picked
    }
    [val, ok] = [it["alwaysShow"], undefined !== it["alwaysShow"]]
    if (ok) {
        let alwaysShow: boolean
        if ((undefined !== val && null !== val)) {
            let _alwaysShow_: boolean
            [_alwaysShow_, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
            alwaysShow = _alwaysShow_
        }
        this.alwaysShow = alwaysShow
    }
    [val, ok] = [it["my"], undefined !== it["my"]]
    if (ok) {
        let my: { [_: string]: any }
        if ((undefined !== val && null !== val)) {
            [my, ok] = [val as { [_: string]: any }, typeof val === "object"]
            if (!ok) {
                return false
            }
        }
        this.my = my
    }
    return true
}

function WorkspaceFolder_populateFrom(this: WorkspaceFolder, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["uri"], undefined !== it["uri"]]
    if (ok) {
        let uri: string
        if ((undefined !== val && null !== val)) {
            [uri, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.uri = uri
    } else {
        return false
    }
    [val, ok] = [it["name"], undefined !== it["name"]]
    if (ok) {
        let name: string
        if ((undefined !== val && null !== val)) {
            [name, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.name = name
    } else {
        return false
    }
    [val, ok] = [it["index"], undefined !== it["index"]]
    if (ok) {
        let index: number
        if ((undefined !== val && null !== val)) {
            [index, ok] = [val as number, typeof val === "number"]
            if (!ok) {
                let __index__: number
                [__index__, ok] = [val as number, typeof val === "number"]
                if (!ok) {
                    return false
                }
                index = __index__
            }
        }
        this.index = index
    } else {
        return false
    }
    return true
}

function WindowState_populateFrom(this: WindowState, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["focused"], undefined !== it["focused"]]
    if (ok) {
        let focused: boolean
        if ((undefined !== val && null !== val)) {
            [focused, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.focused = focused
    } else {
        return false
    }
    return true
}

function StatusBarItem_populateFrom(this: StatusBarItem, payload: any): boolean {
    let ok: boolean
    this.disp = newDisposable()
    ok = this.disp.populateFrom(payload)
    return ok
}

function OutputChannel_populateFrom(this: OutputChannel, payload: any): boolean {
    let ok: boolean
    this.disp = newDisposable()
    ok = this.disp.populateFrom(payload)
    return ok
}

function TextEditorDecorationType_populateFrom(this: TextEditorDecorationType, payload: any): boolean {
    let ok: boolean
    this.disp = newDisposable()
    ok = this.disp.populateFrom(payload)
    return ok
}

function InputBox_populateFrom(this: InputBox, payload: any): boolean {
    let ok: boolean
    this.disp = newDisposable()
    ok = this.disp.populateFrom(payload)
    return ok
}

function QuickPick_populateFrom(this: QuickPick, payload: any): boolean {
    let ok: boolean
    this.disp = newDisposable()
    ok = this.disp.populateFrom(payload)
    return ok
}

function EnvProperties_populateFrom(this: EnvProperties, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["appName"], undefined !== it["appName"]]
    if (ok) {
        let appName: string
        if ((undefined !== val && null !== val)) {
            let _appName_: string
            [_appName_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            appName = _appName_
        }
        this.appName = appName
    }
    [val, ok] = [it["appRoot"], undefined !== it["appRoot"]]
    if (ok) {
        let appRoot: string
        if ((undefined !== val && null !== val)) {
            let _appRoot_: string
            [_appRoot_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            appRoot = _appRoot_
        }
        this.appRoot = appRoot
    }
    [val, ok] = [it["language"], undefined !== it["language"]]
    if (ok) {
        let language: string
        if ((undefined !== val && null !== val)) {
            let _language_: string
            [_language_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            language = _language_
        }
        this.language = language
    }
    [val, ok] = [it["machineId"], undefined !== it["machineId"]]
    if (ok) {
        let machineId: string
        if ((undefined !== val && null !== val)) {
            let _machineId_: string
            [_machineId_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            machineId = _machineId_
        }
        this.machineId = machineId
    }
    [val, ok] = [it["remoteName"], undefined !== it["remoteName"]]
    if (ok) {
        let remoteName: string
        if ((undefined !== val && null !== val)) {
            let _remoteName_: string
            [_remoteName_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            remoteName = _remoteName_
        }
        this.remoteName = remoteName
    }
    [val, ok] = [it["sessionId"], undefined !== it["sessionId"]]
    if (ok) {
        let sessionId: string
        if ((undefined !== val && null !== val)) {
            let _sessionId_: string
            [_sessionId_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            sessionId = _sessionId_
        }
        this.sessionId = sessionId
    }
    [val, ok] = [it["shell"], undefined !== it["shell"]]
    if (ok) {
        let shell: string
        if ((undefined !== val && null !== val)) {
            let _shell_: string
            [_shell_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            shell = _shell_
        }
        this.shell = shell
    }
    [val, ok] = [it["uriScheme"], undefined !== it["uriScheme"]]
    if (ok) {
        let uriScheme: string
        if ((undefined !== val && null !== val)) {
            let _uriScheme_: string
            [_uriScheme_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            uriScheme = _uriScheme_
        }
        this.uriScheme = uriScheme
    }
    return true
}

function WorkspaceFoldersChangeEvent_populateFrom(this: WorkspaceFoldersChangeEvent, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["added"], undefined !== it["added"]]
    if (ok) {
        let added: WorkspaceFolder[]
        if ((undefined !== val && null !== val)) {
            let __coll__added: any[]
            [__coll__added, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            added = new Array(__coll__added.length)
            let __idx__added: number
            __idx__added = 0
            for (const __item__added of __coll__added) {
                let __val__added: WorkspaceFolder
                __val__added = newWorkspaceFolder()
                ok = __val__added.populateFrom(__item__added)
                if (!ok) {
                    return false
                }
                added[__idx__added] = __val__added
                __idx__added = __idx__added + 1
            }
        }
        this.added = added
    } else {
        return false
    }
    [val, ok] = [it["removed"], undefined !== it["removed"]]
    if (ok) {
        let removed: WorkspaceFolder[]
        if ((undefined !== val && null !== val)) {
            let __coll__removed: any[]
            [__coll__removed, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            removed = new Array(__coll__removed.length)
            let __idx__removed: number
            __idx__removed = 0
            for (const __item__removed of __coll__removed) {
                let __val__removed: WorkspaceFolder
                __val__removed = newWorkspaceFolder()
                ok = __val__removed.populateFrom(__item__removed)
                if (!ok) {
                    return false
                }
                removed[__idx__removed] = __val__removed
                __idx__removed = __idx__removed + 1
            }
        }
        this.removed = removed
    } else {
        return false
    }
    return true
}

function WorkspaceProperties_populateFrom(this: WorkspaceProperties, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["name"], undefined !== it["name"]]
    if (ok) {
        let name: string
        if ((undefined !== val && null !== val)) {
            let _name_: string
            [_name_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            name = _name_
        }
        this.name = name
    }
    [val, ok] = [it["workspaceFile"], undefined !== it["workspaceFile"]]
    if (ok) {
        let workspaceFile: string
        if ((undefined !== val && null !== val)) {
            let _workspaceFile_: string
            [_workspaceFile_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            workspaceFile = _workspaceFile_
        }
        this.workspaceFile = workspaceFile
    }
    [val, ok] = [it["workspaceFolders"], undefined !== it["workspaceFolders"]]
    if (ok) {
        let workspaceFolders: WorkspaceFolder[]
        if ((undefined !== val && null !== val)) {
            let __coll__workspaceFolders: any[]
            [__coll__workspaceFolders, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            workspaceFolders = new Array(__coll__workspaceFolders.length)
            let __idx__workspaceFolders: number
            __idx__workspaceFolders = 0
            for (const __item__workspaceFolders of __coll__workspaceFolders) {
                let __val__workspaceFolders: WorkspaceFolder
                __val__workspaceFolders = newWorkspaceFolder()
                ok = __val__workspaceFolders.populateFrom(__item__workspaceFolders)
                if (!ok) {
                    return false
                }
                workspaceFolders[__idx__workspaceFolders] = __val__workspaceFolders
                __idx__workspaceFolders = __idx__workspaceFolders + 1
            }
        }
        this.workspaceFolders = workspaceFolders
    }
    return true
}

function DiagnosticChangeEvent_populateFrom(this: DiagnosticChangeEvent, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["uris"], undefined !== it["uris"]]
    if (ok) {
        let uris: string[]
        if ((undefined !== val && null !== val)) {
            let __coll__uris: any[]
            [__coll__uris, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            uris = new Array(__coll__uris.length)
            let __idx__uris: number
            __idx__uris = 0
            for (const __item__uris of __coll__uris) {
                let __val__uris: string
                [__val__uris, ok] = [__item__uris as string, typeof __item__uris === "string"]
                if (!ok) {
                    return false
                }
                uris[__idx__uris] = __val__uris
                __idx__uris = __idx__uris + 1
            }
        }
        this.uris = uris
    } else {
        return false
    }
    return true
}

function StatusBarItemState_populateFrom(this: StatusBarItemState, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["alignment"], undefined !== it["alignment"]]
    if (ok) {
        let alignment: StatusBarAlignment
        if ((undefined !== val && null !== val)) {
            let i_alignment: number
            [i_alignment, ok] = [val as number, typeof val === "number"]
            if (!ok) {
                let __i_alignment__: number
                [__i_alignment__, ok] = [val as number, typeof val === "number"]
                if (!ok) {
                    return false
                }
                i_alignment = __i_alignment__
            }
            alignment = i_alignment
        }
        this.Alignment = (): StatusBarAlignment => {
            return alignment
        }
    }
    [val, ok] = [it["priority"], undefined !== it["priority"]]
    if (ok) {
        let priority: number
        if ((undefined !== val && null !== val)) {
            [priority, ok] = [val as number, typeof val === "number"]
            if (!ok) {
                let __priority__: number
                [__priority__, ok] = [val as number, typeof val === "number"]
                if (!ok) {
                    return false
                }
                priority = __priority__
            }
        }
        this.Priority = (): number => {
            return priority
        }
    }
    [val, ok] = [it["text"], undefined !== it["text"]]
    if (ok) {
        let text: string
        if ((undefined !== val && null !== val)) {
            [text, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.text = text
    }
    [val, ok] = [it["tooltip"], undefined !== it["tooltip"]]
    if (ok) {
        let tooltip: string
        if ((undefined !== val && null !== val)) {
            [tooltip, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.tooltip = tooltip
    }
    [val, ok] = [it["color"], undefined !== it["color"]]
    if (ok) {
        let color: string
        if ((undefined !== val && null !== val)) {
            [color, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.color = color
    }
    [val, ok] = [it["command"], undefined !== it["command"]]
    if (ok) {
        let command: string
        if ((undefined !== val && null !== val)) {
            [command, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.command = command
    }
    return true
}

function OutputChannelState_populateFrom(this: OutputChannelState, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["name"], undefined !== it["name"]]
    if (ok) {
        let name: string
        if ((undefined !== val && null !== val)) {
            [name, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.Name = (): string => {
            return name
        }
    }
    return true
}

function TextEditorDecorationTypeState_populateFrom(this: TextEditorDecorationTypeState, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["key"], undefined !== it["key"]]
    if (ok) {
        let key: string
        if ((undefined !== val && null !== val)) {
            [key, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.Key = (): string => {
            return key
        }
    }
    return true
}

function InputBoxState_populateFrom(this: InputBoxState, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["value"], undefined !== it["value"]]
    if (ok) {
        let value: string
        if ((undefined !== val && null !== val)) {
            [value, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.value = value
    }
    [val, ok] = [it["placeholder"], undefined !== it["placeholder"]]
    if (ok) {
        let placeholder: string
        if ((undefined !== val && null !== val)) {
            [placeholder, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.placeholder = placeholder
    }
    [val, ok] = [it["password"], undefined !== it["password"]]
    if (ok) {
        let password: boolean
        if ((undefined !== val && null !== val)) {
            [password, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.password = password
    }
    [val, ok] = [it["buttons"], undefined !== it["buttons"]]
    if (ok) {
        let buttons: QuickInputButton[]
        if ((undefined !== val && null !== val)) {
            let __coll__buttons: any[]
            [__coll__buttons, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            buttons = new Array(__coll__buttons.length)
            let __idx__buttons: number
            __idx__buttons = 0
            for (const __item__buttons of __coll__buttons) {
                let __val__buttons: QuickInputButton
                __val__buttons = newQuickInputButton()
                ok = __val__buttons.populateFrom(__item__buttons)
                if (!ok) {
                    return false
                }
                buttons[__idx__buttons] = __val__buttons
                __idx__buttons = __idx__buttons + 1
            }
        }
        this.buttons = buttons
    }
    [val, ok] = [it["prompt"], undefined !== it["prompt"]]
    if (ok) {
        let prompt: string
        if ((undefined !== val && null !== val)) {
            [prompt, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.prompt = prompt
    }
    [val, ok] = [it["validationMessage"], undefined !== it["validationMessage"]]
    if (ok) {
        let validationMessage: string
        if ((undefined !== val && null !== val)) {
            [validationMessage, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.validationMessage = validationMessage
    }
    [val, ok] = [it["title"], undefined !== it["title"]]
    if (ok) {
        let title: string
        if ((undefined !== val && null !== val)) {
            [title, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.title = title
    }
    [val, ok] = [it["step"], undefined !== it["step"]]
    if (ok) {
        let step: number
        if ((undefined !== val && null !== val)) {
            let _step_: number
            [_step_, ok] = [val as number, typeof val === "number"]
            if (!ok) {
                return false
            }
            step = _step_
        }
        this.step = step
    }
    [val, ok] = [it["totalSteps"], undefined !== it["totalSteps"]]
    if (ok) {
        let totalSteps: number
        if ((undefined !== val && null !== val)) {
            let _totalSteps_: number
            [_totalSteps_, ok] = [val as number, typeof val === "number"]
            if (!ok) {
                return false
            }
            totalSteps = _totalSteps_
        }
        this.totalSteps = totalSteps
    }
    [val, ok] = [it["enabled"], undefined !== it["enabled"]]
    if (ok) {
        let enabled: boolean
        if ((undefined !== val && null !== val)) {
            [enabled, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.enabled = enabled
    }
    [val, ok] = [it["busy"], undefined !== it["busy"]]
    if (ok) {
        let busy: boolean
        if ((undefined !== val && null !== val)) {
            [busy, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.busy = busy
    }
    [val, ok] = [it["ignoreFocusOut"], undefined !== it["ignoreFocusOut"]]
    if (ok) {
        let ignoreFocusOut: boolean
        if ((undefined !== val && null !== val)) {
            [ignoreFocusOut, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.ignoreFocusOut = ignoreFocusOut
    }
    return true
}

function QuickInputButton_populateFrom(this: QuickInputButton, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["iconPath"], undefined !== it["iconPath"]]
    if (ok) {
        let iconPath: string
        if ((undefined !== val && null !== val)) {
            [iconPath, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.iconPath = iconPath
    } else {
        return false
    }
    [val, ok] = [it["tooltip"], undefined !== it["tooltip"]]
    if (ok) {
        let tooltip: string
        if ((undefined !== val && null !== val)) {
            let _tooltip_: string
            [_tooltip_, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
            tooltip = _tooltip_
        }
        this.tooltip = tooltip
    }
    [val, ok] = [it["my"], undefined !== it["my"]]
    if (ok) {
        let my: { [_: string]: any }
        if ((undefined !== val && null !== val)) {
            [my, ok] = [val as { [_: string]: any }, typeof val === "object"]
            if (!ok) {
                return false
            }
        }
        this.my = my
    }
    return true
}

function QuickPickState_populateFrom(this: QuickPickState, payload: any): boolean {
    let it: { [_: string]: any }
    let ok: boolean
    let val: any
    [it, ok] = [payload as { [_: string]: any }, typeof payload === "object"]
    if (!ok) {
        return false
    }
    [val, ok] = [it["value"], undefined !== it["value"]]
    if (ok) {
        let value: string
        if ((undefined !== val && null !== val)) {
            [value, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.value = value
    }
    [val, ok] = [it["placeholder"], undefined !== it["placeholder"]]
    if (ok) {
        let placeholder: string
        if ((undefined !== val && null !== val)) {
            [placeholder, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.placeholder = placeholder
    }
    [val, ok] = [it["items"], undefined !== it["items"]]
    if (ok) {
        let items: QuickPickItem[]
        if ((undefined !== val && null !== val)) {
            let __coll__items: any[]
            [__coll__items, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            items = new Array(__coll__items.length)
            let __idx__items: number
            __idx__items = 0
            for (const __item__items of __coll__items) {
                let __val__items: QuickPickItem
                __val__items = newQuickPickItem()
                ok = __val__items.populateFrom(__item__items)
                if (!ok) {
                    return false
                }
                items[__idx__items] = __val__items
                __idx__items = __idx__items + 1
            }
        }
        this.items = items
    }
    [val, ok] = [it["canSelectMany"], undefined !== it["canSelectMany"]]
    if (ok) {
        let canSelectMany: boolean
        if ((undefined !== val && null !== val)) {
            [canSelectMany, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.canSelectMany = canSelectMany
    }
    [val, ok] = [it["matchOnDescription"], undefined !== it["matchOnDescription"]]
    if (ok) {
        let matchOnDescription: boolean
        if ((undefined !== val && null !== val)) {
            [matchOnDescription, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.matchOnDescription = matchOnDescription
    }
    [val, ok] = [it["matchOnDetail"], undefined !== it["matchOnDetail"]]
    if (ok) {
        let matchOnDetail: boolean
        if ((undefined !== val && null !== val)) {
            [matchOnDetail, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.matchOnDetail = matchOnDetail
    }
    [val, ok] = [it["activeItems"], undefined !== it["activeItems"]]
    if (ok) {
        let activeItems: QuickPickItem[]
        if ((undefined !== val && null !== val)) {
            let __coll__activeItems: any[]
            [__coll__activeItems, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            activeItems = new Array(__coll__activeItems.length)
            let __idx__activeItems: number
            __idx__activeItems = 0
            for (const __item__activeItems of __coll__activeItems) {
                let __val__activeItems: QuickPickItem
                __val__activeItems = newQuickPickItem()
                ok = __val__activeItems.populateFrom(__item__activeItems)
                if (!ok) {
                    return false
                }
                activeItems[__idx__activeItems] = __val__activeItems
                __idx__activeItems = __idx__activeItems + 1
            }
        }
        this.activeItems = activeItems
    }
    [val, ok] = [it["selectedItems"], undefined !== it["selectedItems"]]
    if (ok) {
        let selectedItems: QuickPickItem[]
        if ((undefined !== val && null !== val)) {
            let __coll__selectedItems: any[]
            [__coll__selectedItems, ok] = [val as any[], (typeof val === "object") && (typeof val["length"] === "number")]
            if (!ok) {
                return false
            }
            selectedItems = new Array(__coll__selectedItems.length)
            let __idx__selectedItems: number
            __idx__selectedItems = 0
            for (const __item__selectedItems of __coll__selectedItems) {
                let __val__selectedItems: QuickPickItem
                __val__selectedItems = newQuickPickItem()
                ok = __val__selectedItems.populateFrom(__item__selectedItems)
                if (!ok) {
                    return false
                }
                selectedItems[__idx__selectedItems] = __val__selectedItems
                __idx__selectedItems = __idx__selectedItems + 1
            }
        }
        this.selectedItems = selectedItems
    }
    [val, ok] = [it["title"], undefined !== it["title"]]
    if (ok) {
        let title: string
        if ((undefined !== val && null !== val)) {
            [title, ok] = [val as string, typeof val === "string"]
            if (!ok) {
                return false
            }
        }
        this.title = title
    }
    [val, ok] = [it["step"], undefined !== it["step"]]
    if (ok) {
        let step: number
        if ((undefined !== val && null !== val)) {
            let _step_: number
            [_step_, ok] = [val as number, typeof val === "number"]
            if (!ok) {
                return false
            }
            step = _step_
        }
        this.step = step
    }
    [val, ok] = [it["totalSteps"], undefined !== it["totalSteps"]]
    if (ok) {
        let totalSteps: number
        if ((undefined !== val && null !== val)) {
            let _totalSteps_: number
            [_totalSteps_, ok] = [val as number, typeof val === "number"]
            if (!ok) {
                return false
            }
            totalSteps = _totalSteps_
        }
        this.totalSteps = totalSteps
    }
    [val, ok] = [it["enabled"], undefined !== it["enabled"]]
    if (ok) {
        let enabled: boolean
        if ((undefined !== val && null !== val)) {
            [enabled, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.enabled = enabled
    }
    [val, ok] = [it["busy"], undefined !== it["busy"]]
    if (ok) {
        let busy: boolean
        if ((undefined !== val && null !== val)) {
            [busy, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.busy = busy
    }
    [val, ok] = [it["ignoreFocusOut"], undefined !== it["ignoreFocusOut"]]
    if (ok) {
        let ignoreFocusOut: boolean
        if ((undefined !== val && null !== val)) {
            [ignoreFocusOut, ok] = [val as boolean, typeof val === "boolean"]
            if (!ok) {
                return false
            }
        }
        this.ignoreFocusOut = ignoreFocusOut
    }
    return true
}

