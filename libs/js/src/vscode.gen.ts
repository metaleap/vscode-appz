// DO NOT EDIT: generated by github.com/metaleap/vscode-appz/src/gen/gen-nodesjs.ts via github.com/metaleap/vscode-appz/src/gen/main.ts
import { ipcMsg } from './aux'

/**
 * Type Definition for Visual Studio Code 1.38 Extension API
 * See https://code.visualstudio.com/api for more information

 */
export interface Vscode {
    /**
     * Namespace for dealing with the current window of the editor. That is visible
     * and active editors, as well as, UI elements to show messages, selections, and
     * asking for user input.

     */
    Window: Window

    /**
     * Namespace describing the environment the editor runs in.

     */
    Env: Env

    /**
     * Namespace for dealing with the current workspace. A workspace is the representation
     * of the folder that has been opened. There is no workspace when just a file but not a
     * folder has been opened.
     * 
     * The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
     * events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
     * the editor-process so that they should be always used instead of nodejs-equivalents.

     */
    Workspace: Workspace

    /**
     * Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
     * like IntelliSense, code actions, diagnostics etc.
     * 
     * Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
     * like automatic word-completion, code navigation, or code checking have become popular across different tools for different
     * programming languages.
     * 
     * The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
     * by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
     * that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
     * mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
     * 
     * ```javascript
     * languages.registerHoverProvider('javascript', {
     *  	provideHover(document, position, token) {
     *  		return new Hover('I am a hover!');
     *  	}
     * });
     * ```
     * 
     * Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
     * a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
     * a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
     * scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
     * the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
     * score is used for determining the order in which providers are asked to participate.

     */
    Languages: Languages

    /**
     * Namespace for dealing with installed extensions. Extensions are represented
     * by an [extension](#Extension)-interface which enables reflection on them.
     * 
     * Extension writers can provide APIs to other extensions by returning their API public
     * surface from the `activate`-call.
     * 
     * ```javascript
     * export function activate(context: vscode.ExtensionContext) {
     *  	let api = {
     *  		sum(a, b) {
     *  			return a + b;
     *  		},
     *  		mul(a, b) {
     *  			return a * b;
     *  		}
     *  	};
     *  	// 'export' public api-surface
     *  	return api;
     * }
     * ```
     * When depending on the API of another extension add an `extensionDependency`-entry
     * to `package.json`, and use the [getExtension](#extensions.getExtension)-function
     * and the [exports](#Extension.exports)-property, like below:
     * 
     * ```javascript
     * let mathExt = extensions.getExtension('genius.math');
     * let importedApi = mathExt.exports;
     * 
     * console.log(importedApi.mul(42, 1));
     * ```

     */
    Extensions: Extensions

    /**
     * Namespace for dealing with commands. In short, a command is a function with a
     * unique identifier. The function is sometimes also called _command handler_.
     * 
     * Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
     * and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
     * can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
     * 
     * * palette - Use the `commands`-section in `package.json` to make a command show in
     * the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
     * * keybinding - Use the `keybindings`-section in `package.json` to enable
     * [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
     * for your extension.
     * 
     * Commands from other extensions and from the editor itself are accessible to an extension. However,
     * when invoking an editor command not all argument types are supported.
     * 
     * This is a sample that registers a command handler and adds an entry for that command to the palette. First
     * register a command handler with the identifier `extension.sayHello`.
     * ```javascript
     * commands.registerCommand('extension.sayHello', () => {
     *  	window.showInformationMessage('Hello World!');
     * });
     * ```
     * Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
     * ```json
     * {
     *  	"contributes": {
     *  		"commands": [{
     *  			"command": "extension.sayHello",
     *  			"title": "Hello World"
     *  		}]
     *  	}
     * }
     * ```

     */
    Commands: Commands
}

/**
 * Namespace for dealing with the current window of the editor. That is visible
 * and active editors, as well as, UI elements to show messages, selections, and
 * asking for user input.

 */
export interface Window {
    /**
     * Show an information message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage1: (message: string, items: string[], then?: (_: string) => void) => void

    /**
     * Show an information message to users. Optionally provide an array of items which will be presented as
     * clickable buttons.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage2: (message: string, options: MessageOptions, items: string[], then?: (_: string) => void) => void

    /**
     * Show an information message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage3: (message: string, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show an information message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowInformationMessage4: (message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage1: (message: string, items: string[], then?: (_: string) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage2: (message: string, options: MessageOptions, items: string[], then?: (_: string) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage3: (message: string, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show a warning message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowWarningMessage4: (message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage1: (message: string, items: string[], then?: (_: string) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage2: (message: string, options: MessageOptions, items: string[], then?: (_: string) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage3: (message: string, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Show an error message.

     * @param message The message to show.
     * @param options Configures the behaviour of the message.
     * @param items A set of items that will be rendered as actions in the message.
     * @param then A thenable that resolves to the selected item or `undefined` when being dismissed.
     */
    ShowErrorMessage4: (message: string, options: MessageOptions, items: MessageItem[], then?: (_: MessageItem) => void) => void

    /**
     * Opens an input box to ask the user for input.
     * 
     * The returned value will be `undefined` if the input box was canceled (e.g. pressing ESC). Otherwise the
     * returned value will be the string typed by the user or an empty string if the user did not type
     * anything but dismissed the input box with OK.

     * @param options Configures the behavior of the input box.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to a string the user provided or to `undefined` in case of dismissal.
     */
    ShowInputBox: (options?: InputBoxOptions, token?: Cancel, then?: (_: string) => void) => void

    /**
     * Shows a selection list allowing multiple selections.

     * @param items An array of strings, or a promise that resolves to an array of strings.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selected items or `undefined`.
     */
    ShowQuickPick1: (items: string[], options: QuickPickOptions, token?: Cancel, then?: (_: string[]) => void) => void

    /**
     * Shows a selection list.

     * @param items An array of strings, or a promise that resolves to an array of strings.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selection or `undefined`.
     */
    ShowQuickPick2: (items: string[], options?: QuickPickOptions, token?: Cancel, then?: (_: string) => void) => void

    /**
     * Shows a selection list allowing multiple selections.

     * @param items An array of items, or a promise that resolves to an array of items.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selected items or `undefined`.
     */
    ShowQuickPick3: (items: QuickPickItem[], options: QuickPickOptions, token?: Cancel, then?: (_: QuickPickItem[]) => void) => void

    /**
     * Shows a selection list.

     * @param items An array of items, or a promise that resolves to an array of items.
     * @param options Configures the behavior of the selection list.
     * @param token A token that can be used to signal cancellation.
     * @param then A promise that resolves to the selected item or `undefined`.
     */
    ShowQuickPick4: (items: QuickPickItem[], options?: QuickPickOptions, token?: Cancel, then?: (_: QuickPickItem) => void) => void

    /**
     * Set a message to the status bar. This is a short hand for the more powerful
     * status bar [items](#window.createStatusBarItem).

     * @param text The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
     * @param hideAfterTimeout Timeout in milliseconds after which the message will be disposed.
     * @param then A disposable which hides the status bar message.
     */
    SetStatusBarMessage1: (text: string, hideAfterTimeout: number, then?: (_: Disposable) => void) => void

    /**
     * Set a message to the status bar. This is a short hand for the more powerful
     * status bar [items](#window.createStatusBarItem).
     * 
     * *Note* that status bar messages stack and that they must be disposed when no
     * longer used.

     * @param text The message to show, supports icon substitution as in status bar [items](#StatusBarItem.text).
     * @param then A disposable which hides the status bar message.
     */
    SetStatusBarMessage2: (text: string, then?: (_: Disposable) => void) => void

    /**
     * Shows a file save dialog to the user which allows to select a file
     * for saving-purposes.

     * @param options Options that control the dialog.
     * @param then A promise that resolves to the selected resource or `undefined`.
     */
    ShowSaveDialog: (options: SaveDialogOptions, then?: (_: string) => void) => void

    /**
     * Shows a file open dialog to the user which allows to select a file
     * for opening-purposes.

     * @param options Options that control the dialog.
     * @param then A promise that resolves to the selected resources or `undefined`.
     */
    ShowOpenDialog: (options: OpenDialogOptions, then?: (_: string[]) => void) => void

    /**
     * Shows a selection list of [workspace folders](#workspace.workspaceFolders) to pick from.
     * Returns `undefined` if no folder is open.

     * @param options Configures the behavior of the workspace folder list.
     * @param then A promise that resolves to the workspace folder or `undefined`.
     */
    ShowWorkspaceFolderPick: (options?: WorkspaceFolderPickOptions, then?: (_: WorkspaceFolder) => void) => void

    /**
     * Represents the current window's state.

     */
    State: (then?: (_: WindowState) => void) => void

    /**
     * An [event](#Event) which fires when the focus state of the current window
     * changes. The value of the event represents whether the window is focused.

     */
    OnDidChangeWindowState: (listener: (_: WindowState) => void, then?: (_: Disposable) => void) => void
}

/**
 * Namespace describing the environment the editor runs in.

 */
export interface Env {
    /**
     * Opens an *external* item, e.g. a http(s) or mailto-link, using the
     * default application.
     * 
     * *Note* that [`showTextDocument`](#window.showTextDocument) is the right
     * way to open a text document inside the editor, not this function.

     * @param target The uri that should be opened.
     * @param then A promise indicating if open was successful.
     */
    OpenExternal: (target: string, then?: (_: boolean) => void) => void

    /**
     * The application name of the editor, like 'VS Code'.

     */
    AppName: (then?: (_: string) => void) => void

    /**
     * The application root folder from which the editor is running.

     */
    AppRoot: (then?: (_: string) => void) => void

    /**
     * Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.

     */
    Language: (then?: (_: string) => void) => void

    /**
     * A unique identifier for the computer.

     */
    MachineId: (then?: (_: string) => void) => void

    /**
     * The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
     * Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
     * 
     * *Note* that the value is `undefined` when there is no remote extension host but that the
     * value is defined in all extension hosts (local and remote) in case a remote extension host
     * exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
     * a specific extension runs remote or not.

     */
    RemoteName: (then?: (_: string) => void) => void

    /**
     * A unique identifier for the current session.
     * Changes each time the editor is started.

     */
    SessionId: (then?: (_: string) => void) => void

    /**
     * The detected default shell for the extension host, this is overridden by the
     * `terminal.integrated.shell` setting for the extension host's platform.

     */
    Shell: (then?: (_: string) => void) => void

    /**
     * The custom uri scheme the editor registers to in the operating system.

     */
    UriScheme: (then?: (_: string) => void) => void

    /**
     * Provides single-call access to numerous individual `Env` properties at once.

     */
    Properties: (then: (_: EnvProperties) => void) => void
}

/**
 * Namespace for dealing with the current workspace. A workspace is the representation
 * of the folder that has been opened. There is no workspace when just a file but not a
 * folder has been opened.
 * 
 * The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
 * events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
 * the editor-process so that they should be always used instead of nodejs-equivalents.

 */
export interface Workspace {
    /**
     * The name of the workspace. `undefined` when no folder
     * has been opened.

     */
    Name: (then?: (_: string) => void) => void

    /**
     * The location of the workspace file, for example:
     * 
     * `file:///Users/name/Development/myProject.code-workspace`
     * 
     * or
     * 
     * `untitled:1555503116870`
     * 
     * for a workspace that is untitled and not yet saved.
     * 
     * Depending on the workspace that is opened, the value will be:
     *   * `undefined` when no workspace or  a single folder is opened
     *   * the path of the workspace file as `Uri` otherwise. if the workspace
     * is untitled, the returned URI will use the `untitled:` scheme
     * 
     * The location can e.g. be used with the `vscode.openFolder` command to
     * open the workspace again after it has been closed.
     * 
     * **Example:**
     * ```typescript
     * vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
     * ```
     * 
     * **Note:** it is not advised to use `workspace.workspaceFile` to write
     * configuration data into the file. You can use `workspace.getConfiguration().update()`
     * for that purpose which will work both when a single folder is opened as
     * well as an untitled or saved workspace.

     */
    WorkspaceFile: (then?: (_: string) => void) => void

    /**
     * Save all dirty files.

     * @param includeUntitled Also save files that have been created during this session.
     * @param then A thenable that resolves when the files have been saved.
     */
    SaveAll: (includeUntitled: boolean, then?: (_: boolean) => void) => void

    /**
     * An event that is emitted when a workspace folder is added or removed.

     */
    OnDidChangeWorkspaceFolders: (listener: (_: WorkspaceFoldersChangeEvent) => void, then?: (_: Disposable) => void) => void

    /**
     * Returns the [workspace folder](#WorkspaceFolder) that contains a given uri.
     * * returns `undefined` when the given uri doesn't match any workspace folder
     * * returns the *input* when the given uri is a workspace folder itself

     * @param uri An uri.
     * @param then A workspace folder or `undefined`
     */
    GetWorkspaceFolder: (uri: string, then?: (_: WorkspaceFolder) => void) => void

    /**
     * List of workspace folders or `undefined` when no folder is open.
     * *Note* that the first entry corresponds to the value of `rootPath`.

     */
    WorkspaceFolders: (then?: (_: WorkspaceFolder[]) => void) => void

    /**
     * Find files across all [workspace folders](#workspace.workspaceFolders) in the workspace.
     * `findFiles('**​/*.js', '**​/node_modules/**', 10)`

     * @param include A [glob pattern](#GlobPattern) that defines the files to search for. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. Use a [relative pattern](#RelativePattern) to restrict the search results to a [workspace folder](#WorkspaceFolder).
     * @param exclude A [glob pattern](#GlobPattern) that defines files and folders to exclude. The glob pattern will be matched against the file paths of resulting matches relative to their workspace. When `undefined` only default excludes will apply, when `null` no excludes will apply.
     * @param maxResults An upper-bound for the result.
     * @param token A token that can be used to signal cancellation to the underlying search engine.
     * @param then A thenable that resolves to an array of resource identifiers. Will return no results if no [workspace folders](#workspace.workspaceFolders) are opened.
     */
    FindFiles: (include: GlobPattern, exclude?: GlobPattern, maxResults?: number, token?: Cancel, then?: (_: string[]) => void) => void

    /**
     * Returns a path that is relative to the workspace folder or folders.
     * 
     * When there are no [workspace folders](#workspace.workspaceFolders) or when the path
     * is not contained in them, the input is returned.

     * @param pathOrUri A path or uri. When a uri is given its [fsPath](#Uri.fsPath) is used.
     * @param includeWorkspaceFolder When `true` and when the given path is contained inside a workspace folder the name of the workspace is prepended. Defaults to `true` when there are multiple workspace folders and `false` otherwise.
     * @param then A path relative to the root or the input.
     */
    AsRelativePath: (pathOrUri: string, includeWorkspaceFolder: boolean, then?: (_: string) => void) => void

    /**
     * Provides single-call access to numerous individual `Workspace` properties at once.

     */
    Properties: (then: (_: WorkspaceProperties) => void) => void
}

/**
 * Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
 * like IntelliSense, code actions, diagnostics etc.
 * 
 * Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
 * like automatic word-completion, code navigation, or code checking have become popular across different tools for different
 * programming languages.
 * 
 * The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
 * by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
 * that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
 * mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
 * 
 * ```javascript
 * languages.registerHoverProvider('javascript', {
 *  	provideHover(document, position, token) {
 *  		return new Hover('I am a hover!');
 *  	}
 * });
 * ```
 * 
 * Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
 * a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
 * a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
 * scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
 * the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
 * score is used for determining the order in which providers are asked to participate.

 */
export interface Languages {
    /**
     * Return the identifiers of all known languages.

     * @param then Promise resolving to an array of identifier strings.
     */
    GetLanguages: (then?: (_: string[]) => void) => void

    /**
     * An [event](#Event) which fires when the global set of diagnostics changes. This is
     * newly added and removed diagnostics.

     */
    OnDidChangeDiagnostics: (listener: (_: DiagnosticChangeEvent) => void, then?: (_: Disposable) => void) => void
}

/**
 * Namespace for dealing with installed extensions. Extensions are represented
 * by an [extension](#Extension)-interface which enables reflection on them.
 * 
 * Extension writers can provide APIs to other extensions by returning their API public
 * surface from the `activate`-call.
 * 
 * ```javascript
 * export function activate(context: vscode.ExtensionContext) {
 *  	let api = {
 *  		sum(a, b) {
 *  			return a + b;
 *  		},
 *  		mul(a, b) {
 *  			return a * b;
 *  		}
 *  	};
 *  	// 'export' public api-surface
 *  	return api;
 * }
 * ```
 * When depending on the API of another extension add an `extensionDependency`-entry
 * to `package.json`, and use the [getExtension](#extensions.getExtension)-function
 * and the [exports](#Extension.exports)-property, like below:
 * 
 * ```javascript
 * let mathExt = extensions.getExtension('genius.math');
 * let importedApi = mathExt.exports;
 * 
 * console.log(importedApi.mul(42, 1));
 * ```

 */
export interface Extensions {
    /**
     * An event which fires when `extensions.all` changes. This can happen when extensions are
     * installed, uninstalled, enabled or disabled.

     */
    OnDidChange: (listener: () => void, then?: (_: Disposable) => void) => void
}

/**
 * Namespace for dealing with commands. In short, a command is a function with a
 * unique identifier. The function is sometimes also called _command handler_.
 * 
 * Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
 * and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
 * can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
 * 
 * * palette - Use the `commands`-section in `package.json` to make a command show in
 * the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
 * * keybinding - Use the `keybindings`-section in `package.json` to enable
 * [keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_customizing-shortcuts)
 * for your extension.
 * 
 * Commands from other extensions and from the editor itself are accessible to an extension. However,
 * when invoking an editor command not all argument types are supported.
 * 
 * This is a sample that registers a command handler and adds an entry for that command to the palette. First
 * register a command handler with the identifier `extension.sayHello`.
 * ```javascript
 * commands.registerCommand('extension.sayHello', () => {
 *  	window.showInformationMessage('Hello World!');
 * });
 * ```
 * Second, bind the command identifier to a title under which it will show in the palette (`package.json`).
 * ```json
 * {
 *  	"contributes": {
 *  		"commands": [{
 *  			"command": "extension.sayHello",
 *  			"title": "Hello World"
 *  		}]
 *  	}
 * }
 * ```

 */
export interface Commands {
    /**
     * Retrieve the list of all available commands. Commands starting an underscore are
     * treated as internal commands.

     * @param filterInternal Set `true` to not see internal commands (starting with an underscore)
     * @param then Thenable that resolves to a list of command ids.
     */
    GetCommands: (filterInternal: boolean, then?: (_: string[]) => void) => void
}



/**
 * Options to configure the behavior of the message.

 */
MessageOptions: class

    /**
     * Indicates that this message should be modal.

     */
    #
    # JSON FLAGS: {"Name":"modal","Required":false,"Excluded":false}
    Modal: boolean




/**
 * Represents an action that is shown with an information, warning, or
 * error message.

 */
MessageItem: class

    /**
     * A short title like 'Retry', 'Open Log' etc.

     */
    #
    # JSON FLAGS: {"Name":"title","Required":true,"Excluded":false}
    Title: string

    /**
     * A hint for modal dialogs that the item should be triggered
     * when the user cancels the dialog (e.g. by pressing the ESC
     * key).
     * 
     * Note: this option is ignored for non-modal messages.

     */
    #
    # JSON FLAGS: {"Name":"isCloseAffordance","Required":false,"Excluded":false}
    IsCloseAffordance: boolean

    /**
     * Free-form custom data, preserved across a roundtrip.

     */
    #
    # JSON FLAGS: {"Name":"my","Required":false,"Excluded":false}
    My: { [_:string]:any}




/**
 * Options to configure the behavior of the input box UI.

 */
InputBoxOptions: class

    /**
     * The value to prefill in the input box.

     */
    #
    # JSON FLAGS: {"Name":"value","Required":false,"Excluded":false}
    Value: string

    /**
     * Selection of the prefilled [`value`](#InputBoxOptions.value). Defined as tuple of two number where the
     * first is the inclusive start index and the second the exclusive end index. When `undefined` the whole
     * word will be selected, when empty (start equals end) only the cursor will be set,
     * otherwise the defined range will be selected.

     */
    #
    # JSON FLAGS: {"Name":"valueSelection","Required":false,"Excluded":false}
    ValueSelection: [number, number]

    /**
     * The text to display underneath the input box.

     */
    #
    # JSON FLAGS: {"Name":"prompt","Required":false,"Excluded":false}
    Prompt: string

    /**
     * An optional string to show as place holder in the input box to guide the user what to type.

     */
    #
    # JSON FLAGS: {"Name":"placeHolder","Required":false,"Excluded":false}
    PlaceHolder: string

    /**
     * Set to `true` to show a password prompt that will not show the typed value.

     */
    #
    # JSON FLAGS: {"Name":"password","Required":false,"Excluded":false}
    Password: boolean

    /**
     * Set to `true` to keep the input box open when focus moves to another part of the editor or to another window.

     */
    #
    # JSON FLAGS: {"Name":"ignoreFocusOut","Required":false,"Excluded":false}
    IgnoreFocusOut: boolean

    /**
     * An optional function that will be called to validate input and to give a hint
     * to the user.
     * 
     * `value` ── The current value of the input box.
     * 
     * `return` ── A human readable string which is presented as diagnostic message.
     * Return `undefined`, `null`, or the empty string when 'value' is valid.

     */
    #
    # JSON FLAGS: {"Name":"validateInput","Required":false,"Excluded":true}
    ValidateInput: (_: string) => string

    /**
     * For internal runtime use only.

     */
    #
    # JSON FLAGS: {"Name":"validateInput_AppzFuncId","Required":false,"Excluded":false}
    ValidateInput_AppzFuncId: string




/**
 * Options to configure the behavior of the quick pick UI.

 */
QuickPickOptions: class

    /**
     * An optional flag to include the description when filtering the picks.

     */
    #
    # JSON FLAGS: {"Name":"matchOnDescription","Required":false,"Excluded":false}
    MatchOnDescription: boolean

    /**
     * An optional flag to include the detail when filtering the picks.

     */
    #
    # JSON FLAGS: {"Name":"matchOnDetail","Required":false,"Excluded":false}
    MatchOnDetail: boolean

    /**
     * An optional string to show as place holder in the input box to guide the user what to pick on.

     */
    #
    # JSON FLAGS: {"Name":"placeHolder","Required":false,"Excluded":false}
    PlaceHolder: string

    /**
     * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.

     */
    #
    # JSON FLAGS: {"Name":"ignoreFocusOut","Required":false,"Excluded":false}
    IgnoreFocusOut: boolean

    /**
     * An optional flag to make the picker accept multiple selections, if true the result is an array of picks.

     */
    #
    # JSON FLAGS: {"Name":"canPickMany","Required":false,"Excluded":false}
    CanPickMany: boolean

    /**
     * An optional function that is invoked whenever an item is selected.

     */
    #
    # JSON FLAGS: {"Name":"onDidSelectItem","Required":false,"Excluded":true}
    OnDidSelectItem: (_: QuickPickItem) => any

    /**
     * For internal runtime use only.

     */
    #
    # JSON FLAGS: {"Name":"onDidSelectItem_AppzFuncId","Required":false,"Excluded":false}
    OnDidSelectItem_AppzFuncId: string




/**
 * Represents an item that can be selected from
 * a list of items.

 */
QuickPickItem: class

    /**
     * A human readable string which is rendered prominent.

     */
    #
    # JSON FLAGS: {"Name":"label","Required":true,"Excluded":false}
    Label: string

    /**
     * A human readable string which is rendered less prominent.

     */
    #
    # JSON FLAGS: {"Name":"description","Required":false,"Excluded":false}
    Description: string

    /**
     * A human readable string which is rendered less prominent.

     */
    #
    # JSON FLAGS: {"Name":"detail","Required":false,"Excluded":false}
    Detail: string

    /**
     * Optional flag indicating if this item is picked initially.
     * (Only honored when the picker allows multiple selections.)

     */
    #
    # JSON FLAGS: {"Name":"picked","Required":false,"Excluded":false}
    Picked: boolean

    /**
     * Always show this item.

     */
    #
    # JSON FLAGS: {"Name":"alwaysShow","Required":false,"Excluded":false}
    AlwaysShow: boolean

    /**
     * Free-form custom data, preserved across a roundtrip.

     */
    #
    # JSON FLAGS: {"Name":"my","Required":false,"Excluded":false}
    My: { [_:string]:any}




/**
 * Options to configure the behaviour of a file save dialog.

 */
SaveDialogOptions: class

    /**
     * The resource the dialog shows when opened.

     */
    #
    # JSON FLAGS: {"Name":"defaultUri","Required":false,"Excluded":false}
    DefaultUri: string

    /**
     * A human-readable string for the save button.

     */
    #
    # JSON FLAGS: {"Name":"saveLabel","Required":false,"Excluded":false}
    SaveLabel: string

    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions, e.g.
     * ```ts
     * {
     *  	'Images': ['png', 'jpg']
     *  	'TypeScript': ['ts', 'tsx']
     * }
     * ```

     */
    #
    # JSON FLAGS: {"Name":"filters","Required":false,"Excluded":false}
    Filters: { [_:string]: string[]}




/**
 * Options to configure the behaviour of a file open dialog.
 * 
 * * Note 1: A dialog can select files, folders, or both. This is not true for Windows
 * which enforces to open either files or folder, but *not both*.
 * * Note 2: Explicitly setting `canSelectFiles` and `canSelectFolders` to `false` is futile
 * and the editor then silently adjusts the options to select files.

 */
OpenDialogOptions: class

    /**
     * The resource the dialog shows when opened.

     */
    #
    # JSON FLAGS: {"Name":"defaultUri","Required":false,"Excluded":false}
    DefaultUri: string

    /**
     * A human-readable string for the open button.

     */
    #
    # JSON FLAGS: {"Name":"openLabel","Required":false,"Excluded":false}
    OpenLabel: string

    /**
     * Allow to select files, defaults to `true`.

     */
    #
    # JSON FLAGS: {"Name":"canSelectFiles","Required":false,"Excluded":false}
    CanSelectFiles: boolean

    /**
     * Allow to select folders, defaults to `false`.

     */
    #
    # JSON FLAGS: {"Name":"canSelectFolders","Required":false,"Excluded":false}
    CanSelectFolders: boolean

    /**
     * Allow to select many files or folders.

     */
    #
    # JSON FLAGS: {"Name":"canSelectMany","Required":false,"Excluded":false}
    CanSelectMany: boolean

    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions, e.g.
     * ```ts
     * {
     *  	'Images': ['png', 'jpg']
     *  	'TypeScript': ['ts', 'tsx']
     * }
     * ```

     */
    #
    # JSON FLAGS: {"Name":"filters","Required":false,"Excluded":false}
    Filters: { [_:string]: string[]}




/**
 * Options to configure the behaviour of the [workspace folder](#WorkspaceFolder) pick UI.

 */
WorkspaceFolderPickOptions: class

    /**
     * An optional string to show as place holder in the input box to guide the user what to pick on.

     */
    #
    # JSON FLAGS: {"Name":"placeHolder","Required":false,"Excluded":false}
    PlaceHolder: string

    /**
     * Set to `true` to keep the picker open when focus moves to another part of the editor or to another window.

     */
    #
    # JSON FLAGS: {"Name":"ignoreFocusOut","Required":false,"Excluded":false}
    IgnoreFocusOut: boolean




/**
 * A workspace folder is one of potentially many roots opened by the editor. All workspace folders
 * are equal which means there is no notion of an active or master workspace folder.

 */
WorkspaceFolder: class

    /**
     * The associated uri for this workspace folder.
     * 
     * *Note:* The [Uri](#Uri)-type was intentionally chosen such that future releases of the editor can support
     * workspace folders that are not stored on the local disk, e.g. `ftp://server/workspaces/foo`.

     */
    #
    # JSON FLAGS: {"Name":"uri","Required":true,"Excluded":false}
    Uri: string

    /**
     * The name of this workspace folder. Defaults to
     * the basename of its [uri-path](#Uri.path)

     */
    #
    # JSON FLAGS: {"Name":"name","Required":true,"Excluded":false}
    Name: string

    /**
     * The ordinal number of this workspace folder.

     */
    #
    # JSON FLAGS: {"Name":"index","Required":true,"Excluded":false}
    Index: number




/**
 * Represents the state of a window.

 */
WindowState: class

    /**
     * Whether the current window is focused.

     */
    #
    # JSON FLAGS: {"Name":"focused","Required":true,"Excluded":false}
    Focused: boolean




/**
 * An event describing a change to the set of [workspace folders](#workspace.workspaceFolders).

 */
WorkspaceFoldersChangeEvent: class

    /**
     * Added workspace folders.

     */
    #
    # JSON FLAGS: {"Name":"added","Required":true,"Excluded":false}
    Added: WorkspaceFolder[]

    /**
     * Removed workspace folders.

     */
    #
    # JSON FLAGS: {"Name":"removed","Required":true,"Excluded":false}
    Removed: WorkspaceFolder[]




/**
 * The event that is fired when diagnostics change.

 */
DiagnosticChangeEvent: class

    /**
     * An array of resources for which diagnostics have changed.

     */
    #
    # JSON FLAGS: {"Name":"uris","Required":true,"Excluded":false}
    Uris: string[]




/**
 * Namespace describing the environment the editor runs in.

 */
EnvProperties: class

    /**
     * The application name of the editor, like 'VS Code'.

     */
    #
    # JSON FLAGS: {"Name":"appName","Required":false,"Excluded":false}
    AppName: string

    /**
     * The application root folder from which the editor is running.

     */
    #
    # JSON FLAGS: {"Name":"appRoot","Required":false,"Excluded":false}
    AppRoot: string

    /**
     * Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.

     */
    #
    # JSON FLAGS: {"Name":"language","Required":false,"Excluded":false}
    Language: string

    /**
     * A unique identifier for the computer.

     */
    #
    # JSON FLAGS: {"Name":"machineId","Required":false,"Excluded":false}
    MachineId: string

    /**
     * The name of a remote. Defined by extensions, popular samples are `wsl` for the Windows
     * Subsystem for Linux or `ssh-remote` for remotes using a secure shell.
     * 
     * *Note* that the value is `undefined` when there is no remote extension host but that the
     * value is defined in all extension hosts (local and remote) in case a remote extension host
     * exists. Use [`Extension#extensionKind`](#Extension.extensionKind) to know if
     * a specific extension runs remote or not.

     */
    #
    # JSON FLAGS: {"Name":"remoteName","Required":false,"Excluded":false}
    RemoteName: string

    /**
     * A unique identifier for the current session.
     * Changes each time the editor is started.

     */
    #
    # JSON FLAGS: {"Name":"sessionId","Required":false,"Excluded":false}
    SessionId: string

    /**
     * The detected default shell for the extension host, this is overridden by the
     * `terminal.integrated.shell` setting for the extension host's platform.

     */
    #
    # JSON FLAGS: {"Name":"shell","Required":false,"Excluded":false}
    Shell: string

    /**
     * The custom uri scheme the editor registers to in the operating system.

     */
    #
    # JSON FLAGS: {"Name":"uriScheme","Required":false,"Excluded":false}
    UriScheme: string




/**
 * Namespace for dealing with the current workspace. A workspace is the representation
 * of the folder that has been opened. There is no workspace when just a file but not a
 * folder has been opened.
 * 
 * The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
 * events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
 * the editor-process so that they should be always used instead of nodejs-equivalents.

 */
WorkspaceProperties: class

    /**
     * The name of the workspace. `undefined` when no folder
     * has been opened.

     */
    #
    # JSON FLAGS: {"Name":"name","Required":false,"Excluded":false}
    Name: string

    /**
     * The location of the workspace file, for example:
     * 
     * `file:///Users/name/Development/myProject.code-workspace`
     * 
     * or
     * 
     * `untitled:1555503116870`
     * 
     * for a workspace that is untitled and not yet saved.
     * 
     * Depending on the workspace that is opened, the value will be:
     *   * `undefined` when no workspace or  a single folder is opened
     *   * the path of the workspace file as `Uri` otherwise. if the workspace
     * is untitled, the returned URI will use the `untitled:` scheme
     * 
     * The location can e.g. be used with the `vscode.openFolder` command to
     * open the workspace again after it has been closed.
     * 
     * **Example:**
     * ```typescript
     * vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
     * ```
     * 
     * **Note:** it is not advised to use `workspace.workspaceFile` to write
     * configuration data into the file. You can use `workspace.getConfiguration().update()`
     * for that purpose which will work both when a single folder is opened as
     * well as an untitled or saved workspace.

     */
    #
    # JSON FLAGS: {"Name":"workspaceFile","Required":false,"Excluded":false}
    WorkspaceFile: string

    /**
     * List of workspace folders or `undefined` when no folder is open.
     * *Note* that the first entry corresponds to the value of `rootPath`.

     */
    #
    # JSON FLAGS: {"Name":"workspaceFolders","Required":false,"Excluded":false}
    WorkspaceFolders: WorkspaceFolder[]




Vscode·Window: ( -> Window)
    return ((this)·(implWindow))




Vscode·Env: ( -> Env)
    return ((this)·(implEnv))




Vscode·Workspace: ( -> Workspace)
    return ((this)·(implWorkspace))




Vscode·Languages: ( -> Languages)
    return ((this)·(implLanguages))




Vscode·Extensions: ( -> Extensions)
    return ((this)·(implExtensions))




Vscode·Commands: ( -> Commands)
    return ((this)·(implCommands))




Window·ShowInformationMessage1: (message:string -> items:string[] -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showInformationMessage1"
    msg.Data = dict·new(2)
    msg.Data@"message" = message
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowInformationMessage2: (message:string -> options:MessageOptions -> items:string[] -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showInformationMessage2"
    msg.Data = dict·new(3)
    msg.Data@"message" = message
    msg.Data@"options" = options
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowInformationMessage3: (message:string -> items:MessageItem[] -> then:(_: MessageItem) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showInformationMessage3"
    msg.Data = dict·new(2)
    msg.Data@"message" = message
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of MessageItem
            if (=?payload)
                result = MessageItem·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowInformationMessage4: (message:string -> options:MessageOptions -> items:MessageItem[] -> then:(_: MessageItem) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showInformationMessage4"
    msg.Data = dict·new(3)
    msg.Data@"message" = message
    msg.Data@"options" = options
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of MessageItem
            if (=?payload)
                result = MessageItem·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowWarningMessage1: (message:string -> items:string[] -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showWarningMessage1"
    msg.Data = dict·new(2)
    msg.Data@"message" = message
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowWarningMessage2: (message:string -> options:MessageOptions -> items:string[] -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showWarningMessage2"
    msg.Data = dict·new(3)
    msg.Data@"message" = message
    msg.Data@"options" = options
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowWarningMessage3: (message:string -> items:MessageItem[] -> then:(_: MessageItem) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showWarningMessage3"
    msg.Data = dict·new(2)
    msg.Data@"message" = message
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of MessageItem
            if (=?payload)
                result = MessageItem·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowWarningMessage4: (message:string -> options:MessageOptions -> items:MessageItem[] -> then:(_: MessageItem) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showWarningMessage4"
    msg.Data = dict·new(3)
    msg.Data@"message" = message
    msg.Data@"options" = options
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of MessageItem
            if (=?payload)
                result = MessageItem·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowErrorMessage1: (message:string -> items:string[] -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showErrorMessage1"
    msg.Data = dict·new(2)
    msg.Data@"message" = message
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowErrorMessage2: (message:string -> options:MessageOptions -> items:string[] -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showErrorMessage2"
    msg.Data = dict·new(3)
    msg.Data@"message" = message
    msg.Data@"options" = options
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowErrorMessage3: (message:string -> items:MessageItem[] -> then:(_: MessageItem) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showErrorMessage3"
    msg.Data = dict·new(2)
    msg.Data@"message" = message
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of MessageItem
            if (=?payload)
                result = MessageItem·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowErrorMessage4: (message:string -> options:MessageOptions -> items:MessageItem[] -> then:(_: MessageItem) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showErrorMessage4"
    msg.Data = dict·new(3)
    msg.Data@"message" = message
    msg.Data@"options" = options
    msg.Data@"items" = items
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of MessageItem
            if (=?payload)
                result = MessageItem·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowInputBox: (options:InputBoxOptions -> token:Cancel -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showInputBox"
    msg.Data = dict·new(2)
    var fnids of string[]
    fnids = [string]·new(1)
    if (=?options)
        options.ValidateInput_AppzFuncId = ""
        var fn of (_: string) => string
        fn = options.ValidateInput
        if (=?fn)
            lock this
                options.ValidateInput_AppzFuncId = this.nextFuncId()
                fnids·add(options.ValidateInput_AppzFuncId)
                this.cbOther@options.ValidateInput_AppzFuncId = (args:any[] -> [any, boolean])
                    if (1 != args·len)
                        return [null,false]
                    else
                        var ok of boolean
                        var __0 of string
                        if (=?args@0)
                            [__0,ok] = ((args@0)·(string))
                            if (!ok)
                                return [null,false]
                        return [fn(__0),true]
                
    msg.Data@"options" = options
    if (=?token)
        token.impl = this.Impl()
        if ("" == token.fnId)
            lock this
                token.fnId = this.nextFuncId()
        msg.Data@"token" = token.fnId
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, (payload:any -> boolean)
        if (fnids·len != 0)
            lock this
                for fnid in fnids
                    this.cbOther·del(fnid)
        return ((=!on) || on(payload))
    )




Window·ShowQuickPick1: (items:string[] -> options:QuickPickOptions -> token:Cancel -> then:(_: string[]) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showQuickPick1"
    msg.Data = dict·new(3)
    var fnids of string[]
    fnids = [string]·new(1)
    if true
        options.OnDidSelectItem_AppzFuncId = ""
        var fn of (_: QuickPickItem) => any
        fn = options.OnDidSelectItem
        if (=?fn)
            lock this
                options.OnDidSelectItem_AppzFuncId = this.nextFuncId()
                fnids·add(options.OnDidSelectItem_AppzFuncId)
                this.cbOther@options.OnDidSelectItem_AppzFuncId = (args:any[] -> [any, boolean])
                    if (1 != args·len)
                        return [null,false]
                    else
                        var ok of boolean
                        var __0 of QuickPickItem
                        if (=?args@0)
                            __0 = QuickPickItem·new
                            ok = __0.populateFrom(args@0)
                            if (!ok)
                                return [null,false]
                        else
                            return [null,false]
                        return [fn(__0),true]
                
    msg.Data@"items" = items
    options.CanPickMany = true
    msg.Data@"options" = options
    if (=?token)
        token.impl = this.Impl()
        if ("" == token.fnId)
            lock this
                token.fnId = this.nextFuncId()
        msg.Data@"token" = token.fnId
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string[]
            if (=?payload)
                var __coll__result of any[]
                [__coll__result,ok] = ((payload)·(any[]))
                if (!ok)
                    return false
                result = [string]·new(__coll__result·len)
                var __idx__result of number
                __idx__result = 0
                for __item__result in __coll__result
                    var __val__result of string
                    [__val__result,ok] = ((__item__result)·(string))
                    if (!ok)
                        return false
                    result@__idx__result = __val__result
                    __idx__result = (__idx__result + 1)
            then(result)
            return true
        
    this.send(msg, (payload:any -> boolean)
        if (fnids·len != 0)
            lock this
                for fnid in fnids
                    this.cbOther·del(fnid)
        return ((=!on) || on(payload))
    )




Window·ShowQuickPick2: (items:string[] -> options:QuickPickOptions -> token:Cancel -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showQuickPick2"
    msg.Data = dict·new(3)
    var fnids of string[]
    fnids = [string]·new(1)
    if (=?options)
        options.OnDidSelectItem_AppzFuncId = ""
        var fn of (_: QuickPickItem) => any
        fn = options.OnDidSelectItem
        if (=?fn)
            lock this
                options.OnDidSelectItem_AppzFuncId = this.nextFuncId()
                fnids·add(options.OnDidSelectItem_AppzFuncId)
                this.cbOther@options.OnDidSelectItem_AppzFuncId = (args:any[] -> [any, boolean])
                    if (1 != args·len)
                        return [null,false]
                    else
                        var ok of boolean
                        var __0 of QuickPickItem
                        if (=?args@0)
                            __0 = QuickPickItem·new
                            ok = __0.populateFrom(args@0)
                            if (!ok)
                                return [null,false]
                        else
                            return [null,false]
                        return [fn(__0),true]
                
    msg.Data@"items" = items
    msg.Data@"options" = options
    if (=?token)
        token.impl = this.Impl()
        if ("" == token.fnId)
            lock this
                token.fnId = this.nextFuncId()
        msg.Data@"token" = token.fnId
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, (payload:any -> boolean)
        if (fnids·len != 0)
            lock this
                for fnid in fnids
                    this.cbOther·del(fnid)
        return ((=!on) || on(payload))
    )




Window·ShowQuickPick3: (items:QuickPickItem[] -> options:QuickPickOptions -> token:Cancel -> then:(_: QuickPickItem[]) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showQuickPick3"
    msg.Data = dict·new(3)
    var fnids of string[]
    fnids = [string]·new(1)
    if true
        options.OnDidSelectItem_AppzFuncId = ""
        var fn of (_: QuickPickItem) => any
        fn = options.OnDidSelectItem
        if (=?fn)
            lock this
                options.OnDidSelectItem_AppzFuncId = this.nextFuncId()
                fnids·add(options.OnDidSelectItem_AppzFuncId)
                this.cbOther@options.OnDidSelectItem_AppzFuncId = (args:any[] -> [any, boolean])
                    if (1 != args·len)
                        return [null,false]
                    else
                        var ok of boolean
                        var __0 of QuickPickItem
                        if (=?args@0)
                            __0 = QuickPickItem·new
                            ok = __0.populateFrom(args@0)
                            if (!ok)
                                return [null,false]
                        else
                            return [null,false]
                        return [fn(__0),true]
                
    msg.Data@"items" = items
    options.CanPickMany = true
    msg.Data@"options" = options
    if (=?token)
        token.impl = this.Impl()
        if ("" == token.fnId)
            lock this
                token.fnId = this.nextFuncId()
        msg.Data@"token" = token.fnId
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of QuickPickItem[]
            if (=?payload)
                var __coll__result of any[]
                [__coll__result,ok] = ((payload)·(any[]))
                if (!ok)
                    return false
                result = [QuickPickItem]·new(__coll__result·len)
                var __idx__result of number
                __idx__result = 0
                for __item__result in __coll__result
                    var __val__result of QuickPickItem
                    __val__result = QuickPickItem·new
                    ok = __val__result.populateFrom(__item__result)
                    if (!ok)
                        return false
                    result@__idx__result = __val__result
                    __idx__result = (__idx__result + 1)
            then(result)
            return true
        
    this.send(msg, (payload:any -> boolean)
        if (fnids·len != 0)
            lock this
                for fnid in fnids
                    this.cbOther·del(fnid)
        return ((=!on) || on(payload))
    )




Window·ShowQuickPick4: (items:QuickPickItem[] -> options:QuickPickOptions -> token:Cancel -> then:(_: QuickPickItem) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showQuickPick4"
    msg.Data = dict·new(3)
    var fnids of string[]
    fnids = [string]·new(1)
    if (=?options)
        options.OnDidSelectItem_AppzFuncId = ""
        var fn of (_: QuickPickItem) => any
        fn = options.OnDidSelectItem
        if (=?fn)
            lock this
                options.OnDidSelectItem_AppzFuncId = this.nextFuncId()
                fnids·add(options.OnDidSelectItem_AppzFuncId)
                this.cbOther@options.OnDidSelectItem_AppzFuncId = (args:any[] -> [any, boolean])
                    if (1 != args·len)
                        return [null,false]
                    else
                        var ok of boolean
                        var __0 of QuickPickItem
                        if (=?args@0)
                            __0 = QuickPickItem·new
                            ok = __0.populateFrom(args@0)
                            if (!ok)
                                return [null,false]
                        else
                            return [null,false]
                        return [fn(__0),true]
                
    msg.Data@"items" = items
    msg.Data@"options" = options
    if (=?token)
        token.impl = this.Impl()
        if ("" == token.fnId)
            lock this
                token.fnId = this.nextFuncId()
        msg.Data@"token" = token.fnId
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of QuickPickItem
            if (=?payload)
                result = QuickPickItem·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, (payload:any -> boolean)
        if (fnids·len != 0)
            lock this
                for fnid in fnids
                    this.cbOther·del(fnid)
        return ((=!on) || on(payload))
    )




Window·SetStatusBarMessage1: (text:string -> hideAfterTimeout:number -> then:(_: Disposable) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.setStatusBarMessage1"
    msg.Data = dict·new(2)
    msg.Data@"text" = text
    msg.Data@"hideAfterTimeout" = hideAfterTimeout
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of Disposable
            if (=?payload)
                result = Disposable·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result.bind(this.Impl(), ""))
            return true
        
    this.send(msg, on)




Window·SetStatusBarMessage2: (text:string -> then:(_: Disposable) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.setStatusBarMessage2"
    msg.Data = dict·new(1)
    msg.Data@"text" = text
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of Disposable
            if (=?payload)
                result = Disposable·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result.bind(this.Impl(), ""))
            return true
        
    this.send(msg, on)




Window·ShowSaveDialog: (options:SaveDialogOptions -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showSaveDialog"
    msg.Data = dict·new(1)
    msg.Data@"options" = options
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowOpenDialog: (options:OpenDialogOptions -> then:(_: string[]) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showOpenDialog"
    msg.Data = dict·new(1)
    msg.Data@"options" = options
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string[]
            if (=?payload)
                var __coll__result of any[]
                [__coll__result,ok] = ((payload)·(any[]))
                if (!ok)
                    return false
                result = [string]·new(__coll__result·len)
                var __idx__result of number
                __idx__result = 0
                for __item__result in __coll__result
                    var __val__result of string
                    [__val__result,ok] = ((__item__result)·(string))
                    if (!ok)
                        return false
                    result@__idx__result = __val__result
                    __idx__result = (__idx__result + 1)
            then(result)
            return true
        
    this.send(msg, on)




Window·ShowWorkspaceFolderPick: (options:WorkspaceFolderPickOptions -> then:(_: WorkspaceFolder) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.showWorkspaceFolderPick"
    msg.Data = dict·new(1)
    msg.Data@"options" = options
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of WorkspaceFolder
            if (=?payload)
                result = WorkspaceFolder·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·State: (then:(_: WindowState) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.state"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of WindowState
            if (=?payload)
                result = WindowState·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Window·OnDidChangeWindowState: (listener:(_: WindowState) => void -> then:(_: Disposable) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "window.onDidChangeWindowState"
    msg.Data = dict·new(1)
    var _fnid_listener of string
    if (=!listener)
        OnError(this, "Window.OnDidChangeWindowState: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
        return 
    _fnid_listener = this.nextSub((args:any[] -> boolean)
        var ok of boolean
        if (1 != args·len)
            return ok
        var _a_0_ of WindowState
        _a_0_ = WindowState·new
        ok = _a_0_.populateFrom(args@0)
        if (!ok)
            return false
        listener(_a_0_)
        return true
    )
    msg.Data@"listener" = _fnid_listener
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of Disposable
            if (=?payload)
                result = Disposable·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result.bind(this.Impl(), _fnid_listener))
            return true
        
    this.send(msg, on)




Env·OpenExternal: (target:string -> then:(_: boolean) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.openExternal"
    msg.Data = dict·new(1)
    msg.Data@"target" = target
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of boolean
            if (=?payload)
                [result,ok] = ((payload)·(boolean))
                if (!ok)
                    return false
            else
                return false
            then(result)
            return true
        
    this.send(msg, on)




Env·AppName: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.appName"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                [result,ok] = ((payload)·(string))
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Env·AppRoot: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.appRoot"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                [result,ok] = ((payload)·(string))
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Env·Language: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.language"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                [result,ok] = ((payload)·(string))
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Env·MachineId: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.machineId"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                [result,ok] = ((payload)·(string))
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Env·RemoteName: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.remoteName"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Env·SessionId: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.sessionId"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                [result,ok] = ((payload)·(string))
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Env·Shell: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.shell"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                [result,ok] = ((payload)·(string))
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Env·UriScheme: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.uriScheme"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                [result,ok] = ((payload)·(string))
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Env·Properties: (then:(_: EnvProperties) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "env.Properties"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of EnvProperties
            if (=?payload)
                result = EnvProperties·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result)
            return true
        
    this.send(msg, on)




Workspace·Name: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.name"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Workspace·WorkspaceFile: (then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.workspaceFile"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Workspace·SaveAll: (includeUntitled:boolean -> then:(_: boolean) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.saveAll"
    msg.Data = dict·new(1)
    msg.Data@"includeUntitled" = includeUntitled
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of boolean
            if (=?payload)
                [result,ok] = ((payload)·(boolean))
                if (!ok)
                    return false
            else
                return false
            then(result)
            return true
        
    this.send(msg, on)




Workspace·OnDidChangeWorkspaceFolders: (listener:(_: WorkspaceFoldersChangeEvent) => void -> then:(_: Disposable) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.onDidChangeWorkspaceFolders"
    msg.Data = dict·new(1)
    var _fnid_listener of string
    if (=!listener)
        OnError(this, "Workspace.OnDidChangeWorkspaceFolders: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
        return 
    _fnid_listener = this.nextSub((args:any[] -> boolean)
        var ok of boolean
        if (1 != args·len)
            return ok
        var _a_0_ of WorkspaceFoldersChangeEvent
        _a_0_ = WorkspaceFoldersChangeEvent·new
        ok = _a_0_.populateFrom(args@0)
        if (!ok)
            return false
        listener(_a_0_)
        return true
    )
    msg.Data@"listener" = _fnid_listener
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of Disposable
            if (=?payload)
                result = Disposable·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result.bind(this.Impl(), _fnid_listener))
            return true
        
    this.send(msg, on)




Workspace·GetWorkspaceFolder: (uri:string -> then:(_: WorkspaceFolder) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.getWorkspaceFolder"
    msg.Data = dict·new(1)
    msg.Data@"uri" = uri
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of WorkspaceFolder
            if (=?payload)
                result = WorkspaceFolder·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            then(result)
            return true
        
    this.send(msg, on)




Workspace·WorkspaceFolders: (then:(_: WorkspaceFolder[]) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.workspaceFolders"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of WorkspaceFolder[]
            if (=?payload)
                var __coll__result of any[]
                [__coll__result,ok] = ((payload)·(any[]))
                if (!ok)
                    return false
                result = [WorkspaceFolder]·new(__coll__result·len)
                var __idx__result of number
                __idx__result = 0
                for __item__result in __coll__result
                    var __val__result of WorkspaceFolder
                    __val__result = WorkspaceFolder·new
                    ok = __val__result.populateFrom(__item__result)
                    if (!ok)
                        return false
                    result@__idx__result = __val__result
                    __idx__result = (__idx__result + 1)
            then(result)
            return true
        
    this.send(msg, on)




Workspace·FindFiles: (include:GlobPattern -> exclude:GlobPattern -> maxResults:number -> token:Cancel -> then:(_: string[]) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.findFiles"
    msg.Data = dict·new(4)
    msg.Data@"include" = include
    msg.Data@"exclude" = exclude
    msg.Data@"maxResults" = maxResults
    if (=?token)
        token.impl = this.Impl()
        if ("" == token.fnId)
            lock this
                token.fnId = this.nextFuncId()
        msg.Data@"token" = token.fnId
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string[]
            if (=?payload)
                var __coll__result of any[]
                [__coll__result,ok] = ((payload)·(any[]))
                if (!ok)
                    return false
                result = [string]·new(__coll__result·len)
                var __idx__result of number
                __idx__result = 0
                for __item__result in __coll__result
                    var __val__result of string
                    [__val__result,ok] = ((__item__result)·(string))
                    if (!ok)
                        return false
                    result@__idx__result = __val__result
                    __idx__result = (__idx__result + 1)
            then(result)
            return true
        
    this.send(msg, on)




Workspace·AsRelativePath: (pathOrUri:string -> includeWorkspaceFolder:boolean -> then:(_: string) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.asRelativePath"
    msg.Data = dict·new(2)
    msg.Data@"pathOrUri" = pathOrUri
    msg.Data@"includeWorkspaceFolder" = includeWorkspaceFolder
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string
            if (=?payload)
                var _result_ of string
                [_result_,ok] = ((payload)·(string))
                if (!ok)
                    return false
                result = (&_result_)
            then(result)
            return true
        
    this.send(msg, on)




Workspace·Properties: (then:(_: WorkspaceProperties) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "workspace.Properties"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of WorkspaceProperties
            if (=?payload)
                result = WorkspaceProperties·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result)
            return true
        
    this.send(msg, on)




Languages·GetLanguages: (then:(_: string[]) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "languages.getLanguages"
    msg.Data = dict·new(0)
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string[]
            if (=?payload)
                var __coll__result of any[]
                [__coll__result,ok] = ((payload)·(any[]))
                if (!ok)
                    return false
                result = [string]·new(__coll__result·len)
                var __idx__result of number
                __idx__result = 0
                for __item__result in __coll__result
                    var __val__result of string
                    [__val__result,ok] = ((__item__result)·(string))
                    if (!ok)
                        return false
                    result@__idx__result = __val__result
                    __idx__result = (__idx__result + 1)
            then(result)
            return true
        
    this.send(msg, on)




Languages·OnDidChangeDiagnostics: (listener:(_: DiagnosticChangeEvent) => void -> then:(_: Disposable) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "languages.onDidChangeDiagnostics"
    msg.Data = dict·new(1)
    var _fnid_listener of string
    if (=!listener)
        OnError(this, "Languages.OnDidChangeDiagnostics: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
        return 
    _fnid_listener = this.nextSub((args:any[] -> boolean)
        var ok of boolean
        if (1 != args·len)
            return ok
        var _a_0_ of DiagnosticChangeEvent
        _a_0_ = DiagnosticChangeEvent·new
        ok = _a_0_.populateFrom(args@0)
        if (!ok)
            return false
        listener(_a_0_)
        return true
    )
    msg.Data@"listener" = _fnid_listener
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of Disposable
            if (=?payload)
                result = Disposable·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result.bind(this.Impl(), _fnid_listener))
            return true
        
    this.send(msg, on)




Extensions·OnDidChange: (listener:() => void -> then:(_: Disposable) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "extensions.onDidChange"
    msg.Data = dict·new(1)
    var _fnid_listener of string
    if (=!listener)
        OnError(this, "Extensions.OnDidChange: the 'listener' arg (which is not optional but required) was not passed by the caller", null)
        return 
    _fnid_listener = this.nextSub((args:any[] -> boolean)
        var ok of boolean
        if (0 != args·len)
            return ok
        listener()
        return true
    )
    msg.Data@"listener" = _fnid_listener
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of Disposable
            if (=?payload)
                result = Disposable·new
                ok = result.populateFrom(payload)
                if (!ok)
                    return false
            else
                return false
            then(result.bind(this.Impl(), _fnid_listener))
            return true
        
    this.send(msg, on)




Commands·GetCommands: (filterInternal:boolean -> then:(_: string[]) => void -> void)
    var msg of ipcMsg
    msg = ipcMsg·new
    msg.QName = "commands.getCommands"
    msg.Data = dict·new(1)
    msg.Data@"filterInternal" = filterInternal
    var on of (_: any) => boolean
    if (=?then)
        on = (payload:any -> boolean)
            var ok of boolean
            var result of string[]
            if (=?payload)
                var __coll__result of any[]
                [__coll__result,ok] = ((payload)·(any[]))
                if (!ok)
                    return false
                result = [string]·new(__coll__result·len)
                var __idx__result of number
                __idx__result = 0
                for __item__result in __coll__result
                    var __val__result of string
                    [__val__result,ok] = ((__item__result)·(string))
                    if (!ok)
                        return false
                    result@__idx__result = __val__result
                    __idx__result = (__idx__result + 1)
            then(result)
            return true
        
    this.send(msg, on)




MessageItem·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"title"
    if ok
        var title of string
        if (=?val)
            [title,ok] = ((val)·(string))
            if (!ok)
                return false
        this.Title = title
    else
        return false
    [val,ok] = it@?"isCloseAffordance"
    if ok
        var isCloseAffordance of boolean
        if (=?val)
            var _isCloseAffordance_ of boolean
            [_isCloseAffordance_,ok] = ((val)·(boolean))
            if (!ok)
                return false
            isCloseAffordance = (&_isCloseAffordance_)
        this.IsCloseAffordance = isCloseAffordance
    [val,ok] = it@?"my"
    if ok
        var my of { [_:string]:any}
        if (=?val)
            [my,ok] = ((val)·({ [_:string]:any}))
            if (!ok)
                return false
        this.My = my
    return true




QuickPickItem·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"label"
    if ok
        var label of string
        if (=?val)
            [label,ok] = ((val)·(string))
            if (!ok)
                return false
        this.Label = label
    else
        return false
    [val,ok] = it@?"description"
    if ok
        var description of string
        if (=?val)
            var _description_ of string
            [_description_,ok] = ((val)·(string))
            if (!ok)
                return false
            description = (&_description_)
        this.Description = description
    [val,ok] = it@?"detail"
    if ok
        var detail of string
        if (=?val)
            var _detail_ of string
            [_detail_,ok] = ((val)·(string))
            if (!ok)
                return false
            detail = (&_detail_)
        this.Detail = detail
    [val,ok] = it@?"picked"
    if ok
        var picked of boolean
        if (=?val)
            var _picked_ of boolean
            [_picked_,ok] = ((val)·(boolean))
            if (!ok)
                return false
            picked = (&_picked_)
        this.Picked = picked
    [val,ok] = it@?"alwaysShow"
    if ok
        var alwaysShow of boolean
        if (=?val)
            var _alwaysShow_ of boolean
            [_alwaysShow_,ok] = ((val)·(boolean))
            if (!ok)
                return false
            alwaysShow = (&_alwaysShow_)
        this.AlwaysShow = alwaysShow
    [val,ok] = it@?"my"
    if ok
        var my of { [_:string]:any}
        if (=?val)
            [my,ok] = ((val)·({ [_:string]:any}))
            if (!ok)
                return false
        this.My = my
    return true




WorkspaceFolder·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"uri"
    if ok
        var uri of string
        if (=?val)
            [uri,ok] = ((val)·(string))
            if (!ok)
                return false
        this.Uri = uri
    else
        return false
    [val,ok] = it@?"name"
    if ok
        var name of string
        if (=?val)
            [name,ok] = ((val)·(string))
            if (!ok)
                return false
        this.Name = name
    else
        return false
    [val,ok] = it@?"index"
    if ok
        var index of number
        if (=?val)
            [index,ok] = ((val)·(number))
            if (!ok)
                var __index__ of number
                [__index__,ok] = ((val)·(number))
                if (!ok)
                    return false
                index = ((__index__)·(number))
        this.Index = index
    else
        return false
    return true




WindowState·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"focused"
    if ok
        var focused of boolean
        if (=?val)
            [focused,ok] = ((val)·(boolean))
            if (!ok)
                return false
        this.Focused = focused
    else
        return false
    return true




EnvProperties·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"appName"
    if ok
        var appName of string
        if (=?val)
            var _appName_ of string
            [_appName_,ok] = ((val)·(string))
            if (!ok)
                return false
            appName = (&_appName_)
        this.AppName = appName
    [val,ok] = it@?"appRoot"
    if ok
        var appRoot of string
        if (=?val)
            var _appRoot_ of string
            [_appRoot_,ok] = ((val)·(string))
            if (!ok)
                return false
            appRoot = (&_appRoot_)
        this.AppRoot = appRoot
    [val,ok] = it@?"language"
    if ok
        var language of string
        if (=?val)
            var _language_ of string
            [_language_,ok] = ((val)·(string))
            if (!ok)
                return false
            language = (&_language_)
        this.Language = language
    [val,ok] = it@?"machineId"
    if ok
        var machineId of string
        if (=?val)
            var _machineId_ of string
            [_machineId_,ok] = ((val)·(string))
            if (!ok)
                return false
            machineId = (&_machineId_)
        this.MachineId = machineId
    [val,ok] = it@?"remoteName"
    if ok
        var remoteName of string
        if (=?val)
            var _remoteName_ of string
            [_remoteName_,ok] = ((val)·(string))
            if (!ok)
                return false
            remoteName = (&_remoteName_)
        this.RemoteName = remoteName
    [val,ok] = it@?"sessionId"
    if ok
        var sessionId of string
        if (=?val)
            var _sessionId_ of string
            [_sessionId_,ok] = ((val)·(string))
            if (!ok)
                return false
            sessionId = (&_sessionId_)
        this.SessionId = sessionId
    [val,ok] = it@?"shell"
    if ok
        var shell of string
        if (=?val)
            var _shell_ of string
            [_shell_,ok] = ((val)·(string))
            if (!ok)
                return false
            shell = (&_shell_)
        this.Shell = shell
    [val,ok] = it@?"uriScheme"
    if ok
        var uriScheme of string
        if (=?val)
            var _uriScheme_ of string
            [_uriScheme_,ok] = ((val)·(string))
            if (!ok)
                return false
            uriScheme = (&_uriScheme_)
        this.UriScheme = uriScheme
    return true




WorkspaceFoldersChangeEvent·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"added"
    if ok
        var added of WorkspaceFolder[]
        if (=?val)
            var __coll__added of any[]
            [__coll__added,ok] = ((val)·(any[]))
            if (!ok)
                return false
            added = [WorkspaceFolder]·new(__coll__added·len)
            var __idx__added of number
            __idx__added = 0
            for __item__added in __coll__added
                var __val__added of WorkspaceFolder
                __val__added = WorkspaceFolder·new
                ok = __val__added.populateFrom(__item__added)
                if (!ok)
                    return false
                added@__idx__added = __val__added
                __idx__added = (__idx__added + 1)
        this.Added = added
    else
        return false
    [val,ok] = it@?"removed"
    if ok
        var removed of WorkspaceFolder[]
        if (=?val)
            var __coll__removed of any[]
            [__coll__removed,ok] = ((val)·(any[]))
            if (!ok)
                return false
            removed = [WorkspaceFolder]·new(__coll__removed·len)
            var __idx__removed of number
            __idx__removed = 0
            for __item__removed in __coll__removed
                var __val__removed of WorkspaceFolder
                __val__removed = WorkspaceFolder·new
                ok = __val__removed.populateFrom(__item__removed)
                if (!ok)
                    return false
                removed@__idx__removed = __val__removed
                __idx__removed = (__idx__removed + 1)
        this.Removed = removed
    else
        return false
    return true




WorkspaceProperties·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"name"
    if ok
        var name of string
        if (=?val)
            var _name_ of string
            [_name_,ok] = ((val)·(string))
            if (!ok)
                return false
            name = (&_name_)
        this.Name = name
    [val,ok] = it@?"workspaceFile"
    if ok
        var workspaceFile of string
        if (=?val)
            var _workspaceFile_ of string
            [_workspaceFile_,ok] = ((val)·(string))
            if (!ok)
                return false
            workspaceFile = (&_workspaceFile_)
        this.WorkspaceFile = workspaceFile
    [val,ok] = it@?"workspaceFolders"
    if ok
        var workspaceFolders of WorkspaceFolder[]
        if (=?val)
            var __coll__workspaceFolders of any[]
            [__coll__workspaceFolders,ok] = ((val)·(any[]))
            if (!ok)
                return false
            workspaceFolders = [WorkspaceFolder]·new(__coll__workspaceFolders·len)
            var __idx__workspaceFolders of number
            __idx__workspaceFolders = 0
            for __item__workspaceFolders in __coll__workspaceFolders
                var __val__workspaceFolders of WorkspaceFolder
                __val__workspaceFolders = WorkspaceFolder·new
                ok = __val__workspaceFolders.populateFrom(__item__workspaceFolders)
                if (!ok)
                    return false
                workspaceFolders@__idx__workspaceFolders = __val__workspaceFolders
                __idx__workspaceFolders = (__idx__workspaceFolders + 1)
        this.WorkspaceFolders = workspaceFolders
    return true




DiagnosticChangeEvent·populateFrom: (payload:any -> boolean)
    var it of { [_:string]:any}
    var ok of boolean
    var val of any
    [it,ok] = ((payload)·({ [_:string]:any}))
    if (!ok)
        return false
    [val,ok] = it@?"uris"
    if ok
        var uris of string[]
        if (=?val)
            var __coll__uris of any[]
            [__coll__uris,ok] = ((val)·(any[]))
            if (!ok)
                return false
            uris = [string]·new(__coll__uris·len)
            var __idx__uris of number
            __idx__uris = 0
            for __item__uris in __coll__uris
                var __val__uris of string
                [__val__uris,ok] = ((__item__uris)·(string))
                if (!ok)
                    return false
                uris@__idx__uris = __val__uris
                __idx__uris = (__idx__uris + 1)
        this.Uris = uris
    else
        return false
    return true


class implBase {
    impl: impl
    constructor(impl: impl) { this.impl = impl }
    send(msg: ipcMsg, on: (_: any) => boolean) { this.impl.send(msg, on) }
}
